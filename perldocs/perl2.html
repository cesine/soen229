<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>perldocs page 2</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
	<META NAME="CREATED" CONTENT="20030217;12042100">
	<META NAME="CHANGED" CONTENT="20030224;23095000">
</HEAD>
<BODY LANG="en-US" BGCOLOR="#888888">
<P STYLE="margin-bottom: 0cm"><A HREF="perl1.html">page 1</A><BR><A HREF="">page
2</A><BR><A HREF="perl3.html">page 3</A><BR><A HREF="perl4.html">page
4</A></P>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-10"></A>4.10 The use strict Pragma</H3>
			<P><A NAME="IXT-4-336058"></A><A NAME="IXT-4-336059"></A>Perl
			tends to be a pretty permissive language. But maybe you want Perl
			to impose a little discipline; that can be arranged with the <TT><FONT COLOR="#cc0000">use
			strict</FONT></TT> pragma. 
			</P>
			<P><A NAME="IXT-4-336060"></A><SPAN STYLE="background: #ffff99">A
			<I>pragma</I> is a hint to a compiler</SPAN>, telling it something
			about the code. In this case, the <TT><FONT COLOR="#cc0000">use
			strict</FONT></TT> pragma tells Perl's internal compiler that it
			should enforce some good programming rules for the rest of this
			block or source file. 
			</P>
			<P>Why would this be important? Well, imagine that you're
			composing your program, and you type a line like this one: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$bamm_bamm = 3;  # Perl creates that variable automatically</FONT></PRE><P>
			Now, you keep typing for a while. After that line has scrolled off
			the top of the screen, you type this line to increment the
			variable: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$bammbamm += 1;  # Oops!</FONT></PRE><P>
			<A NAME="IXT-4-336061"></A><A NAME="IXT-4-336062"></A>Since Perl
			sees a new variable name (the underscore is significant in a
			variable name), it creates a new variable and increments that one.
			If you're lucky and smart, you've turned on warnings, and <SPAN STYLE="background: #7da647">Perl
			can tell you that you used one or both of those global variable
			names only once in your program. </SPAN>But if you're merely
			smart, you used each name more than once, and Perl won't be able
			to warn you. 
			</P>
			<P>To tell Perl that you're ready to be more restrictive, put the
			<TT><FONT COLOR="#cc0000">use strict</FONT></TT> pragma at the top
			of your program (or in any block or file where you want to enforce
			these rules): 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">use strict;  # Enforce some good programming rules</FONT></PRE><P>
			Now, among other restrictions,<A HREF="#">[19]</A> <SPAN STYLE="background: #94bd5e">Perl
			will insist that you declare every new variable with </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">my</FONT></SPAN></TT>:<A HREF="#">[20]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[19]</SUP> To
			learn about the other restrictions, see the documentation for
			<TT><FONT COLOR="#cc0000">strict</FONT></TT>. The documentation
			for any pragma is filed under that pragma's name, so the command
			perldoc strict(or your system's native documentation method)
			should find it for you. In brief, the other restrictions require
			that strings be quoted in most cases, and that references be true
			(hard) references. Neither of these restrictions should affect
			beginners in Perl.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[20]</SUP>
			There are some other ways to declare variables, too.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $bamm_bamm = 3;  # New lexical variable</FONT></PRE><P>
			Now if you try to spell it the other way, Perl can complain that
			you haven't declared any variable called <TT><FONT COLOR="#cc0000">$bammbamm</FONT></TT>,
			so your mistake is automatically caught at compile time. 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$bammbamm += 1;  # No such variable: Compile time error</FONT></PRE><P>
			Of course, this applies only to new variables; Perl's builtin
			variables, such as <TT><FONT COLOR="#cc0000">$_</FONT></TT> and <TT><FONT COLOR="#cc0000">@_</FONT></TT>
			never need to be declared.<A HREF="#">[21]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[21]</SUP>
			And, at least in some circumstances, <TT><SPAN STYLE="background: #5c8526"><FONT COLOR="#cc0000">$a</FONT></SPAN></TT><SPAN STYLE="background: #5c8526">
			and </SPAN><TT><SPAN STYLE="background: #5c8526"><FONT COLOR="#cc0000">$b</FONT></SPAN></TT>
			won't need to be declared, <SPAN STYLE="background: #5c8526">because
			they're used internally by </SPAN><TT><SPAN STYLE="background: #5c8526"><FONT COLOR="#cc0000">sort</FONT></SPAN></TT><SPAN STYLE="background: #5c8526">.</SPAN>
			So if you're testing this feature, use other variable names than
			those two. The fact that <TT><FONT COLOR="#cc0000">use strict</FONT></TT>
			doesn't forbid these two is one of the most frequently reported
			non-bugs in Perl.</P>
			<P>If you add <TT><FONT COLOR="#cc0000">use strict</FONT></TT> to
			an already-written program, you'll generally get a flood of
			warning messages, so it's better to use it from the start, when
			it's needed. 
			</P>
			<P>Most people recommend that<SPAN STYLE="background: #ff6633">
			programs that are longer than a screenful of text </SPAN>generally
			need <TT><FONT COLOR="#cc0000">use strict</FONT></TT>. And we
			agree. 
			</P>
			<P><SPAN STYLE="background: #ff6633">From here on, most (but not
			all) of our examples will be written as if </SPAN><TT><TT><SPAN STYLE="background: #ff6633"><FONT COLOR="#cc0000">use
			strict</FONT></SPAN></TT></TT><SPAN STYLE="background: #ff6633">
			is in effect, even where we don't show it</SPAN>. That is, we'll
			generally declare variables with <TT><TT><FONT COLOR="#cc0000">my</FONT></TT></TT>
			where it's appropriate. But, even though we don't always do so
			here, we encourage you to include <TT><TT><FONT COLOR="#cc0000">use
			strict</FONT></TT></TT> in your programs as often as possible. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-11"></A>4.11 The return Operator</H3>
			<P><A NAME="lperl3-IDXTERM-362"></A>The <TT><FONT COLOR="#cc0000">return</FONT></TT>
			operator immediately returns a value from a subroutine: 
			</P>
			<PRE><FONT COLOR="#cc0000">my @names = qw/ fred barney betty dino wilma pebbles bamm-bamm /;</FONT>
<FONT COLOR="#cc0000">my $result = &amp;which_element_is(&quot;dino&quot;, @names);</FONT>

<FONT COLOR="#cc0000">sub which_element_is {</FONT>
<FONT COLOR="#cc0000">  my($what, @list) = @_; <FONT COLOR="#b80047"><SPAN STYLE="background: transparent">#assigns the local variables from the arug lis</SPAN>t</FONT></FONT>
<FONT COLOR="#cc0000">  foreach (0..$#list) {  # indices of @list's elements</FONT>
<FONT COLOR="#cc0000">    if ($what eq $list[<SPAN STYLE="background: #eb613d">$_]</SPAN>) { <SPAN STYLE="background: #eb613d">#how do i know where this comesfrom?</SPAN></FONT>
<FONT COLOR="#cc0000">      return $_;         # <SPAN STYLE="background: #94bd5e">return early once found</SPAN></FONT>
<FONT COLOR="#cc0000">    }</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">  -1;                    # element not found (return is optional here)</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			This subroutine is being used to find the index of &quot;<TT><FONT COLOR="#cc0000">dino</FONT></TT>&quot;
			in the array <TT><FONT COLOR="#cc0000">@names</FONT></TT>. First,
			the <TT><FONT COLOR="#cc0000">my</FONT></TT> declaration names the
			parameters: there's <TT><FONT COLOR="#cc0000">$what</FONT></TT>,
			which is what we're searching for, and <TT><FONT COLOR="#cc0000">@list</FONT></TT>,
			a list of values to search within. That's a copy of the array
			<TT><FONT COLOR="#cc0000">@names</FONT></TT>, in this case. The
			<TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop steps through
			the indices of <TT><FONT COLOR="#cc0000">@list</FONT></TT> (the
			first index is <TT><FONT COLOR="#cc0000">0</FONT></TT>, and the
			<SPAN STYLE="background: #94bd5e">last one is </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">$#list</FONT></SPAN></TT>,
			as we saw in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-3#lperl3-CHP-3">Chapter
			3</A>). 
			</P>
			<P>Each time through the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, we check to see whether the string in <TT><FONT COLOR="#cc0000">$what</FONT></TT>
			is equal<A HREF="#">[22]</A> to the element from <TT><FONT COLOR="#cc0000">@list</FONT></TT>
			at the current index. If it's equal, we return that index at once.
			This is the most common use of the keyword <TT><FONT COLOR="#cc0000">return</FONT></TT>
			in Perl&iuml;&frac34;—to <SPAN STYLE="background: #94bd5e">return
			a value immediately, without executing the rest of the subroutine.
			</SPAN>
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[22]</SUP> You
			noticed that we used the string equality test, <TT><FONT COLOR="#cc0000">eq</FONT></TT>,
			instead of the numeric equality test, <TT><FONT COLOR="#cc0000">==</FONT></TT>,
			didn't you?</P>
			<P>But what if we never found that element? In that case, the
			author of this subroutine has chosen to return <TT><FONT COLOR="#cc0000">-1</FONT></TT>
			as a &quot;value not found&quot; code. It would be more Perlish,
			perhaps, to return <TT><FONT COLOR="#cc0000">undef</FONT></TT> in
			that case, but this programmer used <TT><FONT COLOR="#cc0000">-1</FONT></TT>.
			Saying <TT><FONT COLOR="#cc0000">return -1</FONT></TT> on that
			last line would be correct, but the word <TT><FONT COLOR="#cc0000">return</FONT></TT>
			isn't really needed. 
			</P>
			<P><SPAN STYLE="background: #5c8526">Some programmers like to use
			</SPAN><TT><SPAN STYLE="background: #5c8526"><FONT COLOR="#cc0000">return</FONT></SPAN></TT><SPAN STYLE="background: #5c8526">
			every time there's a return value</SPAN>, as a means of
			documenting that it is a return value. For example, you might use
			<TT><FONT COLOR="#cc0000">return</FONT></TT> when the return value
			is not the last line of the subroutine, such as in the subroutine
			<TT><FONT COLOR="#cc0000">&amp;list_from_fred_to_barney</FONT></TT>,
			earlier in this chapter. It's not really needed, but it doesn't
			hurt anything. However, many Perl programmers believe it's just an
			extra seven characters of typing. So you'll need to be able to
			read code written by both kinds of programmers. 
			</P>
			<P><SPAN STYLE="background: #94bd5e">If </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">return</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			is used with no expression, that will return an empty
			value&iuml;&frac34;—</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">undef</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			in a scalar context, or an empty list in a list context</SPAN>.
			<TT><FONT COLOR="#cc0000">return ( )</FONT></TT> does the same, in
			case you want to be explicit. 
			</P>
			<H4><A NAME="lperl3-CHP-4-SECT-11.1"></A>4.11.1 Omitting the
			Ampersand</H4>
			<P><A NAME="IXT-4-336063"></A><A NAME="IXT-4-336064"></A>As
			promised, now we'll tell you the rule for when a subroutine call
			can omit the ampersand. <SPAN STYLE="background: transparent">If
			the compiler sees the subroutine definition before invocation, or
			if Perl can tell from the syntax that it's a subroutine call, the
			subroutine can be called without an ampersand, just like a builtin
			function. (But there's a</SPAN> catch hidden in that rule, as
			we'll see in a moment.) 
			</P>
			<P>This means that if Perl can see that it's a subroutine call
			without the ampersand, from the syntax alone, that's generally
			fine. That is, <SPAN STYLE="background: #94bd5e">if you've got the
			parameter list in parentheses, it's got to be a function</SPAN><A HREF="#"><SPAN STYLE="background: #94bd5e">[23]</SPAN></A><SPAN STYLE="background: #94bd5e">
			call: </SPAN>
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[23]</SUP> In
			this case, the function is the subroutine <TT><FONT COLOR="#cc0000">&amp;shuffle</FONT></TT>.
			But it may be a built-in function, as we'll see in a moment.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my @cards = shuffle(@deck_of_cards);  # No &amp; necessary on &amp;shuffle</FONT></PRE><P>
			Or <SPAN STYLE="background: #94bd5e">if Perl's internal compiler
			has already seen the subroutine definition,</SPAN> that's
			generally okay, too; in that case, <SPAN STYLE="background: #7da647">you
			can even omit the parentheses around the <SPAN STYLE="background: #47b8b8">argument
			list</SPAN>: </SPAN>
			</P>
			<PRE><FONT COLOR="#cc0000"><SPAN STYLE="background: #99ccff">sub division </SPAN>{</FONT>
<FONT COLOR="#cc0000">  $_[0] / $_[1];                   # Divide first param by second</FONT>
<FONT COLOR="#cc0000">}</FONT>

<FONT COLOR="#cc0000">my $quotient = <SPAN STYLE="background: #99ccff">division </SPAN><SPAN STYLE="background: #47b8b8">355, 113</SPAN>;  # Uses &amp;division</FONT></PRE><P>
			This works because of the rule that parentheses may always be
			omitted, except when doing so would change the meaning of the
			code. 
			</P>
			<P>But don't put that subroutine declaration after the invocation,
			or the compiler won't know what the attempted invocation of
			<TT><FONT COLOR="#cc0000">division</FONT></TT> is all about. The
			compiler has to see the <SPAN STYLE="background: #ff6633">definition
			before the invocation </SPAN>in order to use the subroutine call
			as if it were a builtin. 
			</P>
			<P>That's not the catch, though. The catch is this:<SPAN STYLE="background: #ff6633">
			if the subroutine has the same name as a Perl builtin, you must
			use the ampersand to call it. </SPAN>With an ampersand, you're
			sure to call the subroutine; without it, you can get the
			subroutine only if there's no builtin with the same name: 
			</P>
			<PRE><FONT COLOR="#cc0000">sub chomp {</FONT>
<FONT COLOR="#cc0000">  print &quot;Munch, munch!&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT>

<FONT COLOR="#cc0000">&amp;chomp;  # That ampersand is not optional!</FONT></PRE><P>
			<A NAME="IXT-4-336065"></A><A NAME="IXT-4-336066"></A>Without the
			ampersand, we'd be calling the builtin <TT><FONT COLOR="#cc0000">chomp</FONT></TT>,
			even though we've defined the subroutine <TT><FONT COLOR="#cc0000">&amp;chomp</FONT></TT>.
			So, the real rule to use is this one: until you know the names of
			all of Perl's builtin functions, always use the ampersand on
			function calls. That means that you will use it for your first
			hundred programs or so. But when you see someone else has omitted
			the ampersand in their own code, it's not necessarily a mistake;
			perhaps they simply know that Perl has no builtin with that
			name.<A HREF="#">[24]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[24]</SUP>
			Then again, maybe it is a mistake; you can search the <TT><FONT COLOR="#cc0000">perlfunc</FONT></TT>
			and <TT><FONT COLOR="#cc0000">perlop</FONT></TT> manpages for that
			name, though, to see whether it's the same as a builtin. And Perl
			will usually be able to warn you about this, when you have
			warnings turned on.</P>
			<P><A NAME="IXT-4-336067"></A><A NAME="IXT-4-336068"></A><A NAME="IXTR3-29"></A>
			When programmers plan to call their subroutines as if they were
			calling Perl's builtins, often when writing <I>modules</I>, they
			often use <I>prototypes</I> to tell Perl about the parameters to
			expect. Making modules is an advanced topic, though; when you're
			ready for that, see Perl's documentation (in particular, the
			perlmod and perlsub documents) for more information about
			subroutine prototypes and making modules. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-12"></A>4.12 Exercises</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-3#lperl3-APP-A-SECT-3">Section
			A.3</A> for answers to the following exercises: 
			</P>
			<OL>
				<LI><P>[12] Write a subroutine, called <TT><FONT COLOR="#cc0000">&amp;total</FONT></TT>,
				which returns the total of a list of numbers. Hint: the
				subroutine should not perform any I/O; it should simply process
				its parameters and return a value to its caller. Try it out in
				this sample program, which merely exercises the subroutine to see
				that it works. The first group of numbers should add up to 25. 
				</P>
				<PRE STYLE="font-weight: medium"><FONT COLOR="#cc0000">my @fred = qw{ 1 3 5 7 9 };</FONT>
<FONT COLOR="#cc0000">my $fred_total = &amp;total(@fred);</FONT>
<FONT COLOR="#cc0000">print &quot;The total of \@fred is $fred_total.\n&quot;;</FONT>
<FONT COLOR="#cc0000">print &quot;Enter some numbers on separate lines: &quot;;</FONT>
<FONT COLOR="#cc0000">my $user_total = &amp;total(&lt;STDIN&gt;);</FONT>
<FONT COLOR="#cc0000">print &quot;The total of those numbers is $user_total.\n&quot;;</FONT></PRE>
				<LI><P STYLE="font-weight: medium"><A NAME="IXTR3-30"></A>[5]
				Using the subroutine from the previous problem, make a program to
				calculate the sum of the numbers from 1 to 1000. 
				</P>
			</OL>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic1" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H2><A NAME="lperl3-CHP-5"></A>Chapter 5. Hashes</H2>
			<P><A NAME="lperl3-IDXTERM-371"></A>In this chapter, we will see
			one of Perl's features that makes Perl one of the world's truly
			great programming languages&iuml;&frac34;—hashes.<A HREF="#">[1]</A>
			Although hashes are a powerful and useful feature, you may have
			used other powerful languages for years without ever hearing of
			hashes. But you'll use hashes in nearly every Perl program you'll
			write from now on; they're that important. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-5-336069"></A>
			<SUP>[1]</SUP> In the olden days, we called these &quot;associative
			arrays.&quot; But the Perl community decided in about 1995 this
			was too many letters to type and too many syllables to say, so we
			changed the name to &quot;hashes.&quot; 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-5-SECT-1"></A>5.1 What Is a Hash?</H3>
			<P><A NAME="IXT-5-336070"></A><A NAME="IXT-5-336071"></A>A hash is
			a data structure, not unlike an array in that it can hold any
			number of values and retrieve them at will. But instead of
			indexing the values by number, as we did with arrays, we'll look
			up the values by name. <SPAN STYLE="background: #94bd5e">That is,
			the <I>indices</I> (here, we'll call them <I>keys</I> ) aren't
			numbers, but instead they are arbitrary unique strings</SPAN> (see
			<A HREF="#lperl3-CHP-5-FIG-1">Figure 5-1</A>). 
			</P>
			<H5 ALIGN=CENTER><A NAME="lperl3-CHP-5-FIG-1"></A>Figure 5-1. Hash
			keys and values</H5>
			<P ALIGN=CENTER><IMG SRC="lrnp_0501.gif" NAME="Graphic2" ALT="lrnp_0501.gif" ALIGN=BOTTOM WIDTH=238 HEIGHT=220 BORDER=0></P>
			<P>The keys are strings, first of all, so instead of getting
			element number <TT><FONT COLOR="#cc0000">3</FONT></TT> from an
			array, we'll be accessing the hash element named <TT><FONT COLOR="#cc0000">wilma</FONT></TT>.
						</P>
			<P>These <SPAN STYLE="background: #94bd5e">keys are arbitrary</SPAN>
			strings&iuml;&frac34;—you can use any string expression for a
			hash key. And they are <SPAN STYLE="background: #94bd5e">unique</SPAN>
			strings&iuml;&frac34;—just as there's only one array element
			numbered <TT><FONT COLOR="#cc0000">3</FONT></TT>, there's only one
			hash element named <TT><FONT COLOR="#cc0000">wilma</FONT></TT>. 
			</P>
			<P><A NAME="IXT-5-336072"></A>Another way to think of a hash is
			that it's like a barrel of data, where each piece of data has a
			tag attached. You can reach into the barrel and pull out any tag
			and see what piece of data is attached. But there's no &quot;first&quot;
			item in the barrel; it's just a jumble. In an array, we'd start
			with element <TT><FONT COLOR="#cc0000">0</FONT></TT>, then element
			<TT><FONT COLOR="#cc0000">1</FONT></TT>, then element <TT><FONT COLOR="#cc0000">2</FONT></TT>,
			and so on. But in a hash, there's no fixed order, no first
			element. It's just a collection of key-value pairs. 
			</P>
			<P>The keys and values are both arbitrary scalars, but the <SPAN STYLE="background: #94bd5e">keys
			are always converted to strings.</SPAN> So, if you used the
			numeric expression <TT><FONT COLOR="#cc0000">50/20</FONT></TT> as
			the key,<A HREF="#">[2]</A> it would be turned into the
			three-character string <TT><FONT COLOR="#cc0000">&quot;2.5&quot;</FONT></TT>,
			which is one of the keys shown in the diagram above. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP>
			That's a numeric expression, not the five-character string
			<TT><FONT COLOR="#cc0000">&quot;50/20&quot;</FONT></TT>. If we
			used that five-character string as a hash key, it would stay the
			same five-character string, of course.</P>
			<P>As usual, Perl's no-unnecessary-limits philosophy applies: a
			hash may be of any size, from an empty hash with zero key-value
			pairs, up to whatever fills up your memory. 
			</P>
			<P>Some implementations of hashes (such as in the original <I>awk</I>
			language, from where Larry borrowed the idea) slow down as the
			hashes get larger and larger. This is not the case in Perl&iuml;&frac34;—it
			has a good, efficient, scalable algorithm.<A HREF="#">[3]</A> So,
			if a hash has only three key-value pairs, it's very quick to
			&quot;reach into the barrel&quot; and pull out any one of those.
			If the hash has three million key-value pairs, it should be just
			about as quick to pull out any one of those. A big hash is nothing
			to fear. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP>
			Technically, Perl rebuilds the hash table as needed for larger
			hashes. In fact, the term &quot;hashes&quot; comes from the fact
			that a hash table is used for implementing them.</P>
			<P>It's worth mentioning again that the <SPAN STYLE="background: #94bd5e">keys
			are always unique, although the values may be duplicated.</SPAN>
			The values of a hash may be all numbers, all strings, <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			values, or a mixture.<A HREF="#">[4]</A> But the keys are all
			arbitrary, unique strings. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP> Or,
			in fact, any scalar values, including other scalar types than the
			ones we'll see in this book.</P>
			<H4><A NAME="lperl3-CHP-5-SECT-1.1"></A>5.1.1 Why Use a Hash?</H4>
			<P><A NAME="IXT-5-336073"></A>When you first hear about hashes,
			especially if you've lived a long and productive life as a
			programmer using other languages that don't have hashes, you may
			wonder why anyone would want one of these strange beasts. Well,
			the general idea is that you'll have one set of data &quot;related
			to&quot; another set of data. For example, here are some hashes
			you might find in typical applications of Perl: 
			</P>
			<DL>
				<DT STYLE="margin-bottom: 0.5cm"><A NAME="IXT-5-336074"></A><I>Given
				name, family name</I> 
				</DT></DL>
			<P STYLE="margin-left: 1cm">
			<A NAME="IXT-5-3360741"></A>The given name (first name) is the
			key, and the family name is the value. This requires unique given
			names, of course; if there were two people named <TT><FONT COLOR="#cc0000">randal</FONT></TT>,
			this wouldn't work. With this hash, you can look up anyone's given
			name, and find the corresponding family name. If you use the key
			<TT><FONT COLOR="#cc0000">tom</FONT></TT>, you get the value
			<TT><FONT COLOR="#cc0000">phoenix</FONT></TT>. 
			</P>
			<DL>
				<DT STYLE="margin-bottom: 0.5cm"><A NAME="IXT-5-336075"></A><I>Host
				name, IP address</I> 
				</DT></DL>
			<P STYLE="margin-left: 1cm">
			<A NAME="IXT-5-3360751"></A>You may know that each computer on the
			Internet has both a host name (like <A HREF="http://www.stonehenge.com/" TARGET="_blank">www.stonehenge.com</A>)
			and an IP address number (like 123.45.67.89). That's because
			machines like working with the numbers, but we humans have an
			easier time remembering the names. The host names are unique
			strings, so they can be used to make this hash. With this hash,
			you could look up a host name and find the corresponding IP
			address number. 
			</P>
			<DL>
				<DT STYLE="margin-bottom: 0.5cm"><I>IP address, host name</I> 
				</DT></DL>
			<P STYLE="margin-left: 1cm">
			Or you could go in the opposite direction. We generally think of
			the IP address as a number, but it can also be a unique string, so
			it's suitable for use as a hash key. In this hash, we can look up
			the IP address number to determine the corresponding host name.
			Note that this is not the same hash as the previous example:
			hashes are a one-way street, running from key to value; <SPAN STYLE="background: #ff6633">there's
			no way to look up a value in a hash and find the corresponding
			key! </SPAN>So these two are a pair of hashes, one for storing IP
			addresses, one for host names. It's easy enough to create one of
			these given the other, though, as we'll see below. 
			</P>
			<DL>
				<DT STYLE="margin-bottom: 0.5cm"><A NAME="IXT-5-336076"></A>Word,
				count of number of times that word appears<A HREF="#">[5]</A> 
				</DT></DL>
			<P STYLE="margin-left: 1cm">
			<A NAME="IXT-5-3360761"></A>The idea here is that you <SPAN STYLE="background: #ffff00">want
			to know how often each word appears in a given document.</SPAN>
			Perhaps you're building an index to a number of documents, so that
			when a user searches for <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
			you'll know that a certain document mentions <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			five times, another mentions <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			seven times, and yet another doesn't mention <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			at all&iuml;&frac34;—so you'll know which documents the user is
			likely to want. As the index-making program reads through a given
			document, each time it sees a mention of <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
			it adds one to the value filed under the key of <TT><FONT COLOR="#cc0000">fred</FONT></TT>.
			That is, if we had seen <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			twice already in this document, the value would be <TT><FONT COLOR="#cc0000">2</FONT></TT>,
			but now we'll increment it to <TT><FONT COLOR="#cc0000">3</FONT></TT>.
			If we had never seen <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			before, we'd change the value from <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			(the implicit, default value) to <TT><FONT COLOR="#cc0000">1</FONT></TT>.
						</P>
			<DL>
				<DT STYLE="margin-bottom: 0.5cm"><I>Username, number of disk
				blocks they are using [wasting] </I>
				</DT></DL>
			<P STYLE="margin-left: 1cm">
			System administrators like this one: the usernames on a given
			system are all unique strings, so they can be used as keys in a
			hash to look up information about that user. 
			</P>
			<DL>
				<DT STYLE="margin-bottom: 0.5cm"><I>Driver's license number, name</I>
								</DT></DL>
			<P STYLE="margin-left: 1cm">
			There may be many, many people named John Smith, but we hope that
			each one has a different driver's license number. That number
			makes for a unique key, and the person's name is the value. 
			</P>
			<P><A NAME="IXT-5-336077"></A>So, yet another way to think of a
			hash is as a very simple database, in which just one piece of data
			may be filed under each key. In fact, if your task description
			includes phrases like &quot;finding duplicates,&quot; &quot;unique,&quot;
			&quot;cross-reference,&quot; or &quot;lookup table,&quot; it's
			likely that a hash will be useful in the implementation. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-5-SECT-2"></A>5.2 Hash Element Access</H3>
			<P><A NAME="lperl3-IDXTERM-381"></A><A NAME="lperl3-IDXTERM-382"></A>
			To access an element of a hash, use syntax that looks like this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$hash{$some_key}</FONT></PRE><P>
			<A NAME="IXT-5-336078"></A>This is similar to what we used for
			array access, <SPAN STYLE="background: #94bd5e">but here we use
			curly braces instead of square brackets around the subscript
			(key).</SPAN><A HREF="#"><SPAN STYLE="background: #94bd5e">[6]</SPAN></A><SPAN STYLE="background: #94bd5e">
			And that key expression is now a string</SPAN>, rather than a
			number: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP>
			Here's a peek into the mind of Larry Wall: Larry says that we use
			curly braces instead of square brackets because we're doing
			something fancier than ordinary array access, so we should use
			fancier punctuation. 
			</P>
			<PRE><FONT COLOR="#cc0000">$family_name{&quot;fred&quot;} = &quot;flintstone&quot;;</FONT>
<FONT COLOR="#cc0000">$family_name{&quot;barney&quot;} = &quot;rubble&quot;;</FONT></PRE><P>
			<A HREF="#lperl3-CHP-5-FIG-2">Figure 5-2</A> shows how the
			resulting hash keys are assigned. 
			</P>
			<H5 ALIGN=CENTER><A NAME="lperl3-CHP-5-FIG-2"></A>Figure 5-2.
			Assigned hash keys</H5>
			<P ALIGN=CENTER><IMG SRC="lrnp_0502.gif" NAME="Graphic3" ALT="lrnp_0502.gif" ALIGN=BOTTOM WIDTH=216 HEIGHT=92 BORDER=0></P>
			<P>This lets us use code like this:</P>
			<PRE><FONT COLOR="#cc0000">foreach $person (qw&lt; barney fred &gt;) {</FONT>
<FONT COLOR="#cc0000">  print &quot;I've heard of $person $family_name{$person}.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-5-336079"></A><A NAME="IXT-5-336080"></A><A NAME="IXT-5-336081"></A><A NAME="IXT-5-336082"></A>
			The name of the hash is like any other Perl identifier (letters,
			digits, and underscores, but can't start with a digit). And it's
			from a separate namespace; that is, there's no connection between
			the hash element <TT><FONT COLOR="#cc0000">$family_name{&quot;fred&quot;}</FONT></TT>
			and a subroutine <TT><FONT COLOR="#cc0000">&amp;family_name</FONT></TT>,
			for example. Of course, there's no reason to confuse everyone by
			giving everything the same name. But Perl won't mind if you also
			have a scalar called <TT><FONT COLOR="#cc0000">$family_name</FONT></TT>
			and array elements like <TT><FONT COLOR="#cc0000">$family_name[5]</FONT></TT>.
			We humans will have to do as Perl does; that is, we'll have to
			look to see what punctuation appears before and after the
			identifier to see what it means. When there is a dollar sign in
			front of the name and curly braces afterwards, it's a hash element
			that's being accessed. 
			</P>
			<P><A NAME="IXT-5-336083"></A>When choosing the name of a hash,
			it's often nice to think of the word &quot;of&quot; between the
			name of the hash and the key. As in, &quot;the <TT><FONT COLOR="#cc0000">family_name</FONT></TT>
			of <TT><FONT COLOR="#cc0000">fred</FONT></TT> is <TT><FONT COLOR="#cc0000">flintstone</FONT></TT>&quot;.
			So the hash is named <TT><FONT COLOR="#cc0000">family_name</FONT></TT>.
			Then it becomes clear what the relationship is between the keys
			and their values. 
			</P>
			<P>Of course, the <SPAN STYLE="background: #99ccff">hash key may
			be any expression</SPAN>, not just the literal strings and simple
			scalar variables that we're showing here: 
			</P>
			<PRE><FONT COLOR="#cc0000">$foo = &quot;bar&quot;;</FONT>
<FONT COLOR="#cc0000">print $family_name{ <SPAN STYLE="background: #99ccff">$foo . &quot;ney&quot;</SPAN> };  # prints &quot;rubble&quot;</FONT></PRE><P>
			When you store something into an existing hash element, that
			overwrites the previous value: 
			</P>
			<PRE><FONT COLOR="#cc0000">$family_name{&quot;fred&quot;} = &quot;astaire&quot;;  # gives new value to existing element</FONT>
<FONT COLOR="#cc0000">$bedrock = $family_name{&quot;fred&quot;};   # gets &quot;astaire&quot;; old value is lost</FONT></PRE><P>
			That's analogous to what happens with arrays and scalars; if you
			store something new into <TT><FONT COLOR="#cc0000">$pebbles[17]</FONT></TT>
			or <TT><FONT COLOR="#cc0000">$dino</FONT></TT>, the old value is
			replaced. If you store something new into <TT><FONT COLOR="#cc0000">$family_name{&quot;fred&quot;}</FONT></TT>,
			the old value is replaced as well. 
			</P>
			<P>Hash elements will spring into existence by assignment:</P>
			<PRE><FONT COLOR="#cc0000">$family_name{&quot;wilma&quot;} = &quot;flintstone&quot;;             # adds a new key (and value)</FONT>
<FONT COLOR="#cc0000">$family_name{&quot;betty&quot;} .= $family_name{&quot;barney&quot;};  # creates the element if needed</FONT></PRE><P>
			That's also just like what happens with arrays and scalars; if you
			didn't have <TT><FONT COLOR="#cc0000">$pebbles[17]</FONT></TT> or
			<TT><FONT COLOR="#cc0000">$dino</FONT></TT> before, you will have
			it after you assign to it. If you didn't have
			<TT><FONT COLOR="#cc0000">$family_name{&quot;betty&quot;}</FONT></TT>
			before, you do now. 
			</P>
			<P>And accessing outside the hash gives <TT><FONT COLOR="#cc0000">undef</FONT></TT>:</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">$granite = $family_name{&quot;larry&quot;};  # No larry here: undef</SPAN></FONT></PRE><P>
			Once again, this is just like what happens with arrays and
			scalars; if there's nothing yet stored in <TT><FONT COLOR="#cc0000">$pebbles[17]</FONT></TT>
			or <TT><FONT COLOR="#cc0000">$dino</FONT></TT>, accessing them
			will yield <TT><FONT COLOR="#cc0000">undef</FONT></TT>. If there's
			nothing yet stored in <TT><FONT COLOR="#cc0000">$family_name{&quot;larry&quot;}</FONT></TT>,
			accessing it will yield <TT><FONT COLOR="#cc0000">undef</FONT></TT>.
						</P>
			<H4><A NAME="lperl3-CHP-5-SECT-2.1"></A>5.2.1 The Hash as a Whole</H4>
			<P><A NAME="IXT-5-336084"></A>To refer to the <SPAN STYLE="background: #94bd5e">entire
			hash, use the percent sign (&quot;</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">%</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">&quot;)
			as a prefix</SPAN>. So, the hash we've been using for the last few
			pages is actually called <TT><FONT COLOR="#cc0000">%family_name</FONT></TT>.
						</P>
			<P>For convenience, a hash may be converted into a list, and back
			again. <SPAN STYLE="background: #94bd5e">Assigning to a hash</SPAN>
			(in this case, the one from <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-5-SECT-1#lperl3-CHP-5-FIG-1">Figure
			5-1</A>) is a list-context assignment, where the <SPAN STYLE="background: #94bd5e">list
			is made of key-value pairs</SPAN>:<A HREF="#">[7]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP>
			Although any list expression may be used, it must have an even
			number of elements, because the hash is made of key-value pairs.
			An odd element will likely do something unreliable, although it's
			a warnable offense.</P>
			<PRE><FONT COLOR="#cc0000">%some_hash = (<SPAN STYLE="background: #99ccff">&quot;foo&quot;, 35</SPAN>, <SPAN STYLE="background: #99ccff">&quot;bar&quot;, 12.4</SPAN>, 2.5, &quot;hello&quot;,</FONT>
<FONT COLOR="#cc0000">      &quot;wilma&quot;, 1.72e30, &quot;betty&quot;, &quot;bye\n&quot;);</FONT></PRE><P>
			The <SPAN STYLE="background: #7da647">value of the hash (in a list
			context) is a simple list of key-value pairs: </SPAN>
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">@any_array = %some_hash;</FONT></PRE><P>
			<A NAME="IXT-5-336085"></A><A NAME="IXT-5-336086"></A>We call this<SPAN STYLE="background: #94bd5e">
			<I>unwinding</I> the hash</SPAN>; turning it back into a list of
			key-value pairs. Of course, the pairs won't necessarily be in the
			same order as the original list: 
			</P>
			<PRE><FONT COLOR="#cc0000">print &quot;@any_array\n&quot;;</FONT>
<FONT COLOR="#cc0000">  # might give something like this:</FONT>
<FONT COLOR="#cc0000">  #  betty bye (and a newline) wilma 1.72e+30 foo 35 2.5 hello bar 12.4</FONT></PRE><P>
			The order is jumbled because <SPAN STYLE="background: #ff9966">Perl
			keeps the key-value pairs in an order that's convenient for Perl</SPAN>,
			so that it can look up any item quickly. So you'd normally use a
			hash either when you don't care what order the items are in, or
			when you have an easy way to put them into the order you want. 
			</P>
			<P>Of course, even though the order of the key-value pairs is
			jumbled, each key &quot;sticks&quot; with its corresponding value
			in the resulting list. So, even though we don't know where the key
			<TT><FONT COLOR="#cc0000">foo</FONT></TT> will appear in the list,
			we know that its value, <TT><FONT COLOR="#cc0000">35</FONT></TT>,
			will be right after it. 
			</P>
			<H4><A NAME="lperl3-CHP-5-SECT-2.2"></A>5.2.2 Hash Assignment</H4>
			<P><A NAME="IXT-5-336087"></A><A NAME="IXT-5-336088"></A>It's rare
			to do so, but a hash may be copied using the obvious syntax: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">%new_hash = %old_hash;</FONT></PRE><P>
			This is actually more work for Perl than meets the eye. Unlike
			what happens in languages like <SPAN STYLE="background: #ffff00">Pascal
			or C, where such an operation would be a simple matter of copying
			a block of memory,</SPAN> Perl's data structures are more complex.
			So, that line of code tells Perl to unwind the <TT><FONT COLOR="#cc0000">%old_hash</FONT></TT>
			into a list of key-value pairs, then assign those to <TT><FONT COLOR="#cc0000">%new_hash</FONT></TT>,
			building it up one key-value pair at a time. 
			</P>
			<P>It's more common to transform the hash in some way, though. For
			example, we could make an inverse hash: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">%inverse_hash = reverse %any_hash;</FONT></PRE><P>
			This takes <TT><FONT COLOR="#cc0000">%any_hash</FONT></TT> and
			unwinds it into a list of key-value pairs, making a list like
			<TT><FONT COLOR="#cc0000">(</FONT></TT>key, value, key, value,
			key, value, ...<TT><FONT COLOR="#cc0000">)</FONT></TT>. Then
			<TT><FONT COLOR="#cc0000">reverse</FONT></TT> turns that list
			end-for-end, making a list like <TT><FONT COLOR="#cc0000">(</FONT></TT>value,
			key, value, key, value, key, ...<TT><FONT COLOR="#cc0000">)</FONT></TT>.
			<SPAN STYLE="background: #94bd5e">Now the keys are where the
			values used to be, and the values are where the keys used to be.
			When that's stored into </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">%inverse_hash</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,</SPAN>
			we'll be able to look up a string that was a value in
			<TT><FONT COLOR="#cc0000">%any_hash</FONT></TT>&iuml;&frac34;—it's
			now a key of <TT><FONT COLOR="#cc0000">%inverse_hash</FONT></TT>.
			And the value we'll find is one that was one of the keys from
			<TT><FONT COLOR="#cc0000">%any_hash</FONT></TT>. <SPAN STYLE="background: #94bd5e">So,
			we have a way to look up a &quot;value&quot;</SPAN> (now a key),
			and find a &quot;key&quot; (now a value). 
			</P>
			<P>Of course, you might guess (or determine from scientific
			principles, if you're clever) that this will work properly <SPAN STYLE="background: #94bd5e">only
			if the values in the original hash were unique</SPAN>&iuml;&frac34;—otherwise
			we'd have duplicate keys in the new hash, and keys are always
			unique. Here's the rule that Perl uses: the last one in wins. That
			is, the later items in the list overwrite any earlier ones. Of
			course, we don't know what order the key-value pairs will have in
			this list, so there's no telling which ones would win. You'd use
			this technique only if you know there are no duplicates among the
			original values.<A HREF="#">[8]</A> But that's the case for the IP
			address and host name examples given earlier: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> Or
			if you don't care that there are duplicates. For example, we could
			invert the <TT><FONT COLOR="#cc0000">%family_name</FONT></TT> hash
			(in which the keys are people's given names and values are their
			family names) to make it easy to determine whether there is or is
			not anyone with a given family name in the group. Thus, in the
			inverted hash, if there's no key of <TT><FONT COLOR="#cc0000">slate</FONT></TT>,
			we'd know that there's no one with that name in the original hash.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">%ip_address = reverse %host_name;</FONT></PRE><P>
			Now we can look up a host name or IP address with equal ease, to
			find the corresponding IP address or host name. 
			</P>
			<H4><A NAME="lperl3-CHP-5-SECT-2.3"></A>5.2.3 The Big Arrow</H4>
			<P><A NAME="IXT-5-336089"></A><A NAME="IXT-5-336090"></A><A NAME="IXT-5-336091"></A>
			When assigning a list to a hash, sometimes it's not obvious which
			elements are keys and which are values. For example, in this
			assignment (which we saw earlier), we humans have to count through
			the list, saying, &quot;key, value, key, value...&quot;, in order
			to determine whether <TT><FONT COLOR="#cc0000">2.5</FONT></TT> is
			a key or a value: 
			</P>
			<PRE><FONT COLOR="#cc0000">%some_hash = (&quot;foo&quot;, 35, &quot;bar&quot;, 12.4, 2.5, &quot;hello&quot;,</FONT>
<FONT COLOR="#cc0000">      &quot;wilma&quot;, 1.72e30, &quot;betty&quot;, &quot;bye\n&quot;);</FONT></PRE><P>
			<A NAME="IXT-5-336094"></A><A NAME="IXT-5-336095"></A>Wouldn't it
			be nice if Perl gave us a way to pair up keys and values in that
			kind of a list, so that it would be easy to see which ones were
			which? Larry thought so, too, which is why he invented the big
			arro<SPAN STYLE="background: transparent">w, (</SPAN><TT><SPAN STYLE="background: transparent"><FONT COLOR="#cc0000">=&gt;</FONT></SPAN></TT><SPAN STYLE="background: transparent">).</SPAN><A HREF="#"><SPAN STYLE="background: transparent">[9]</SPAN></A><SPAN STYLE="background: transparent">
			To Perl, it's just a different way to &quot;spell&quot; a comma.
			T</SPAN>hat is, <SPAN STYLE="background: #94bd5e">in the Perl
			grammar, any time that you need a comma ( </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">,</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			), you can use the big arrow instead; it's all the same to
			Perl.</SPAN><A HREF="#">[10]</A> So here's another way to set up
			the hash of last names: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-5-336092"></A><A NAME="IXT-5-336093"></A>
			<SUP>[9]</SUP> Yes, there's also a little arrow, (<TT><FONT COLOR="#cc0000">-&gt;</FONT></TT>).
			It's used with references, which are an advanced topic; see the
			perlreftutand perlrefmanpage when you're ready for that.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[10]</SUP>
			Well, there's one technical difference: any<SPAN STYLE="background: #94bd5e">
			bareword </SPAN>(a sequence of nothing but letters, digits, and
			underscores not starting with a digit) <SPAN STYLE="background: #94bd5e">to
			the left of the big arrow is implicitly quoted</SPAN>. So you can
			leave off the quote marks on a bareword to the left of the big
			arrow. You may also omit the quote marks if there's nothing but a
			bareword as a key inside the curly braces of a hash.</P>
			<PRE><FONT COLOR="#cc0000">my %last_name = (  # a hash may be a lexical variable</FONT>
<FONT COLOR="#cc0000">  &quot;fred&quot; =&gt; &quot;flintstone&quot;,</FONT>
<FONT COLOR="#cc0000">  &quot;dino&quot; =&gt; undef,</FONT>
<FONT COLOR="#cc0000">  &quot;barney&quot; =&gt; &quot;rubble&quot;,</FONT>
<FONT COLOR="#cc0000">  &quot;betty&quot; =&gt; &quot;rubble&quot;,</FONT>
<FONT COLOR="#cc0000">);</FONT></PRE><P>
			<A NAME="IXTR3-31"></A><A NAME="IXTR3-32"></A>Here, it's easy (or
			perhaps at least easier) to see whose name pairs with which value,
			even if we end up putting many pairs on one line. And notice that
			there's an extra comma at the end of the list. As we saw earlier,
			this is harmless, but convenient; if we need to add additional
			people to this hash, we'll simply make sure that each line has a
			key-value pair and a trailing comma. Perl will see that there is a
			comma between each item and the next, and one extra (harmless)
			comma at the end of the list. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-5-SECT-3"></A>5.3 Hash Functions</H3>
			<P><A NAME="lperl3-IDXTERM-403"></A><A NAME="lperl3-IDXTERM-404"></A>
			Naturally, there are some useful functions that can work on an
			entire hash at once. 
			</P>
			<H4><A NAME="lperl3-CHP-5-SECT-3.1"></A>5.3.1 The keys and values
			Functions</H4>
			<P><A NAME="IXT-5-336096"></A><A NAME="IXT-5-336097"></A>The <TT><FONT COLOR="#cc0000">keys</FONT></TT>
			function yields a list of all the current keys in a hash, while
			the <TT><FONT COLOR="#cc0000">values</FONT></TT> function gives
			the corresponding values. If there are no elements to the hash,
			then either function returns an empty list: 
			</P>
			<PRE><FONT COLOR="#cc0000">my %hash = (&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3);</FONT>
<FONT COLOR="#cc0000">my @k = keys %hash;</FONT>
<FONT COLOR="#cc0000">my @v = values %hash;</FONT></PRE><P>
			So, <TT><FONT COLOR="#cc0000">@k</FONT></TT> will contain <TT><FONT COLOR="#cc0000">&quot;a&quot;</FONT></TT>,
			<TT><FONT COLOR="#cc0000">&quot;b&quot;</FONT></TT>, and <TT><FONT COLOR="#cc0000">&quot;c&quot;</FONT></TT>,
			and <TT><FONT COLOR="#cc0000">@v</FONT></TT> will contain <TT><FONT COLOR="#cc0000">1</FONT></TT>,
			<TT><FONT COLOR="#cc0000">2</FONT></TT>, and <TT><FONT COLOR="#cc0000">3</FONT></TT>&iuml;&frac34;—in
			some order. Remember, Perl doesn't maintain the order of elements
			in a hash. But, whatever order the keys are in, the values will be
			in the corresponding order: If <TT><FONT COLOR="#cc0000">&quot;b&quot;</FONT></TT>
			is last in the keys, <TT><FONT COLOR="#cc0000">2</FONT></TT> will
			be last in the values; if <TT><FONT COLOR="#cc0000">&quot;c&quot;</FONT></TT>
			is the first key, <TT><FONT COLOR="#cc0000">3</FONT></TT> will be
			the first value. That's true as long as you don't modify the hash
			between the request for the keys and the one for the values. If
			you add elements to the hash, Perl reserves the right to rearrange
			it as needed, to keep the access quick.<A HREF="#">[11]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP> Of
			course, if you started adding elements to the hash between <TT><FONT COLOR="#cc0000">keys</FONT></TT>
			and <TT><FONT COLOR="#cc0000">values</FONT></TT>, your list of
			values (or keys, whichever you did second) would have additional
			items, which would be tough to match up with the first list. So no
			normal programmer would do that. 
			</P>
			<P>In a scalar context, these functions give the number of
			elements (key-value pairs) in the hash. They do this quite
			efficiently, without having to visit each element of the hash: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $count = keys %hash;  # gets 3, meaning three key-value pairs</FONT></PRE><P>
			Once in a long while, you'll see that someone has used a hash as a
			Boolean (true/false) expression, something like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">if (%hash) {</FONT>
<FONT COLOR="#cc0000">  print &quot;That was a true value!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			That will be true if (and only if) the hash has at least one
			key-value pair.<A HREF="#">[12]</A> So, it's just saying, &quot;if
			the hash is not empty...&quot;. But this is a pretty rare
			construct, as such things go. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP> The
			actual result is an internal debugging string useful to the people
			who maintain Perl. It looks something like &quot;4/16&quot;, but
			the value is guaranteed to be true when the hash is non-empty, and
			false when it's empty, so the rest of us can still use it for
			that.</P>
			<H4><A NAME="lperl3-CHP-5-SECT-3.2"></A>5.3.2 The each Function</H4>
			<P><A NAME="IXT-5-336098"></A>If you wish to iterate over (that
			is, examine every element of) an entire hash, one of the usual
			ways is to use the <TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">each</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			function, which returns a key-value pair as a two-element
			list.</SPAN><A HREF="#">[13]</A> On each evaluation of this
			function for the same array, the next successive key-value pair is
			returned, until all the elements have been accessed. When there
			are no more pairs, <TT><FONT COLOR="#cc0000">each</FONT></TT>
			returns an empty list. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP> The
			other usual way to iterate over an entire hash is to use <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			on a list of keys from the hash; we'll see that by the end of this
			section.</P>
			<P><A NAME="IXT-5-336099"></A>In practice, the only way to use
			<TT><FONT COLOR="#cc0000">each</FONT></TT> is in a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop, something like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">while ( ($key, $value) = each %hash ) {</FONT>
<FONT COLOR="#cc0000">  print &quot;$key =&gt; $value\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			There's a lot going on here. First, <TT><FONT COLOR="#cc0000">each
			%hash</FONT></TT> returns a key-value pair from the hash, as a
			two-element list; let's say that the key is <TT><FONT COLOR="#cc0000">&quot;c&quot;</FONT></TT>
			and the value is <TT><FONT COLOR="#cc0000">3</FONT></TT>, so the
			list is <TT><FONT COLOR="#cc0000">(&quot;c&quot;, 3)</FONT></TT>.
			That list is assigned to the list <TT><FONT COLOR="#cc0000">($key,</FONT></TT>
			<TT><FONT COLOR="#cc0000">$value)</FONT></TT>, so <TT><FONT COLOR="#cc0000">$key</FONT></TT>
			becomes <TT><FONT COLOR="#cc0000">&quot;c&quot;</FONT></TT>, and
			<TT><FONT COLOR="#cc0000">$value</FONT></TT> becomes <TT><FONT COLOR="#cc0000">3</FONT></TT>.
						</P>
			<P>But that list assignment is happening in the conditional
			expression of the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop, which is a scalar context. (Specifically, it's a Boolean
			context, looking for a true/false value; and a Boolean context is
			a particular kind of scalar context.) The value of a list
			assignment in a scalar context is the number of elements in the
			source list&iuml;&frac34;—<TT><FONT COLOR="#cc0000">2</FONT></TT>,
			in this case. Since <TT><FONT COLOR="#cc0000">2</FONT></TT> is a
			true value, we enter the body of the loop and print the message <TT><FONT COLOR="#cc0000">c
			=&gt; 3</FONT></TT>. 
			</P>
			<P>The next time through the loop, <TT><FONT COLOR="#cc0000">each
			%hash</FONT></TT> gives a new key-value pair; let's say it's <TT><FONT COLOR="#cc0000">(&quot;a&quot;,
			1)</FONT></TT> this time. (It knows to return a different pair
			than previously because it keeps track of where it is; in
			technical jargon, there's an iterator stored in with each
			hash.<A HREF="#">[14]</A>) Those two items are stored into <TT><FONT COLOR="#cc0000">($key,
			$value)</FONT></TT>. Since the number of elements in the source
			list was again <TT><FONT COLOR="#cc0000">2</FONT></TT>, a true
			value, the <TT><FONT COLOR="#cc0000">while</FONT></TT> condition
			is true, and the loop body runs again, telling us <TT><FONT COLOR="#cc0000">a
			=&gt; 1</FONT></TT>. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP>
			Since each hash has its own private iterator, loops using <TT><FONT COLOR="#cc0000">each
			</FONT></TT>may be nested, as long as they are iterating over
			different hashes. And, as long as we're already in a footnote, we
			may as well tell you: it's unlikely you'll ever need to do so, but
			you may reset the iterator of a hash by using the <TT><FONT COLOR="#cc0000">keys
			</FONT></TT>or <TT><FONT COLOR="#cc0000">values</FONT></TT>
			function on the hash. The iterator is also automatically reset if
			a new list is stored into the entire hash, or if <TT><FONT COLOR="#cc0000">each
			</FONT></TT>has iterated through all of the items to the &quot;end&quot;
			of the hash. On the other hand, adding new key-value pairs to the
			hash while iterating over it is generally a bad idea, since that
			won't necessarily reset the iterator. That's likely to confuse
			you, your maintenance programmer, and <TT><FONT COLOR="#cc0000">each
			</FONT></TT>as well.</P>
			<P>We go one more time through the loop, and by now we know what
			to expect, so it's no surprise to see <TT><FONT COLOR="#cc0000">b
			=&gt; 2</FONT></TT> appear in the output. 
			</P>
			<P>But we knew it couldn't go on forever. Now, when Perl evaluates
			<TT><FONT COLOR="#cc0000">each %hash</FONT></TT>, there are no
			more key-value pairs available. So, <TT><FONT COLOR="#cc0000">each</FONT></TT>
			has to return an empty list.<A HREF="#">[15]</A> The empty list is
			assigned to <TT><FONT COLOR="#cc0000">($key, $value)</FONT></TT>,
			so <TT><FONT COLOR="#cc0000">$key</FONT></TT> gets <TT><FONT COLOR="#cc0000">undef</FONT></TT>,
			and <TT><FONT COLOR="#cc0000">$value</FONT></TT> also gets <TT><FONT COLOR="#cc0000">undef</FONT></TT>.
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP>
			It's being used in list context, so it can't return <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			to signal failure; that would be the one-element list
			<TT><FONT COLOR="#cc0000">(undef)</FONT></TT>instead of the empty
			(zero-element) list <TT><FONT COLOR="#cc0000">( )</FONT></TT>. 
			</P>
			<P>But that hardly matters, because the whole thing is being
			evaluated in the conditional expression of the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop. The value of a list assignment in a scalar context is the
			number of elements in the source list&iuml;&frac34;—in this
			case, that's <TT><FONT COLOR="#cc0000">0</FONT></TT>. Since <TT><FONT COLOR="#cc0000">0</FONT></TT>
			is a false value, the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop is done, and execution continues with the rest of the
			program. 
			</P>
			<P>Of course, <TT><FONT COLOR="#cc0000">each</FONT></TT> returns
			the key-value pairs in a jumbled order. (It's the same order as
			<TT><FONT COLOR="#cc0000">keys</FONT></TT> and <TT><FONT COLOR="#cc0000">values</FONT></TT>
			would give, incidentally; the &quot;natural&quot; order of the
			hash.) If you need to go through the hash in order, simply sort
			the keys, perhaps something like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">foreach $key (sort keys %hash) {</FONT>
<FONT COLOR="#cc0000">  $value = $hash{$key};</FONT>
<FONT COLOR="#cc0000">  print &quot;$key =&gt; $value\n&quot;;</FONT>
<FONT COLOR="#cc0000">  # Or, we could have avoided the extra $value variable:</FONT>
<FONT COLOR="#cc0000">  #  print &quot;$key =&gt; $hash{$key}\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXTR3-33"></A><A NAME="IXTR3-34"></A>We'll see more about
			sorting hashes in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-15#lperl3-CHP-15">Chapter
			15</A>. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic4" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-5-SECT-4"></A>5.4 Typical Use of a Hash</H3>
			<P>At this point, you may find it helpful to see a more concrete
			example. 
			</P>
			<P>The Bedrock library uses a Perl program in which a hash keeps
			track of how many books each person has checked out, among other
			information: 
			</P>
			<PRE><FONT COLOR="#cc0000">$books{&quot;fred&quot;} = 3;</FONT>
<FONT COLOR="#cc0000">$books{&quot;wilma&quot;} = 1;</FONT></PRE><P>
			It's easy to see whether an element of the hash is true or false,
			do this: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ($books{$someone}) {</FONT>
<FONT COLOR="#cc0000">  print &quot;$someone has at least one book checked out.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			But there are some elements of the hash that aren't true:</P>
			<PRE><FONT COLOR="#cc0000">$books{&quot;barney&quot;} = 0;       # no books currently checked out</FONT>
<FONT COLOR="#cc0000">$books{&quot;pebbles&quot;} = undef;  # no books EVER checked out - a new library card</FONT></PRE><P>
			Since Pebbles has never checked out any books, her entry has the
			value of <TT><FONT COLOR="#cc0000">undef</FONT></TT>, rather than
			<TT><FONT COLOR="#cc0000">0</FONT></TT>. 
			</P>
			<P>There's a key in the hash for everyone who has a library card.
			For each key (that is, for each library patron), there's a value
			that is either a number of books checked out, or <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			if that person's library card has never been used. 
			</P>
			<H4><A NAME="lperl3-CHP-5-SECT-4.1"></A>5.4.1 The exists Function</H4>
			<P><A NAME="IXT-5-336100"></A><A NAME="IXT-5-336101"></A>To see
			whether a key exists in the hash, (that is, whether someone has a
			library card or not), use the <TT><FONT COLOR="#cc0000">exists</FONT></TT>
			function, which returns a true value if the given key exists in
			the hash, whether the corresponding value is true or not: 
			</P>
			<PRE><FONT COLOR="#cc0000">if (exists $books{&quot;dino&quot;}) {</FONT>
<FONT COLOR="#cc0000">  print &quot;Hey, there's a library card for dino!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			That is to say, <TT><FONT COLOR="#cc0000">exists $books{&quot;dino&quot;}</FONT></TT>
			will return a true value if (and only if) <TT><FONT COLOR="#cc0000">dino</FONT></TT>
			is found in the list of keys from <TT><FONT COLOR="#cc0000">keys
			%books</FONT></TT>. 
			</P>
			<H4><A NAME="lperl3-CHP-5-SECT-4.2"></A>5.4.2 The delete Function</H4>
			<P><A NAME="IXT-5-336102"></A><A NAME="IXT-5-336103"></A>The
			<TT><FONT COLOR="#cc0000">delete</FONT></TT> function removes the
			given key (and its corresponding value) from the hash. (If there's
			no such key, its work is done; there's no warning or error in that
			case.) 
			</P>
			<PRE><FONT COLOR="#cc0000">my $person = &quot;betty&quot;;</FONT>
<FONT COLOR="#cc0000">delete $books{$person};  # Revoke the library card for $person</FONT></PRE><P>
			Note that this is not the same as storing <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			into that hash element&iuml;&frac34;—in fact, it's precisely the
			opposite! Checking <TT><FONT COLOR="#cc0000">exists($books{&quot;betty&quot;})</FONT></TT>
			will give opposite results in these two cases; after a <TT><FONT COLOR="#cc0000">delete</FONT></TT>,
			the key can't exist in the hash, but after storing <TT><FONT COLOR="#cc0000">undef</FONT></TT>,
			the key must exist. 
			</P>
			<H4><A NAME="lperl3-CHP-5-SECT-4.3"></A>5.4.3 Hash Element
			Interpolation</H4>
			<P><A NAME="IXT-5-336104"></A><A NAME="IXT-5-336105"></A>You can
			interpolate a single hash element into a double-quoted string just
			as you'd expect: 
			</P>
			<PRE><FONT COLOR="#cc0000">foreach $person (sort keys %books) {            # for each library patron,in order</FONT>
<FONT COLOR="#cc0000">  if ($books{$person}) {</FONT>
<FONT COLOR="#cc0000">    print &quot;$person has $books{$person} items\n&quot;;# fred has 3 items</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-5-336106"></A>But there's no support for entire hash
			interpolation; <TT><FONT COLOR="#cc0000">&quot;%books&quot;</FONT></TT>
			is just the six chararcters of (literally) <TT><FONT COLOR="#cc0000">%books</FONT></TT>.<A HREF="#">[16]</A>
			So we've seen all of the magical characters that need backslashing
			in double quotes: <TT><FONT COLOR="#cc0000">$</FONT></TT> and <TT><FONT COLOR="#cc0000">@</FONT></TT>,
			because they introduce a variable to be interpolated; <TT><FONT COLOR="#cc0000">&quot;</FONT></TT>,
			since that's the quoting character that would otherwise end the
			double-quoted string; and <TT><FONT COLOR="#cc0000">\</FONT></TT>,
			the backslash itself. Any other characters in a double-quoted
			string are non-magical and should simply stand for themselves.<A HREF="#">[17]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP>
			Well, it couldn't really be anything else; if we tried to print
			out the entire hash, as a series of key-value pairs, that would be
			nearly useless. And, as we'll see in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-6#lperl3-CHP-6">Chapter
			6</A>, the percent sign is frequently used in <TT><FONT COLOR="#cc0000">printf
			</FONT></TT>format strings; giving it another meaning here would
			be terribly inconvenient.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP> But
			do beware of the apostrophffffffe (<TT><FONT COLOR="#cc0000">'</FONT></TT>),
			left square bracket (<TT><FONT COLOR="#cc0000">[</FONT></TT>),
			left curly brace (<TT><FONT COLOR="#cc0000">{</FONT></TT>), the
			small arrow (<TT><FONT COLOR="#cc0000">-&gt;</FONT></TT>), or
			double-colon (<TT><FONT COLOR="#cc0000">::</FONT></TT>) following
			a variable name in a double-quoted string, as they could perhaps
			mean something you didn't intend.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic5" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=0 FRAME=VOID RULES=COLS>
	<COL WIDTH=8*>
	<COL WIDTH=85*>
	<COL WIDTH=138*>
	<COL WIDTH=25*>
	<TBODY>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<H3><A NAME="lperl3-CHP-5-SECT-5"></A>5.5 Exercises</H3>
				<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-4#lperl3-APP-A-SECT-4">Section
				A.4</A> for answers to the following exercises: 
				</P>
				<OL>
					<LI><P STYLE="font-weight: medium"><A NAME="ch05-11-fm2xml"></A>[7]
					Write a program that will ask the user for a given name and
					report the corresponding family name. Use the names of people
					you know, or (if you spend so much time on the computer that you
					don't know any actual people) use the following table: 
					</P>
				</OL>
			</TD>
		</TR>
		<TR>
			<TD ROWSPAN=4 WIDTH=3% VALIGN=TOP></TD>
			<TH WIDTH=33%>
				<P>Input</P>
			</TH>
			<TH WIDTH=54%>
				<P>Output</P>
			</TH>
			<TD ROWSPAN=4 WIDTH=10% VALIGN=TOP></TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=33%>
				<P><TT><FONT COLOR="#cc0000">fred</FONT></TT></P>
			</TD>
			<TD WIDTH=54%>
				<P><TT><FONT COLOR="#cc0000">flintstone</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=33%>
				<P><TT><FONT COLOR="#cc0000">barney</FONT></TT></P>
			</TD>
			<TD WIDTH=54%>
				<P><TT><FONT COLOR="#cc0000">rubble</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=33%>
				<P><TT><FONT COLOR="#cc0000">wilma</FONT></TT></P>
			</TD>
			<TD WIDTH=54%>
				<P><TT><FONT COLOR="#cc0000">flintstone</FONT></TT></P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<OL START=2>
					<LI><P><A NAME="IXTR3-35"></A>[15] Write a program that reads a
					series of words (with one word per line<A HREF="#">[18]</A>)
					until end-of-input, then prints a summary of how many times each
					word was seen. (Hint: remember that when an undefined value is
					used as if it were a number, Perl automatically converts it to
					<TT><FONT COLOR="#cc0000">0</FONT></TT>. It may help to look
					back at the earlier exercise that kept a running total.) So, if
					the input words were <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
					<TT><FONT COLOR="#cc0000">barney</FONT></TT>, <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
					<TT><FONT COLOR="#cc0000">dino</FONT></TT>, <TT><FONT COLOR="#cc0000">wilma</FONT></TT>,
					<TT><FONT COLOR="#cc0000">fred</FONT></TT> (all on separate
					lines), the output should tell us that <TT><FONT COLOR="#cc0000">fred</FONT></TT>
					was seen <TT><FONT COLOR="#cc0000">3</FONT></TT> times. For
					extra credit, sort the summary words in ASCII order in the
					output. 
					</P>
					<P STYLE="margin-right: 1cm; font-weight: medium"><SUP>[18]</SUP>
					It has to be one word per line, because we still haven't shown
					you how to extract individual words from a line of input.</P>
				</OL>
				<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic6" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H2><A NAME="lperl3-CHP-6"></A>Chapter 6. I/O Basics</H2>
			<P><A NAME="lperl3-IDXTERM-419"></A><A NAME="lperl3-IDXTERM-420"></A><A NAME="lperl3-IDXTERM-421"></A><A NAME="lperl3-IDXTERM-422"></A><A NAME="lperl3-IDXTERM-423"></A><A NAME="IXT-6-336107"></A>
			We've already seen how to do some input/output (I/O), in order to
			make some of the earlier exercises possible. But now we'll learn a
			little more about those operations. As the title of this chapter
			implies, there will be more about Perl's I/O operations in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-11#lperl3-CHP-11">Chapter
			11</A>. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-6-SECT-1"></A>6.1 Input from Standard
			Input</H3>
			<P>Reading from the standard input stream is easy.<A HREF="#">[1]</A>
			We've been doing it already with the <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>
			operator.<A HREF="#">[2]</A> Evaluating this operator in a scalar
			context gives you the next line of input: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP> If
			you're already familiar with the workings of standard input,
			output, and error streams, you're ahead of the game. If not, we'll
			get you caught up when we get to <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-14#lperl3-CHP-14">Chapter
			14</A>. For now, just think of &quot;standard input&quot; as being
			&quot;the keyboard,&quot; and &quot;standard output&quot; as being
			&quot;the display screen.&quot;</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> What
			we're calling the line-input operator here, <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>,
			is actually a line-input operator (represented by the angle
			brackets) around a <I>filehandle</I>. We'll learn about
			filehandles in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-11#lperl3-CHP-11">Chapter
			11</A>.</P>
			<PRE><FONT COLOR="#cc0000">$line = &lt;STDIN&gt;;                # read the next line</FONT>
<FONT COLOR="#cc0000">chomp($line);                   # and chomp it</FONT>

<FONT COLOR="#cc0000">chomp($line = &lt;STDIN&gt;);         # same thing, more idiomatically</FONT></PRE><P>
			Since the line-input operator will return <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			when you reach end-of-file, this is handy for dropping out of
			loops: 
			</P>
			<PRE><FONT COLOR="#cc0000">while (defined($line = &lt;STDIN&gt;)) {</FONT>
<FONT COLOR="#cc0000">  print &quot;I saw $line&quot;;</FONT>
<FONT COLOR="#cc0000">{</FONT></PRE><P>
			<A NAME="lperl3-IDXTERM-425"></A><A NAME="lperl3-IDXTERM-426"></A>There's
			a lot going on in that first line: we're reading the input into a
			variable, checking that it's defined, and if it is (meaning that
			we haven't reached the end of the input) we're running the body of
			the <TT><FONT COLOR="#cc0000">while</FONT></TT> loop. So, inside
			the body of the loop, we'll see each line, one after another, in
			<TT><FONT COLOR="#cc0000">$line</FONT></TT>.<A HREF="#">[3]</A>
			This is something you'll want to do fairly often, so naturally
			Perl has a shortcut for it. The shortcut looks like this: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP> You
			probably noticed that we never chomped that input. In this kind of
			a loop, you can't really put <TT><FONT COLOR="#cc0000">chomp </FONT></TT>into
			the conditional expression, so it's often the first item in the
			loop body, when it's needed. We'll see examples of that in the
			next section.</P>
			<PRE><FONT COLOR="#cc0000">while (&lt;STDIN&gt;) {</FONT>
<FONT COLOR="#cc0000">  print &quot;I saw $_&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Now, to make this shortcut, Larry chose some useless syntax. That
			is, this is literally saying, &quot;Read a line of input, and see
			if it's true. (Normally it is.) And if it is true, enter the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop, but throw away that line of input!&quot; Larry knew that it
			was a useless thing to do; nobody should ever need to do that in a
			real Perl program. So, Larry took this useless syntax and made it
			useful. 
			</P>
			<P>What this is actually saying is that Perl should do the same
			thing as we saw in our earlier loop: it tells Perl to read the
			input into a variable, and (as long as the result was defined, so
			we haven't reached end-of file) then enter the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop. However, instead of storing the input into <TT><FONT COLOR="#cc0000">$line</FONT></TT>,
			Perl will use its favorite default variable, <TT><FONT COLOR="#cc0000">$_</FONT></TT>,
			just as if you had written this: 
			</P>
			<PRE><FONT COLOR="#cc0000">while (defined($_ = &lt;STDIN&gt;)) {</FONT>
<FONT COLOR="#cc0000">  print &quot;I saw $_&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Now, before we go any further, we must be very clear about
			something: this shortcut works only if you write it just as we
			did. If you put a line-input operator anywhere else (in
			particular, as a statement all on its own) it won't read a line
			into <TT><FONT COLOR="#cc0000">$_</FONT></TT> by default. It works
			only if there's nothing but the line-input operator in the
			conditional of a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop.<A HREF="#">[4]</A> If you put anything else into the
			conditional expression, this shortcut won't apply. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP>
			Well, okay, the conditional of a <TT><FONT COLOR="#cc0000">for</FONT></TT>
			loop is just a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			conditional in disguise, so it works there, too.</P>
			<P><A NAME="IXT-6-336108"></A><A NAME="IXT-6-336109"></A>There's
			no connection between the line-input operator (<TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>)
			and Perl's favorite default variable (<TT><FONT COLOR="#cc0000">$_</FONT></TT>).
			In this case, though, it just happens that the input is being
			stored in that variable. 
			</P>
			<P>On the other hand, evaluating the line-input operator in a list
			context gives you all of the (remaining) lines of input as a
			list&iuml;&frac34;—each element of the list is one line: 
			</P>
			<PRE><FONT COLOR="#cc0000">foreach (&lt;STDIN&gt;) {</FONT>
<FONT COLOR="#cc0000">  print &quot;I saw $_&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Once again, there's no connection between the line-input operator
			and Perl's favorite default variable. In this case, though, the
			default control variable for <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			is <TT><FONT COLOR="#cc0000">$_</FONT></TT>. So in this loop,
			we'll see each line of input in <TT><FONT COLOR="#cc0000">$_</FONT></TT>,
			one after the other. 
			</P>
			<P>That may sound familiar, and for good reason: That's the same
			behavior as the <TT><FONT COLOR="#cc0000">while</FONT></TT> loop
			would do. Isn't it? 
			</P>
			<P><A NAME="IXTR3-36"></A><A NAME="IXTR3-37"></A>The difference is
			under the hood. In the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop, Perl reads a line of input, puts it into a variable, and
			runs the body of the loop. Then, it goes back to find another line
			of input. But in the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, the line-input operator is being used in a list context
			(since <TT><FONT COLOR="#cc0000">foreach</FONT></TT> needs a list
			to iterate through). So it has to read all of the input before the
			loop can start running. That difference will become apparent when
			the input is coming from your 400MB web server log file! It's
			generally best to use code like the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop's shortcut, which will process input a line at a time,
			whenever possible. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic7" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-6-SECT-2"></A>6.2 Input from the Diamond
			Operator</H3>
			<P><A NAME="lperl3-IDXTERM-431"></A><A NAME="lperl3-IDXTERM-432"></A><A NAME="lperl3-IDXTERM-433"></A><A NAME="IXT-6-336111"></A><A NAME="IXT-6-336112"></A>
			Another way to read input is with the diamond<A HREF="#">[5]</A>
			operator: <TT><FONT COLOR="#cc0000">&lt;&gt;</FONT></TT>. This is
			useful for making programs that work like standard Unix<A HREF="#">[6]</A>
			utilities, with respect to the invocation arguments (which we'll
			see in a moment). If you want to make a Perl program that can be
			used like the utilities <I>cat</I>, <I>sed</I>, <I>awk</I>, <I>sort</I>,
			<I>grep</I>, <I>lpr</I>, and many others, the diamond operator
			will be your friend. If you want to make anything else, the
			diamond operator probably won't help. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-6-336110"></A>
			<SUP>[5]</SUP> The diamond operator was named by Larry's daughter,
			Heidi, when Randal went over to Larry's house one day to show off
			the new training materials he'd been writing, and complained that
			there was no spoken name for &quot;that thing&quot;. Larry didn't
			have a name for it, either. Heidi (eight years old at the time)
			quickly chimed in, &quot;That's a diamond, Daddy.&quot; So the
			name stuck. Thanks, Heidi!</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP> But
			not just on Unix systems. Many other systems have adopted this way
			of using invocation arguments.</P>
			<P>The <I>invocation arguments</I> to a program are normally a
			number of &quot;words&quot; on the command line after the name of
			the program.<A HREF="#">[7]</A> In this case, they give the names
			of a number of files to be processed in sequence: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP>
			Whenever a program is started, it has a list of zero or more
			invocation arguments, supplied by whatever program is starting it.
			Often this is the shell, which makes up the list depending upon
			what you type on the command line. But we'll see in a later
			chapter that you can invoke a program with pretty much any strings
			as the invocation arguments. Because they often come from the
			shell's command line, they are sometimes called &quot;command-line
			arguments&quot; as well.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$ <B>./my_program fred barney betty</B></FONT></PRE><P>
			That command means to run the command <I>my_program</I> (which
			will be found in the current directory), and that it should
			process file fred, followed by file barney, followed by file
			betty. 
			</P>
			<P><A NAME="IXT-6-336113"></A><A NAME="IXT-6-336114"></A>If you
			give no invocation arguments, the program should process the
			standard input stream. Or, as a special case, if you give just a
			hyphen as one of the arguments, that means standard input as
			well.<A HREF="#">[8]</A> So, if the invocation arguments had been
			<TT><FONT COLOR="#cc0000">fred - betty</FONT></TT>, that would
			have meant that the program should process file fred, followed by
			the standard input stream, followed by file betty. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP>
			Here's a possibly unfamilar Unix fact: most of those standard
			utilities, like <I>cat </I>and <I>sed </I>use this same
			convention, where a hyphen stands for the standard input stream. 
			</P>
			<P>The benefit of making your programs work like this is that you
			may choose where the program gets its input at run time; for
			example, you won't have to rewrite the program to use it in a
			pipeline (which we'll discuss more later). Larry put this feature
			into Perl because he wanted to make it easy for you to write your
			own programs that work like standard Unix utilities&iuml;&frac34;—even
			on non-Unix machines. Actually, he did it so he could make his own
			programs work like standard Unix utilities; since some vendors'
			utilities don't work just like others', Larry could make his own
			utilities, deploy them on a number of machines, and know that
			they'd all have the same behavior. Of course, this meant porting
			Perl to every machine he could find. 
			</P>
			<P><A NAME="IXT-6-336115"></A>The diamond operator is actually a
			special kind of line-input operator. But instead of getting the
			input from the keyboard, it comes from the user's choice of
			input:<A HREF="#">[9]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP>
			Which may or may not include getting input from the keyboard.</P>
			<PRE><FONT COLOR="#cc0000">while (defined($line = &lt;&gt;)) {</FONT>
<FONT COLOR="#cc0000">  chomp($line);</FONT>
<FONT COLOR="#cc0000">  print &quot;It was $line that I saw!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			So, if we run this program with the invocation arguments <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
			<TT><FONT COLOR="#cc0000">barney</FONT></TT>, and <TT><FONT COLOR="#cc0000">betty</FONT></TT>,
			it will say something like: &quot;It was [a line from file <I>fred</I>]
			that I saw!&quot;, &quot;It was [another line from file <I>fred</I>]
			that I saw!&quot;, on and on until it reaches the end of file
			<TT><FONT COLOR="#cc0000">fred</FONT></TT>. Then, it will
			automatically go on to file <TT><FONT COLOR="#cc0000">barney</FONT></TT>,
			printing out one line after another, and then on to file <TT><FONT COLOR="#cc0000">betty</FONT></TT>.
			Note that there's no break when we go from one file to another;
			when you use the diamond, it's as if the input files have been
			merged into one big file.<A HREF="#">[10]</A> The diamond will
			return <TT><FONT COLOR="#cc0000">undef</FONT></TT> (and we'll drop
			out of the <TT><FONT COLOR="#cc0000">while</FONT></TT> loop) only
			at the end of all of the input. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-6-336116"></A>
			<SUP>[10]</SUP> If it matters to you, or even if it doesn't, the
			current file's name is kept in Perl's special variable <TT><FONT COLOR="#cc0000">$ARGV</FONT></TT>.
			This name may be <TT><FONT COLOR="#cc0000">&quot;-&quot;</FONT></TT>
			instead of a real filename if the input is coming from the
			standard input stream, though.</P>
			<P>In fact, since this is just a special kind of line-input
			operator, we may use the same shortcut we saw earlier, to read the
			input into <TT><FONT COLOR="#cc0000">$_</FONT></TT> by default: 
			</P>
			<PRE><FONT COLOR="#cc0000">while (&lt;&gt;) {</FONT>
<FONT COLOR="#cc0000">  chomp;</FONT>
<FONT COLOR="#cc0000">  print &quot;It was $_ that I saw!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			This works like the loop above, but with less typing. And you may
			have noticed that we're using the default for <TT><FONT COLOR="#cc0000">chomp</FONT></TT>;
			without an argument, <TT><FONT COLOR="#cc0000">chomp</FONT></TT>
			will work on <TT><FONT COLOR="#cc0000">$_</FONT></TT>. Every
			little bit of saved typing helps! 
			</P>
			<P>Since the diamond operator is generally being used to process
			all of the input, it's typically a mistake to use it in more than
			one place in your program. If you find yourself putting two
			diamonds into the same program, especially using the second
			diamond inside the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop that is reading from the first one, it's almost certainly not
			going to do what you would like.<A HREF="#">[11]</A> In our
			experience, when beginners put a second diamond into a program,
			they meant to use <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			instead. Remember, the diamond operator reads the input, but the
			input itself is (generally, by default) found in <TT><FONT COLOR="#cc0000">$_</FONT></TT>.
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP> If
			you re-initialize <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>
			before using the second diamond, then you're on solid ground.
			We'll see <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT> in the next
			section.</P>
			<P><A NAME="IXT-6-336117"></A>If the diamond operator can't open
			one of the files and read from it, it'll print an allegedly
			helpful diagnostic message, such as: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><A NAME="IXT-6-336118"></A><FONT COLOR="#cc0000">can't open wimla: No such file or directory</FONT></PRE><P>
			<A NAME="IXTR3-38"></A><A NAME="IXTR3-39"></A>The diamond operator
			will then go on to the next file automatically, much like what
			you'd expect from <I>cat</I> or another standard utility. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-6-SECT-3"></A>6.3 The Invocation Arguments</H3>
			<P><A NAME="IXT-6-336119"></A><A NAME="IXT-6-336120"></A><A NAME="IXT-6-336121"></A>
			Technically, the diamond operator isn't looking literally at the
			invocation arguments&iuml;&frac34;—it works from the <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>
			array. This array is a special array that is preset by the Perl
			interpreter to be a list of the invocation arguments. In other
			words, this is just like any other array, (except for its funny,
			all-caps name), but when your program starts, <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>
			is already stuffed full of the list of invocation arguments.<A HREF="#">[12]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-6-336122"></A><A NAME="IXT-6-336123"></A>
			<SUP>[12]</SUP> C programmers may be wondering about <TT><FONT COLOR="#cc0000">argc</FONT></TT>
			(there isn't one in Perl), and what happened to the program's own
			name (that's found in Perl's special variable <TT><FONT COLOR="#cc0000">$0</FONT></TT>,
			not <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>). Also, depending
			upon how you've invoked your program, there may be a little more
			happening than we say here. See the perlrunmanpage for the full
			details.</P>
			<P>You can use <TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">@ARGV</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			just like any other array;</SPAN> you could <TT><FONT COLOR="#cc0000">shift</FONT></TT>
			items off of it, perhaps, or use <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			to iterate over it. You could even check to see if any arguments
			start with a hyphen, so that you could process them as invocation
			options (like Perl does with its own <TT><FONT COLOR="#cc0000">-w</FONT></TT>
			option).<A HREF="#">[13]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP> If
			you need more than just one or two such options, you should almost
			certainly use a module to process them in a standard way. See the
			documentation for the <TT><FONT COLOR="#cc0000">Getopt::Long</FONT></TT>
			and <TT><FONT COLOR="#cc0000">Getopt::Std</FONT></TT> modules,
			which are part of the standard distribution.</P>
			<P>This is how the diamond operator knows what filenames it should
			use: it looks in <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>. If
			it finds an empty list, it uses the standard input stream;
			otherwise it uses the list of files that it finds. This means that
			after your program starts and before you start using the diamond,
			you've got a chance to tinker with <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>.
			For example, here we can process three specific files, regardless
			of what the user chose on the command line: 
			</P>
			<PRE><FONT COLOR="#cc0000">@ARGV = qw# larry moe curly #;  # force these three files to be read</FONT>
<FONT COLOR="#cc0000">while (&lt;&gt;) {</FONT>
<FONT COLOR="#cc0000">  chomp;</FONT>
<FONT COLOR="#cc0000">  print &quot;It was $_ that I saw in some stooge-like file!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXTR3-40"></A>In <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-11#lperl3-CHP-11">Chapter
			11</A>, we'll see how to open and close specific filenames at
			specific times. But this technique will suffice for the next few
			chapters. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic8" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-6-SECT-4"></A>6.4 Output to Standard
			Output</H3>
			<P><A NAME="lperl3-IDXTERM-450"></A><A NAME="lperl3-IDXTERM-451"></A><A NAME="lperl3-IDXTERM-452"></A><A NAME="IXT-6-336124"></A>
			The <TT><FONT COLOR="#cc0000">print</FONT></TT> operator takes a
			list of values and sends each item (as a string, of course) to
			standard output in turn, one after another. It doesn't add any
			extra characters before, after, or in between the items;<A HREF="#">[14]</A>
			if you want spaces between items and a newline at the end, you
			have to say so: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP>
			Well, it doesn't add anything extra by default, but this default
			(like so many others in Perl) may be changed. Changing these
			defaults will likely confuse your maintenance programmer, though,
			so avoid doing so except in small, quick-and-dirty programs, or
			(rarely) in a small section of a normal program. See the
			perlvarmanpage to learn about changing the defaults.</P>
			<PRE><FONT COLOR="#cc0000">$name = &quot;Larry Wall&quot;;</FONT>
<FONT COLOR="#cc0000">print &quot;Hello there, $name, did you know that 3+4 is &quot;, 3+4, &quot;?\n&quot;;</FONT></PRE><P>
			<A NAME="IXT-6-336125"></A>Of course, that means that there's a
			difference between printing an array and interpolating an array: 
			</P>
			<PRE><FONT COLOR="#cc0000">print @array;     # print a list of items</FONT>
<FONT COLOR="#cc0000">print &quot;@array&quot;;   # print a string (containing an interpolated array)</FONT></PRE><P>
			That first <TT><FONT COLOR="#cc0000">print</FONT></TT> statement
			will print a list of items, one after another, with no spaces in
			between. The second one will print exactly one item, which is the
			string you get by interpolating <TT><FONT COLOR="#cc0000">@array</FONT></TT>
			into the empty string&iuml;&frac34;—that is, it prints the
			contents of <TT><FONT COLOR="#cc0000">@array</FONT></TT>,
			separated by spaces.<A HREF="#">[15]</A> So, if <TT><FONT COLOR="#cc0000">@array</FONT></TT>
			holds <TT><FONT COLOR="#cc0000">qw/</FONT></TT> <TT><FONT COLOR="#cc0000">fred
			barney</FONT></TT> <TT><FONT COLOR="#cc0000">betty</FONT></TT>
			<TT><FONT COLOR="#cc0000">/</FONT></TT>,<A HREF="#">[16]</A> the
			first one prints <TT><FONT COLOR="#cc0000">fredbarneybetty</FONT></TT>,
			while the second prints <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			<TT><FONT COLOR="#cc0000">barney betty</FONT></TT> separated by
			spaces. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP>
			Yes, the spaces are another default; see the perlvarmanpage again.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP> You
			know that we mean a three-element list here, right? This is just
			Perl notation.</P>
			<P>But before you decide to always use the second form, imagine
			that <TT><FONT COLOR="#cc0000">@array</FONT></TT> is a list of
			unchomped lines of input. That is, imagine that each of its
			strings has a trailing newline character. Now, the first <TT><FONT COLOR="#cc0000">print</FONT></TT>
			statement prints <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
			<TT><FONT COLOR="#cc0000">barney</FONT></TT>, and <TT><FONT COLOR="#cc0000">betty</FONT></TT>
			on three separate lines. But the second one prints this: 
			</P>
			<PRE><FONT COLOR="#cc0000">fred</FONT>
<FONT COLOR="#cc0000"> barney</FONT>
<FONT COLOR="#cc0000"> betty</FONT></PRE><P>
			Do you see where the spaces come from? Perl is interpolating an
			array, so it puts spaces between the elements. So, we get the
			first element of the array (<TT><FONT COLOR="#cc0000">fred</FONT></TT>
			and a newline character), then a space, then the next element of
			the array (<TT><FONT COLOR="#cc0000">barney</FONT></TT> and a
			newline character), then a space, then the last element of the
			array (<TT><FONT COLOR="#cc0000">betty</FONT></TT> and a newline
			character). The result is that the lines seem to have become
			indented, except for the first one. Every week or two, a message
			appears on the newsgroup comp.lang.perl.misc with a subject line
			something like: 
			</P>
			<DL>
				<DD STYLE="margin-bottom: 0.5cm">Perl indents everything after
				the first line 
				</DD></DL>
			<P>
			<A NAME="IXT-6-336126"></A>Without even reading the message, we
			can immediately see that the program used double quotes around an
			array containing unchomped strings. &quot;Did you perhaps put an
			array of unchomped strings inside double quotes?&quot; we ask, and
			the answer is always yes. 
			</P>
			<P><A NAME="IXT-6-336127"></A><A NAME="IXT-6-336128"></A>Generally,
			if your strings contain newlines, you simply want to print them,
			after all: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print @array;</FONT></PRE><P>
			But if they don't contain newlines, you'll generally want to add
			one at the end: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print &quot;@array\n&quot;;</FONT></PRE><P>
			So, if you're using the quote marks, you'll be (generally) adding
			the <TT><FONT COLOR="#cc0000">\n</FONT></TT> at the end of the
			string anyway; this should help you to remember which is which. 
			</P>
			<P><A NAME="IXT-6-336129"></A><A NAME="IXT-6-336130"></A><A NAME="IXT-6-336131"></A><A NAME="IXT-6-336132"></A>
			It's normal for your program's output to be <I>buffered</I> . That
			is, instead of sending out every little bit of output at once,
			it'll be saved until there's enough to bother with. That's because
			if (for example) the output were going to be saved on disk, it
			would be (relatively) slow and inefficient to spin the disk every
			time that one or two characters need to be added to the file.
			Generally, then, the output will go into a buffer that is <I>flushed</I>
			(that is, actually written to disk, or wherever) only when the
			buffer gets full, or when the output is otherwise finished (such
			as at the end of runtime). Usually, that's what you want. 
			</P>
			<P>But if you (or a program) may be waiting impatiently for the
			output, you may wish to take that performance hit and flush the
			output buffer each time you <TT><FONT COLOR="#cc0000">print</FONT></TT>.
			See the Perl manpages for more information on controlling
			buffering in that case. 
			</P>
			<P>Since <TT><FONT COLOR="#cc0000">print</FONT></TT> is looking
			for a list of strings to print, its arguments are evaluated in
			list context. Since the diamond operator (as a special kind of
			line-input operator) will return a list of lines in a list
			context, these can work well together: 
			</P>
			<PRE><FONT COLOR="#cc0000">print &lt;&gt;;          # source code for 'cat'</FONT>

<FONT COLOR="#cc0000">print sort &lt;&gt;;  # source code for 'sort'</FONT></PRE><P>
			Well, to be fair, the standard Unix commands <I>cat</I> and <I>sort</I>
			do have some additional functionality that these replacements
			lack. But you can't beat them for the price! You can now
			re-implement all of your standard Unix utilities in Perl, and
			painlessly port them to any machine that has Perl, whether that
			machine is running Unix or not. And you can be sure that the
			programs on every different type of machine will nevertheless have
			the same behavior.<A HREF="#">[17]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP> In
			fact, there was even an endeavor started, called the PPT (Perl
			Power Tools) project, whose goal is to implement all of the
			classic Unix utilities in Perl. They actually completed nearly all
			the utilities (and most of the games!), but got bogged down when
			they got to reimplementing the shell. The PPT project has been
			helpful because it has made these standard utilities available on
			many non-Unix machines. 
			</P>
			<P><A NAME="IXT-6-336133"></A><A NAME="IXT-6-336134"></A>What
			might not be obvious is that <TT><FONT COLOR="#cc0000">print</FONT></TT>
			has optional parentheses, which can sometimes cause confusion.
			Remember the rule that parentheses in Perl may always be omitted,
			except when doing so would change the meaning of a statement. So,
			here are two ways to print the same thing: 
			</P>
			<PRE><FONT COLOR="#cc0000">print(&quot;Hello, world!\n&quot;);</FONT>
<FONT COLOR="#cc0000">print &quot;Hello, world!\n&quot;;</FONT></PRE><P>
			So far, so good. But another rule in Perl is that if the
			invocation of <TT><FONT COLOR="#cc0000">print</FONT></TT> looks
			like a function call, then it is a function call. It's a simple
			rule, but what does it mean for something to look like a function
			call? 
			</P>
			<P>In a function call, there's a function name immediately<A HREF="#">[18]</A>
			followed by parentheses around the function's arguments, like
			this: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP> We
			say &quot;immediately&quot; here because Perl won't permit a
			newline character between the function name and the opening
			parenthesis in this kind of function call. If there is a newline
			there, Perl sees your code as making a list operator, rather than
			a function call. This is the kind of piddling technical detail
			that we mention only for completeness. If you're terminally
			curious, see the full story in the manpages.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print (2+3);</FONT></PRE><P>
			<A NAME="IXT-6-336135"></A>That looks like a function call, so it
			is a function call. It prints <TT><FONT COLOR="#cc0000">5</FONT></TT>,
			but then it returns a value like any other function. The return
			value of <TT><FONT COLOR="#cc0000">print</FONT></TT> is a true or
			false value, indicating the success of the print. It nearly always
			succeeds, unless you get some I/O error, so the <TT><FONT COLOR="#cc0000">$result</FONT></TT>
			in the following statement will normally be <TT><FONT COLOR="#cc0000">1</FONT></TT>:
			
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$result = print(&quot;hello world!\n&quot;);</FONT></PRE><P>
			But what if you used the result in some other way? Let's suppose
			you decide to multiply the return value times four: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print (2+3)*4;  # Oops!</FONT></PRE><P>
			When Perl sees this line of code, it prints <TT><FONT COLOR="#cc0000">5</FONT></TT>,
			just as you asked. Then it takes the return value from <TT><FONT COLOR="#cc0000">print</FONT></TT>,
			which is <TT><FONT COLOR="#cc0000">1</FONT></TT>, and multiplies
			that times <TT><FONT COLOR="#cc0000">4</FONT></TT>. It then throws
			away the product, wondering why you didn't tell it to do something
			else with it. And at this point, someone looking over your
			shoulder says, &quot;Hey, Perl can't do math! That should have
			printed <TT><FONT COLOR="#cc0000">20</FONT></TT>, rather than <TT><FONT COLOR="#cc0000">5</FONT></TT>!&quot;
			
			</P>
			<P>This is the problem with allowing the parentheses to be
			optional; sometimes we humans forget where the parentheses really
			belong. When there are no parentheses, <TT><FONT COLOR="#cc0000">print</FONT></TT>
			is a list operator, printing all of the items in the following
			list; that's generally what you'd expect. But when the first thing
			after <TT><FONT COLOR="#cc0000">print</FONT></TT> is a left
			parenthesis, <TT><FONT COLOR="#cc0000">print</FONT></TT> is a
			function call, and it will print only what's found inside the
			parentheses. Since that line had parentheses, it's the same to
			Perl as if you'd said this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">( print(2+3) ) * 4;  # Oops!</FONT></PRE><P>
			Fortunately, Perl itself can almost always help you with this, if
			you ask for warnings&iuml;&frac34;—so use <TT><FONT COLOR="#cc0000">-w</FONT></TT>,
			at least during program development and debugging. 
			</P>
			<P><A NAME="IXTR3-41"></A>Actually, this rule&iuml;&frac34;—&quot;If
			it looks like a function call, it is a function call&quot;&iuml;&frac34;—applies
			to all list functions<A HREF="#">[19]</A> in Perl, not just to
			<TT><FONT COLOR="#cc0000">print</FONT></TT>. It's just that you're
			most likely to notice it with <TT><FONT COLOR="#cc0000">print</FONT></TT>.
			If <TT><FONT COLOR="#cc0000">print</FONT></TT> (or another
			function name) is followed by an open parenthesis, make sure that
			the corresponding close parenthesis comes after all of the
			arguments to that function. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[19]</SUP>
			Functions that take zero or one arguments don't suffer from this
			problem.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic9" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-6-SECT-5"></A>6.5 Formatted Output with
			printf</H3>
			<P><A NAME="lperl3-IDXTERM-466"></A><A NAME="lperl3-IDXTERM-467"></A><A NAME="lperl3-IDXTERM-468"></A>
			You may wish to have a little more control with your output than
			<TT><FONT COLOR="#cc0000">print</FONT></TT> provides. In fact, you
			may be accustomed to the formatted output of C's <TT><FONT COLOR="#cc0000">printf</FONT></TT>
			function. Fear not&iuml;&frac34;—Perl provides a comparable
			operation with the same name. 
			</P>
			<P>The <TT><FONT COLOR="#cc0000">printf</FONT></TT> operator takes
			a format string followed by a list of things to print. The
			format<A HREF="#">[20]</A> string is a fill-in-the-blanks template
			showing the desired form of the output: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[20]</SUP>
			Here, we're using &quot;format&quot; in the generic sense. Perl
			has a report-generating feature called &quot;formats&quot; that we
			won't even be mentioning (except in this footnote) until <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-B#lperl3-APP-B">Appendix
			B</A>, and then only to say that we really aren't going to talk
			about them. So, you're on your own there. Just wanted to keep you
			from getting lost.</P>
			<PRE><FONT COLOR="#cc0000">printf &quot;Hello, %s; your password expires in %d days!\n&quot;,</FONT>
<FONT COLOR="#cc0000">  $user, $days_to_die;</FONT></PRE><P>
			<A NAME="IXT-6-336136"></A><A NAME="IXT-6-336137"></A><A NAME="IXT-6-336138"></A><A NAME="IXT-6-336139"></A>
			The format string holds a number of so-called <I>conversions</I> ;
			each conversion begins with a percent sign (<TT><FONT COLOR="#cc0000">%</FONT></TT>)
			and ends with a letter. (As we'll see in a moment, there may be
			significant extra characters between these two symbols.) There
			should be the same number of items in the following list as there
			are conversions; if these don't match up, it won't work correctly.
			In the example above, there are two items and two conversions, so
			the output might look something like this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">Hello, merlyn; your password expires in 3 days!</FONT></PRE><P>
			There are many possible <TT><FONT COLOR="#cc0000">printf</FONT></TT>
			conversions, so we'll take time here to describe just the most
			common ones. Of course, the full details are available in the
			<TT><FONT COLOR="#cc0000">perlfunc</FONT></TT> manpage. 
			</P>
			<P><A NAME="IXT-6-336140"></A><A NAME="IXT-6-336141"></A>To print
			a number in what's generally a good way, use <TT><FONT COLOR="#cc0000">%g</FONT></TT>
			,<A HREF="#">[21]</A> which automatically chooses floating-point,
			integer, or even exponential notation as needed: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[21]</SUP>
			&quot;General&quot; numeric conversion. Or maybe a &quot;Good
			conversion for this number&quot; or &quot;Guess what I want the
			output to look like.&quot;</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">printf &quot;%g %g %g\n&quot;, 5/2, 51/17, 51 ** 17;  # 2.5 3 1.0683e+29</FONT></PRE><P>
			<A NAME="IXT-6-336142"></A><A NAME="IXT-6-336143"></A><A NAME="IXT-6-336144"></A>
			The <TT><FONT COLOR="#cc0000">%d</FONT></TT> format means a
			decimal<A HREF="#">[22]</A> integer, truncated as needed: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[22]</SUP>
			There's also <TT><FONT COLOR="#cc0000">%x</FONT></TT> for
			hexadecimal and <TT><FONT COLOR="#cc0000">%o</FONT></TT> for
			octal, if you need those. But we really say &quot;decimal&quot;
			here as a memory aid: <TT><FONT COLOR="#cc0000">%d</FONT></TT> for
			Decimal integer.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">printf &quot;in %d days!\n&quot;, 17.85;  # in 17 days!</FONT></PRE><P>
			Note that this is truncated, not rounded; we'll see how to round
			off a number in a moment. 
			</P>
			<P>In Perl, <TT><FONT COLOR="#cc0000">printf</FONT></TT> is most
			often used for columnar data, since most formats accept a field
			width. If the data won't fit, the field will generally be expanded
			as needed: 
			</P>
			<PRE><FONT COLOR="#cc0000">printf &quot;%6d\n&quot;, 42;  # output like ````42 (the ` symbol stands for a space)</FONT>
<FONT COLOR="#cc0000">printf &quot;%2d\n&quot;, 2e3 + 1.95;  # 2001</FONT></PRE><P>
			<A NAME="IXT-6-336145"></A>The <TT><FONT COLOR="#cc0000">%s</FONT></TT>
			conversion means a string, so it effectively interpolates the
			given value as a string, but with a given field width: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">printf &quot;%10s\n&quot;, &quot;wilma&quot;;  # looks like `````wilma</FONT></PRE><P>
			A negative field width is left-justified (in any of these
			conversions): 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">printf &quot;%-15s\n&quot;, &quot;flintstone&quot;;  # looks like flintstone `````</FONT></PRE><P>
			<A NAME="IXT-6-336146"></A><A NAME="IXT-6-336147"></A>The <TT><FONT COLOR="#cc0000">%f</FONT></TT>
			conversion (floating-point) rounds off its output as needed, and
			even lets you request a certain number of digits after the decimal
			point: 
			</P>
			<PRE><FONT COLOR="#cc0000">printf &quot;%12f\n&quot;, 6 * 7 + 2/3;    # looks like ```42.666667</FONT>
<FONT COLOR="#cc0000">printf &quot;%12.3f\n&quot;, 6 * 7 + 2/3;  # looks like ``````42.667</FONT>
<FONT COLOR="#cc0000">printf &quot;%12.0f\n&quot;, 6 * 7 + 2/3;  # looks like ``````````43</FONT></PRE><P>
			<A NAME="IXT-6-336148"></A>To print a real percent sign, use <TT><FONT COLOR="#cc0000">%%</FONT></TT>,
			which is special in that it uses no element from the list:<A HREF="#">[23]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[23]</SUP>
			Maybe you thought you could simply put a backslash in front of the
			percent sign. Nice try, but no. The reason that won't work is that
			the format is an expression, and the expression <TT><FONT COLOR="#cc0000">&quot;\%&quot;</FONT></TT>
			means the one-character string <TT><FONT COLOR="#cc0000">'%'</FONT></TT>.
			Even if we got a backslash into the format string, <TT><FONT COLOR="#cc0000">printf
			</FONT></TT>wouldn't know what to do with it. Besides, C
			programmers are used to <TT><FONT COLOR="#cc0000">printf </FONT></TT>working
			like this.</P>
			<PRE><FONT COLOR="#cc0000">printf &quot;Monthly interest rate: %.2f%%\n&quot;,</FONT>
<FONT COLOR="#cc0000">  5.25/12;  # the value looks like &quot;0.44%&quot;</FONT></PRE><H4>
			<A NAME="lperl3-CHP-6-SECT-5.1"></A>6.5.1 Arrays and printf</H4>
			<P><A NAME="IXT-6-336149"></A>Generally, you won't use an array as
			an argument to <TT><FONT COLOR="#cc0000">printf</FONT></TT>.
			That's because an array may hold any number of items, and a given
			format string will work with only a certain fixed number of items:
			if there are three conversions in the format, there must be
			exactly three items. 
			</P>
			<P>But there's no reason you can't whip up a format string on the
			fly, since it may be any expression. This can be tricky to get
			right, though, so it may be handy (especially when debugging) to
			store the format into a variable: 
			</P>
			<PRE><FONT COLOR="#cc0000">my @items = qw( wilma dino pebbles );</FONT>
<FONT COLOR="#cc0000">my $format = &quot;The items are:\n&quot; . (&quot;%10s\n&quot; x @items);</FONT>
<FONT COLOR="#cc0000">## print &quot;the format is &lt;&lt;$format&gt;&gt;\n&quot;; # for debugging</FONT>
<FONT COLOR="#cc0000">printf $format, @items;</FONT></PRE><P>
			<A NAME="IXT-6-336150"></A><A NAME="IXT-6-336151"></A>This uses
			the <TT><FONT COLOR="#cc0000">x</FONT></TT> operator (which we
			learned about in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-2#lperl3-CHP-2">Chapter
			2</A>) to replicate the given string a number of times given by
			<TT><FONT COLOR="#cc0000">@items</FONT></TT> (which is being used
			in a scalar context). In this case, that's <TT><FONT COLOR="#cc0000">3</FONT></TT>,
			since there are three items, so the resulting format string is the
			same as if we had written it as <TT><FONT COLOR="#cc0000">&quot;The
			items are:\n%10s\n%10s\n%10s\n</FONT></TT>.<TT><FONT COLOR="#cc0000">&quot;</FONT></TT>
			And the output prints each item on its own line, right-justified
			in a ten-character column, under a heading line. Pretty cool, huh?
			But not cool enough, because you can even combine these: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">printf &quot;The items are:\n&quot;.(&quot;%10s\n&quot; x @items), @items;</FONT></PRE><P>
			<A NAME="IXTR3-42"></A><A NAME="IXTR3-43"></A><A NAME="IXTR3-44"></A><A NAME="IXTR3-45"></A>
			Note that here we have <TT><FONT COLOR="#cc0000">@items</FONT></TT>
			being used once in a scalar context, to get its length, and once
			in a list context, to get its contents. Context is important. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-6-SECT-6"></A>6.6 Exercises</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-5#lperl3-APP-A-SECT-5">Section
			A.5</A> for answers to the following exercises: 
			</P>
			<OL>
				<LI><P>[7] Write a program that acts like <I>cat</I>, but
				reverses the order of the output lines. (Some systems have a
				utility like this named <I>tac</I>.) If you run yours as <TT><FONT COLOR="#cc0000">./tac
				fred barney betty</FONT></TT>, the output should be all of file
				<I>betty</I> from last line to first, then <I>barney</I> and then
				<I>fred</I>, also from last line to first. (Be sure to use the <TT><FONT COLOR="#cc0000">./</FONT></TT>
				in your program's invocation if you call it <I>tac</I>, so that
				you don't get the system's utility instead!) 
				</P>
				<LI><P>[8] Write a program that asks the user to enter a list of
				strings on separate lines, printing each string in a
				right-justified 20-character column. To be certain that the
				output is in the proper columns, print a &quot;ruler line&quot;
				of digits as well. (This is simply a debugging aid.) Make sure
				that you're not using a 19-character column by mistake! For
				example, entering <TT><FONT COLOR="#cc0000">hello</FONT></TT>,
				<TT><FONT COLOR="#cc0000">good-bye</FONT></TT> should give output
				something like this: 
				</P>
				<PRE STYLE="font-weight: medium"><FONT COLOR="#cc0000">123456789012345678901234567890123456789012345678901234567890</FONT>
<FONT COLOR="#cc0000">               hello</FONT>
<FONT COLOR="#cc0000">            good-bye</FONT></PRE>
				<LI><P><A NAME="IXTR3-46"></A><A NAME="IXTR3-47"></A>[8] Modify
				the previous program to let the user choose the column width, so
				that entering <TT><FONT COLOR="#cc0000">30</FONT></TT>, <TT><FONT COLOR="#cc0000">hello</FONT></TT>,
				<TT><FONT COLOR="#cc0000">good-bye</FONT></TT> (on separate
				lines) would put the strings at the 30th column. (Hint: see the
				section <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-2-SECT-6#lperl3-CHP-2-SECT-6.1">Section
				2.6.1</A> in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-2#lperl3-CHP-2">Chapter
				2</A> about controlling variable interpolation.) For extra
				credit, make the ruler line longer when the selected width is
				larger. 
				</P>
			</OL>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic10" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H2><A NAME="lperl3-CHP-7"></A>Chapter 7. Concepts of Regular
			Expressions</H2>
			<P><A NAME="lperl3-IDXTERM-491"></A>Perl has many features that
			set it apart from other languages. Of all those features, one of
			the most important is its strong support for regular expressions.
			These allow fast, flexible, and reliable string handling. 
			</P>
			<P>But that power comes at a price. Regular expressions are
			actually tiny programs in their own special language, built inside
			Perl. (Yes, you're about to learn another programming language!<A HREF="#">[1]</A>
			Fortunately it's a simple one.) So for the next two chapters,
			we'll be learning that language; then we'll take what we've
			learned back to the world of Perl in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-9#lperl3-CHP-9">Chapter
			9</A>. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP> Some
			might argue that regular expressions are not a complete
			programming language. We won't argue.</P>
			<P><A NAME="IXT-7-336152"></A>Regular expressions aren't merely
			part of Perl; they're also found in <I>sed</I> and <I>awk</I>,
			<I>procmail</I>, <I>grep</I>, most programmers' text editors like
			<I>vi</I> and <I>emacs</I>, and even in more esoteric places. If
			you've seen some of these already, you're ahead of the game. Keep
			watching, and you'll see many more tools that use or support
			regular expressions, such as search engines on the Web (often
			written in Perl), email clients, and others. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-7-SECT-1"></A>7.1 What Are Regular
			Expressions?</H3>
			<P><A NAME="IXT-7-336153"></A><A NAME="IXT-7-336154"></A>A <I>regular
			expression</I>, often called a <I>pattern</I> in Perl, is a
			template that either matches or doesn't match a given string.<A HREF="#">[2]</A>
			That is, there are an infinite number of possible text strings; a
			given pattern divides that infinite set into two groups: the ones
			that match, and the ones that don't. There's never any
			kinda-sorta-almost-up-to-here wishy-washy matching: either it
			matches or it doesn't. A pattern may match just one possible
			string, or just two or three, or a dozen, or a hundred, or an
			infinite number. Or it may match all strings except for one, or
			except for some, or except for an infinite number.<A HREF="#">[3]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP>
			Purists would ask for a more rigorous definition. But then again,
			purists say that Perl's patterns aren't really regular
			expressions. If you're serious about regular expressions, we
			highly recommend the book Mastering Regular Expressions by Jeffrey
			Friedl (O'Reilly &amp; Associates, Inc.).</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP> And
			as we'll see, you could have a pattern that always matches or that
			never does. In rare cases, even these may be useful. Generally,
			though, they're mistakes.</P>
			<P>We already referred to regular expressions as being little
			programs in their own simple programming language. It's a simple
			language because the programs have just one task: to look at a
			string and say &quot;it matches&quot; or &quot;it doesn't
			match&quot;.<A HREF="#">[4]</A> That's all they do. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP> The
			programs also pass back some information that Perl can use later.
			One such piece of information is the &quot;regular expressions
			memories&quot; that we'll learn about a little later.</P>
			<P><A NAME="IXT-7-336155"></A><A NAME="IXT-7-336156"></A>One of
			the places you're likely to have seen regular expressions is in
			the Unix <I>grep</I> command, which prints out text lines matching
			a given pattern. For example, if you wanted to see which lines in
			a given file mention <TT><FONT COLOR="#cc0000">flint</FONT></TT>
			and, somewhere later on the same line, <TT><FONT COLOR="#cc0000">stone</FONT></TT>,
			you might do something like this, with the Unix <I>grep</I>
			command: 
			</P>
			<PRE><FONT COLOR="#cc0000">$ <B>grep 'flint.*stone' some_file</B></FONT>
<FONT COLOR="#cc0000">a piece of flint, a stone which may be used to start a fire by striking</FONT>
<FONT COLOR="#cc0000">found obsidian, flint, granite, and small stones of basaltic rock, which</FONT>
<FONT COLOR="#cc0000">a flintlock rifle in poor condition. The sandstone mantle held several</FONT></PRE><P>
			Now, if you've used regular expressions somewhere else, that's
			good, because you have a head start on these three chapters. But
			Perl's regular expressions have somewhat different syntax than
			most other implementations; in fact, everybody's regular
			expressions are a little different. So, if you needed to use a
			backslash to do something in another implementation, maybe you'll
			need to leave it off in Perl, or maybe vice versa. 
			</P>
			<P><A NAME="IXT-7-336157"></A><A NAME="IXT-7-336158"></A>Don't
			confuse regular expressions with shell filename-matching patterns,
			called <I>globs</I>. A typical glob is what you use when you type
			<TT><FONT COLOR="#cc0000">*.pm</FONT></TT> to the Unix shell to
			match all filenames that end in <TT><FONT COLOR="#cc0000">.pm</FONT></TT>.
			Globs use a lot of the same characters that we use in regular
			expressions, but those characters are used in totally different
			ways.<A HREF="#">[5]</A> We'll visit globs later, in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-12#lperl3-CHP-12">Chapter
			12</A>, but for now try to put them totally out of your mind. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[5]</SUP>
			Globs are also (alas) sometimes called patterns. What's worse,
			though, is that some bad Unix books for beginners (and possibly
			written by beginners) have taken to calling globs &quot;regular
			expressions&quot;, which they certainly are not. This confuses
			many folks at the start of their work with Unix.</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-7-SECT-2"></A>7.2 Using Simple Patterns</H3>
			<P><A NAME="lperl3-IDXTERM-499"></A><A NAME="IXT-7-336159"></A><A NAME="IXT-7-336160"></A>
			To compare a pattern (regular expression) to the contents of <TT><FONT COLOR="#cc0000">$_</FONT></TT>,
			simply put the pattern between a pair of forward slashes (<TT><FONT COLOR="#cc0000">/</FONT></TT>),
			like we do here: 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;yabba dabba doo&quot;;</FONT>
<FONT COLOR="#cc0000">if (/abba/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;It matched!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The expression <TT><FONT COLOR="#cc0000">/abba/</FONT></TT> looks
			for that four-letter string in <TT><FONT COLOR="#cc0000">$_</FONT></TT>;
			if it finds it, it returns a true value. In this case, it's found
			more than once, but that doesn't make any difference. If it's
			found at all, it's a match; if it's not in there at all, it fails.
			
			</P>
			<P>Because the pattern match is generally being used to return a
			true or false value, it is almost always found in the conditional
			expression of <TT><FONT COLOR="#cc0000">if</FONT></TT> or <TT><FONT COLOR="#cc0000">while</FONT></TT>.
			
			</P>
			<P>All of the usual backslash escapes that you can put into
			double-quoted strings are available in patterns, so you could use
			the pattern <TT><FONT COLOR="#cc0000">/coke\tsprite/</FONT></TT>
			to match the eleven characters of <TT><FONT COLOR="#cc0000">coke</FONT></TT>,
			a tab, and <TT><FONT COLOR="#cc0000">sprite</FONT></TT>. 
			</P>
			<H4><A NAME="lperl3-CHP-7-SECT-2.1"></A>7.2.1 About Metacharacters</H4>
			<P><A NAME="IXT-7-336161"></A>Of course, if patterns matched only
			simple literal strings, they wouldn't be very useful. That's why
			there are a number of special characters, called <I>metacharacters</I>,
			that have special meanings in regular expressions. 
			</P>
			<P><A NAME="IXT-7-336162"></A><A NAME="IXT-7-336163"></A><A NAME="IXT-7-336164"></A><A NAME="IXT-7-336165"></A>
			For example, the dot (<TT><FONT COLOR="#cc0000">.</FONT></TT>) is
			a wildcard character&iuml;&frac34;—it matches any single
			character except a newline (which is represented by <TT><FONT COLOR="#cc0000">&quot;\n&quot;</FONT></TT>).
			So, the pattern <TT><FONT COLOR="#cc0000">/bet.y/</FONT></TT>
			would match <TT><FONT COLOR="#cc0000">betty</FONT></TT>. Or it
			would match <TT><FONT COLOR="#cc0000">betsy</FONT></TT>, or <TT><FONT COLOR="#cc0000">bet=y</FONT></TT>,
			or <TT><FONT COLOR="#cc0000">bet.y</FONT></TT>, or any other
			string that has <TT><FONT COLOR="#cc0000">bet</FONT></TT>,
			followed by any one character (except a newline), followed by <TT><FONT COLOR="#cc0000">y</FONT></TT>.
			It wouldn't match <TT><FONT COLOR="#cc0000">bety</FONT></TT> or
			<TT><FONT COLOR="#cc0000">betsey</FONT></TT>, though, since those
			don't have exactly one character between the <TT><FONT COLOR="#cc0000">t</FONT></TT>
			and the <TT><FONT COLOR="#cc0000">y</FONT></TT>. The dot always
			matches exactly one character. 
			</P>
			<P>So, if you wanted to match a period in the string, you could
			use the dot. But that would match any possible character (except a
			newline), which might be more than you wanted. If you wanted the
			dot to match just a period, you can simply backslash it. In fact,
			that rule goes for all of Perl's regular expression
			metacharacters: a backslash in front of any metacharacter makes it
			nonspecial. So, the pattern <TT><FONT COLOR="#cc0000">/3\.14159/</FONT></TT>
			doesn't have a wildcard character. 
			</P>
			<P>So the backslash is our second metacharacter. If you mean a
			real backslash, just use a pair of them&iuml;&frac34;—a rule
			that applies just as well everywhere else in Perl. 
			</P>
			<H4><A NAME="lperl3-CHP-7-SECT-2.2"></A>7.2.2 Simple Quantifiers</H4>
			<P><A NAME="IXT-7-336166"></A><A NAME="IXT-7-336167"></A>It often
			happens that you'll need to repeat something in a pattern. The
			star (<TT><FONT COLOR="#cc0000">*</FONT></TT>) means to match the
			preceding item zero or more times. So, <TT><FONT COLOR="#cc0000">/fred\t*barney/</FONT></TT>
			matches any number of tab characters between <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">barney</FONT></TT>. That is, it
			matches <TT><FONT COLOR="#cc0000">&quot;fred\tbarney&quot;</FONT></TT>
			with one tab, or <TT><FONT COLOR="#cc0000">&quot;fred\t\tbarney&quot;</FONT></TT>
			with two tabs, or <TT><FONT COLOR="#cc0000">&quot;fred\t\t\tbarney&quot;</FONT></TT>
			with three tabs, or even <TT><FONT COLOR="#cc0000">&quot;fredbarney&quot;</FONT></TT>
			with nothing in between at all. That's because the star means
			&quot;zero or more&quot;&iuml;&frac34;—so you could even have
			hundreds of tab characters in between, but nothing other than
			tabs. You may find it helpful to think of star as saying, &quot;that
			previous thing, any number of times, even zero times.&quot; 
			</P>
			<P>What if you wanted to allow something besides tab characters?
			The dot matches any character<A HREF="#">[6]</A>, so <TT><FONT COLOR="#cc0000">.*</FONT></TT>
			will match any character, any number of times. That means that the
			pattern <TT><FONT COLOR="#cc0000">/fred.*barney/</FONT></TT>
			matches &quot;any old junk&quot; between <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">barney</FONT></TT>. Any line that
			mentions <TT><FONT COLOR="#cc0000">fred</FONT></TT> and (somewhere
			later) <TT><FONT COLOR="#cc0000">barney</FONT></TT> will match
			that pattern. We often call <TT><FONT COLOR="#cc0000">.*</FONT></TT>
			the &quot;any old junk&quot; pattern, because it can match any old
			junk in your strings. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP>
			Except newline. But we're going to stop reminding you of that so
			often, because you know it by now. Most of the time it doesn't
			matter, anyway, because your strings will most-often not have
			newlines. But don't forget this detail, because someday a newline
			will sneak into your string and you'll need to remember that the
			dot doesn't match newline.</P>
			<P><A NAME="IXT-7-336168"></A><A NAME="IXT-7-336169"></A><A NAME="IXT-7-336170"></A>
			The star is formally called a <I>quantifier</I>, meaning that it
			specifies a quantity of the preceding item. But it's not the only
			quantifier; the plus (&quot;<TT><FONT COLOR="#cc0000">+</FONT></TT>&quot;)
			is another. The plus means to match the preceding item one or more
			times: <TT><FONT COLOR="#cc0000">/fred +barney/</FONT></TT>
			matches if <TT><FONT COLOR="#cc0000">fred</FONT></TT> and <TT><FONT COLOR="#cc0000">barney</FONT></TT>
			are separated by spaces and only spaces. (The space is not a
			metacharacter.) This won't match <TT><FONT COLOR="#cc0000">fredbarney</FONT></TT>,
			since the plus means that there must be one or more spaces between
			the two names, so at least one space is required. It may be
			helpful to think of the plus as saying, &quot;that last thing,
			plus any number more of the same thing.&quot; 
			</P>
			<P><A NAME="IXT-7-336171"></A><A NAME="IXT-7-336172"></A>There's a
			third quantifier like the star and plus, but more limited. It's
			the question mark (&quot;<TT><FONT COLOR="#cc0000">?</FONT></TT>&quot;),
			which means that the preceding item is optional. That is, the
			preceding item may occur once or not at all. Like the other two
			quantifiers, the question mark means that the preceding item
			appears a certain number of times. It's just that in this case the
			item may match one time (if it's there) or zero times (if it's
			not). There aren't any other possibilities. So, <TT><FONT COLOR="#cc0000">/bamm-?bamm/</FONT></TT>
			matches either spelling: <TT><FONT COLOR="#cc0000">bamm-bamm</FONT></TT>
			or <TT><FONT COLOR="#cc0000">bammbamm</FONT></TT>. This is easy to
			remember, since it's saying &quot;that last thing, maybe? Or maybe
			not?&quot; 
			</P>
			<P>All three of these quantifiers must follow something, since
			they tell how many times the previous item may repeat. 
			</P>
			<H4><A NAME="lperl3-CHP-7-SECT-2.3"></A>7.2.3 Grouping in Patterns</H4>
			<P><A NAME="IXT-7-336173"></A>As in mathematics, parentheses (&quot;<TT><FONT COLOR="#cc0000">(
			)</FONT></TT>&quot;) may be used for grouping. So, parentheses are
			also metacharacters. As an example, the pattern <TT><FONT COLOR="#cc0000">/fred+/</FONT></TT>
			matches strings like <TT><FONT COLOR="#cc0000">freddddddddd</FONT></TT>,
			but strings like that don't show up often in real life. But the
			pattern <TT><FONT COLOR="#cc0000">/(fred)+/</FONT></TT> matches
			strings like <TT><FONT COLOR="#cc0000">fredfredfred</FONT></TT>,
			which is more likely to be what you wanted. And what about the
			pattern <TT><FONT COLOR="#cc0000">/(fred)*/</FONT></TT>? That
			matches strings like <TT><FONT COLOR="#cc0000">hello, world</FONT></TT>.<A HREF="#">[7]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP> The
			star means to match zero or more repetitions of <TT><FONT COLOR="#cc0000">fred</FONT></TT>.
			When you're willing to settle for zero, it's hard to be
			disappointed! That pattern will match any string, even the empty
			string.</P>
			<H4><A NAME="lperl3-CHP-7-SECT-2.4"></A>7.2.4 Alternatives</H4>
			<P><A NAME="IXT-7-336174"></A><A NAME="IXT-7-336175"></A>The
			vertical bar (<TT><FONT COLOR="#cc0000">|</FONT></TT>), often
			pronounced &quot;or&quot; in this usage, means that either the
			left side may match, or the right side. That is, if the part of
			the pattern on the left of the bar fails, the part on the right
			gets a chance to match. So, <TT><FONT COLOR="#cc0000">/fred|barney|betty/</FONT></TT>
			will match any string that mentions <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
			or <TT><FONT COLOR="#cc0000">barney</FONT></TT>, or <TT><FONT COLOR="#cc0000">betty</FONT></TT>.
			
			</P>
			<P>Now we can make patterns like <TT><FONT COLOR="#cc0000">/fred(
			|\t)+barney/</FONT></TT>, which matches if <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">barney</FONT></TT> are separated by
			spaces, tabs, or a mixture of the two. The plus means to repeat
			one or more times; each time it repeats, the <TT><FONT COLOR="#cc0000">(
			|\t)</FONT></TT> has the chance to match either a space or a
			tab.<A HREF="#">[8]</A> There must be at least one character
			between the two names. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> This
			particular match would normally be done more efficiently with a
			character class, as we'll see in the next chapter.</P>
			<P>If you wanted the characters between <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">barney</FONT></TT> to all be the
			same, you could rewrite that pattern as <TT><FONT COLOR="#cc0000">/fred(
			+|\t+)barney/</FONT></TT>. In this case, the separators must be
			all spaces, or all tabs. 
			</P>
			<P>The pattern <TT><FONT COLOR="#cc0000">/fred (and|or) barney/</FONT></TT>
			matches any string containing either of the two possible strings:
			<TT><FONT COLOR="#cc0000">fred and barney</FONT></TT>, or <TT><FONT COLOR="#cc0000">fred
			or barney</FONT></TT>.<A HREF="#">[9]</A> We could match the same
			two strings with the pattern <TT><FONT COLOR="#cc0000">/fred and
			barney|fred or</FONT></TT> <TT><FONT COLOR="#cc0000">barney/</FONT></TT>,
			but that would be too much typing. It would probably also be less
			efficient, depending upon what optimizations are built into the
			regular expression engine. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP> Note
			that the words <TT><FONT COLOR="#cc0000">and</FONT></TT> and <TT><FONT COLOR="#cc0000">or</FONT></TT>
			are not operators in regular expressions! They are shown here in a
			fixed-width typeface because they're part of the strings.</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-7-SECT-3"></A>7.3 A Pattern Test Program</H3>
			<P><A NAME="IXT-7-336176"></A>When in the course of Perl events it
			becomes necessary for a programmer to write a regular expression,
			it may be difficult to tell just what the pattern will do. It's
			normal to find that a pattern matches more than you expected, or
			less. Or it may match earlier in the string than you expected, or
			later, or not at all. 
			</P>
			<P>This program is useful to test out a pattern on some strings
			and see just what it matches, and where: 
			</P>
			<PRE><FONT COLOR="#cc0000">#!/usr/bin/perl</FONT>
<FONT COLOR="#cc0000">while (&lt;&gt;) {                        # take one input line at a time</FONT>
<FONT COLOR="#cc0000">  chomp;</FONT>
<FONT COLOR="#cc0000">  if (/YOUR_PATTERN_GOES_HERE/) {</FONT>
<FONT COLOR="#cc0000">    print &quot;Matched: |$`&lt;$&amp;&gt;$'|\n&quot;;  # Mystery code! See the text.</FONT>
<FONT COLOR="#cc0000">  } else {</FONT>
<FONT COLOR="#cc0000">    print &quot;No match.\n&quot;;</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-7-336177"></A><A NAME="IXT-7-336178"></A><A NAME="IXTR3-48"></A><A NAME="IXTR3-49"></A>
			This pattern test program is written for programmers to use, not
			endusers; you can tell because it doesn't have any prompts or
			usage information. It will take any number of input lines and
			check each one against the pattern that you'll put in place of the
			string saying <TT><FONT COLOR="#cc0000">YOUR_PATTERN_GOES_HERE</FONT></TT>.
			For each line that matches, the line with &quot;mystery code&quot;
			will be run. We'll learn about what that line is really doing in
			<A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-9#lperl3-CHP-9">Chapter
			9</A>. But what you'll see is this: if the pattern is <TT><FONT COLOR="#cc0000">/match/</FONT></TT>
			and the input is <TT><FONT COLOR="#cc0000">beforematchafter</FONT></TT>,
			the output will say &quot;<TT><FONT COLOR="#cc0000">|before&lt;match&gt;after|</FONT></TT>&quot;,
			using angle brackets to show you just what part of the string was
			matched by your pattern. Try it and see! If you pattern matches
			something you didn't expect, you'll be able to see that right
			away. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic11" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-7-SECT-4"></A>7.4 Exercises</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-6#lperl3-APP-A-SECT-6">Section
			A.6</A> for answers to the following exercises: 
			</P>
			<P>Remember, it's normal to be surprised by some of the things
			that regular expressions do; that's one reason that the exercises
			in this chapter are even more important than the others. Expect
			the unexpected. 
			</P>
			<P><A NAME="IXT-7-336179"></A>Several of these exercises ask you
			to use the test program from this chapter. You could manually type
			up this program, taking great care to get all of the odd
			punctuation marks correct.<A HREF="#">[10]</A> But you'll probably
			find it faster and easier to simply download the program and some
			other goodies from the O'Reilly website, as we mentioned in the
			Preface. You'll find this program under the name <I>pattern_test</I>.<A HREF="#">[11]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[10]</SUP> If
			you do type it up on your own, remember that the backtick
			character (<TT><FONT COLOR="#cc0000">`</FONT></TT>) is not the
			same as the apostrophe (<TT><FONT COLOR="#cc0000">'</FONT></TT>).
			On most full-sized computer keyboards these days (in the U.S., at
			least), the backtick is found on a key immediately to the left of
			the <TT><FONT COLOR="#cc0000">1</FONT></TT> key. Try out the
			program with the pattern <TT><FONT COLOR="#cc0000">/match/</FONT></TT>and
			the string <TT><FONT COLOR="#cc0000">beforematchafter</FONT></TT>,
			as the text describes, and see that it works correctly before you
			do the exercises.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP>
			Don't be surprised if the program you download is a little fancier
			than what we have in the book. The commented-out extra features
			you see will come in handy in later exercises.</P>
			<OL>
				<LI><P>[6] Use the test program to make and test a pattern that
				matches any string containing <TT><FONT COLOR="#cc0000">fred</FONT></TT>.
				Does it match if your string is <TT><FONT COLOR="#cc0000">Fred</FONT></TT>,
				<TT><FONT COLOR="#cc0000">frederick</FONT></TT>, or <TT><FONT COLOR="#cc0000">Alfred</FONT></TT>?
				
				</P>
				<LI><P>[6] Use the test program to make and test a pattern that
				matches any string containing at least one <TT><FONT COLOR="#cc0000">a</FONT></TT>
				followed by any number of <TT><FONT COLOR="#cc0000">b</FONT></TT>'s.
				Remember that &quot;any number&quot; might be zero. Does it match
				if your string is <TT><FONT COLOR="#cc0000">barney</FONT></TT>,
				<TT><FONT COLOR="#cc0000">fred</FONT></TT>, <TT><FONT COLOR="#cc0000">abba</FONT></TT>,
				or <TT><FONT COLOR="#cc0000">dinosaur</FONT></TT>? 
				</P>
				<LI><P>[5] Use the test program to make and test a pattern that
				matches any string containing any number of backslashes followed
				by any number of asterisks. Does it match if your string is <TT><FONT COLOR="#cc0000">\\**</FONT></TT>,
				<TT><FONT COLOR="#cc0000">fred</FONT></TT>, <TT><FONT COLOR="#cc0000">barney
				\\\***</FONT></TT>, or <TT><FONT COLOR="#cc0000">*wilma\</FONT></TT>?
				(Note the typography; those are four separate test strings.) 
				</P>
				<LI><P>[6] Write a new program (not the test program) that prints
				out any input line that mentions <TT><FONT COLOR="#cc0000">wilma</FONT></TT>.
				(Any other lines should simply be skipped.) For extra credit,
				allow it to match <TT><FONT COLOR="#cc0000">Wilma</FONT></TT>
				with a capital <TT><FONT COLOR="#cc0000">W</FONT></TT> as well. 
				</P>
				<LI><P>[8] Extra credit exercise: write a program that prints out
				any input line that mentions both <TT><FONT COLOR="#cc0000">wilma</FONT></TT>
				and <TT><FONT COLOR="#cc0000">fred</FONT></TT>. 
				</P>
			</OL>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H2><A NAME="lperl3-CHP-8"></A>Chapter 8. More About Regular
			Expressions</H2>
			<P>In the previous chapter, we saw the beginnings of what regular
			expressions can do. Here we'll see some of their other common
			features. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic12" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-8-SECT-1"></A>8.1 Character Classes</H3>
			<P><A NAME="lperl3-IDXTERM-523"></A><A NAME="IXT-8-336180"></A><A NAME="IXT-8-336181"></A>
			A <I>character class</I>, a list of possible characters inside
			square brackets (<TT><FONT COLOR="#cc0000">[]</FONT></TT>),
			matches any single character from within the class. It matches
			just one single character, but that one character may be any of
			the ones listed. 
			</P>
			<P><A NAME="IXT-8-336182"></A><A NAME="IXT-8-336183"></A>For
			example, the character class <TT><FONT COLOR="#cc0000">[abcwxyz]</FONT></TT>
			may match any one of those seven characters. For convenience, you
			may specify a range of characters with a hyphen (<TT><FONT COLOR="#cc0000">-</FONT></TT>),
			so that class may also be written as <TT><FONT COLOR="#cc0000">[a-cw-z]</FONT></TT>.
			That didn't save much typing, but it's more usual to make a
			character class like <TT><FONT COLOR="#cc0000">[a-zA-Z]</FONT></TT>,
			to match any one letter out of that set of 52.<A HREF="#">[1]</A>
			You may use the same character shortcuts as in any double-quotish
			string to define a character, so the class <TT><FONT COLOR="#cc0000">[\000-\177]</FONT></TT>
			matches any seven-bit ASCII character.<A HREF="#">[2]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP>
			Notice that those 52 don't include letters like &Aring; and &Eacute;
			and &Icirc; and &Oslash; and &Uuml;. But when Unicode processing
			is available, that particular character range is noticed and
			enhanced to automatically do the right thing.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> At
			least, if you use ASCII and not EBCDIC.</P>
			<P>Of course, a character class will be just part of a full
			pattern; it will never stand on its own in Perl. For example, you
			might see code that says something like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;The HAL-9000 requires authorization to continue.&quot;;</FONT>
<FONT COLOR="#cc0000">if (/HAL-[0-9]+/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The string mentions some model of HAL computer.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Sometimes, it's easier to specify the characters left out, rather
			than the ones within the character class. A caret (&quot;<TT><FONT COLOR="#cc0000">^</FONT></TT>&quot;)
			at the start of the character class negates it. That is, <TT><FONT COLOR="#cc0000">[^def]</FONT></TT>
			will match any single character except one of those three. And
			<TT><FONT COLOR="#cc0000">[^n\-z]</FONT></TT> matches any
			character except for <TT><FONT COLOR="#cc0000">n</FONT></TT>,
			hyphen, or <TT><FONT COLOR="#cc0000">z</FONT></TT>. (Note that the
			hyphen is backslashed, because it's special inside a character
			class. But the first hyphen in <TT><FONT COLOR="#cc0000">/HAL-[0-9]+/</FONT></TT>
			doesn't need a backslash, because hyphens aren't special outside a
			character class.) 
			</P>
			<H4><A NAME="lperl3-CHP-8-SECT-1.1"></A>8.1.1 Character Class
			Shortcuts</H4>
			<P><A NAME="IXT-8-336184"></A><A NAME="IXT-8-336185"></A><A NAME="IXT-8-336186"></A>
			Some character classes appear so frequently that they have
			shortcuts. For example, the character class for any digit, <TT><FONT COLOR="#cc0000">[0-9]</FONT></TT>,
			may be abbreviated as <TT><FONT COLOR="#cc0000">\d</FONT></TT> .
			Thus, the pattern from the example about HAL could be written
			<TT><FONT COLOR="#cc0000">/HAL-\d+/</FONT></TT> instead. 
			</P>
			<P><A NAME="IXT-8-336187"></A><A NAME="IXT-8-336188"></A>The
			shortcut <TT><FONT COLOR="#cc0000">\w</FONT></TT> is a so-called
			&quot;word&quot; character: <TT><FONT COLOR="#cc0000">[A-Za-z0-9_]</FONT></TT>.
			If your &quot;words&quot; are made up of ordinary letters, digits,
			and underscores, you'll be happy with this. Most of the rest of us
			have words made up of ordinary letters, hyphens, and
			apostrophes,<A HREF="#">[3]</A> and we'd like to change this. As
			of this writing, the Perl developers are working on it, but it's
			not available yet.<A HREF="#">[4]</A> So use this one only when
			you want ordinary letters, digits, and underscores. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP> At
			least, in usual English we do. In other languages, you may have
			different components of words. And when looking at ASCII-encoded
			English text, we have the problem that the single quote and the
			apostrophe are the same character, so it's not possible in
			isolation to tell whether <TT><FONT COLOR="#cc0000">cats'</FONT></TT>
			is a word with an apostrophe or a word at the end of a quotation.
			This is probably one reason that computers haven't been able to
			take over the world yet.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP>
			Except to a limited (but nevertheless useful) extent in connection
			with locales; see the perllocale manpage.</P>
			<P>Of course, <TT><FONT COLOR="#cc0000">\w</FONT></TT> doesn't
			match a &quot;word&quot;; it merely matches a single &quot;word&quot;
			character. To match an entire word, though, the plus modifier is
			handy. A pattern like <TT><FONT COLOR="#cc0000">/fred \w+ barney/</FONT></TT>
			will match <TT><FONT COLOR="#cc0000">fred</FONT></TT> and a space,
			then a &quot;word&quot;, then a space and <TT><FONT COLOR="#cc0000">barney</FONT></TT>.
			That is, it'll match if there's one word<A HREF="#">[5]</A>
			between <TT><FONT COLOR="#cc0000">fred</FONT></TT> and <TT><FONT COLOR="#cc0000">barney</FONT></TT>,
			set off by single spaces. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[5]</SUP>
			We're going to stop saying &quot;word&quot; in quotes so much; you
			know by now that these letter-digit-underscore words are the ones
			we mean.</P>
			<P><A NAME="IXT-8-336189"></A><A NAME="IXT-8-336190"></A><A NAME="IXT-8-336191"></A><A NAME="IXT-8-336192"></A>
			As you may have noticed in that previous example, it might be
			handy to be able to match spaces more flexibly. The <TT><FONT COLOR="#cc0000">\s</FONT></TT>
			shortcut is good for whitespace; it's the same as <TT><FONT COLOR="#cc0000">[\f\t\n\r
			]</FONT></TT>. That is, it's the same as a class containing the
			five whitespace characters form-feed, tab, newline, carriage
			return, and the space character itself. These are the characters
			that merely move the printing position around; they don't use any
			ink. Still, like the other shortcuts we've just seen, <TT><FONT COLOR="#cc0000">\s</FONT></TT>
			matches just a single character from the class, so it's usual to
			use either <TT><FONT COLOR="#cc0000">\s*</FONT></TT> for any
			amount of whitespace (including none at all), or <TT><FONT COLOR="#cc0000">\s+</FONT></TT>
			for one or more whitespace characters. (In fact, it's rare to see
			<TT><FONT COLOR="#cc0000">\s</FONT></TT> without one of those
			quantifiers.) Since all of those whitespace characters look about
			the same to us humans, we can treat them all in the same way with
			this shortcut. 
			</P>
			<H4><A NAME="lperl3-CHP-8-SECT-1.2"></A>8.1.2 Negating the
			Shortcuts</H4>
			<P><A NAME="IXT-8-336193"></A><A NAME="IXT-8-336194"></A><A NAME="IXT-8-336195"></A><A NAME="IXT-8-336196"></A><A NAME="IXT-8-336197"></A>
			Sometimes you may want the opposite of one of these three
			shortcuts. That is, you may want <TT><FONT COLOR="#cc0000">[^\d]</FONT></TT>,
			<TT><FONT COLOR="#cc0000">[^\w]</FONT></TT>, or <TT><FONT COLOR="#cc0000">[^\s]</FONT></TT>,
			meaning a nondigit character, a nonword character, or a
			nonwhitespace character. That's easy enough to accomplish by using
			their uppercase counterparts: <TT><FONT COLOR="#cc0000">\D</FONT></TT>,
			<TT><FONT COLOR="#cc0000">\W</FONT></TT>, or <TT><FONT COLOR="#cc0000">\S</FONT></TT>.
			These match any character that their counterpart would not match. 
			</P>
			<P>Any of these shortcuts will work either in place of a character
			class (standing on their own in a pattern), or inside the square
			brackets of a larger character class. That means that you could
			now use <TT><FONT COLOR="#cc0000">/[\dA-Fa-f]+/</FONT></TT> to
			match hexadecimal (base 16) numbers, which use letters <TT><FONT COLOR="#cc0000">ABCDEF</FONT></TT>
			(or the same letters in lowercase) as additional digits. 
			</P>
			<P><A NAME="IXTR3-50"></A>Another compound character class is
			<TT><FONT COLOR="#cc0000">[\d\D]</FONT></TT>, which means any
			digit, or any non-digit. That is to say, any character at all!
			This is a common way to match any character, even a newline. (As
			opposed to <TT><FONT COLOR="#cc0000">.</FONT></TT>, which matches
			any character except a newline.) And then there's the totally
			useless <TT><FONT COLOR="#cc0000">[^\d\D]</FONT></TT>, which
			matches anything that's not either a digit or a non-digit.
			Right&iuml;&frac34;—nothing! 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic13" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-8-SECT-2"></A>8.2 General Quantifiers</H3>
			<P><A NAME="IXT-8-336198"></A><A NAME="IXT-8-336199"></A><A NAME="IXT-8-336200"></A>
			A <I>quantifier</I> in a pattern means to repeat the preceding
			item a certain number of times. We've already seen three
			quantifiers: <TT><FONT COLOR="#cc0000">*</FONT></TT>, <TT><FONT COLOR="#cc0000">+</FONT></TT>,
			and <TT><FONT COLOR="#cc0000">?</FONT></TT>. But if none of those
			three suits your needs, just use a comma-separated pair of numbers
			inside curly braces (<TT><FONT COLOR="#cc0000">{}</FONT></TT>) to
			specify exactly how few and how many repetitions are allowed. 
			</P>
			<P>So the pattern <TT><FONT COLOR="#cc0000">/a{5,15}/</FONT></TT>
			will match from five to fifteen repetitions of the letter <TT><FONT COLOR="#cc0000">a</FONT></TT>.
			If the <TT><FONT COLOR="#cc0000">a</FONT></TT> appears three
			times, that's too few, so it won't match. If it appears five
			times, it's a match. If it appears ten times, that's still a
			match. If it appears twenty times, just the first fifteen will
			match, since that's the upper limit. 
			</P>
			<P>If you omit the second number (but include the comma), there's
			no upper limit to the number of times the item will match. So,
			<TT><FONT COLOR="#cc0000">/(fred){3,}/</FONT></TT> will match if
			there are three or more instances of <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			in a row (with no extra characters, like spaces, allowed between
			each <TT><FONT COLOR="#cc0000">fred</FONT></TT> and the next).
			There's no upper limit, so that would match eighty-eight instances
			of <TT><FONT COLOR="#cc0000">fred</FONT></TT>, if you had a string
			with that many. 
			</P>
			<P>If you omit the comma as well as the upper bound, the number
			given is an exact count: <TT><FONT COLOR="#cc0000">/\w{8}/</FONT></TT>
			will match exactly eight word characters (occuring as part of a
			larger string, perhaps). 
			</P>
			<P>In fact, the three quantifier characters that we saw earlier
			are just common shortcuts. The star is the same as the quantifier
			<TT><FONT COLOR="#cc0000">{0,}</FONT></TT>, meaning zero or more.
			The plus is the same as <TT><FONT COLOR="#cc0000">{1,}</FONT></TT>,
			meaning one or more. And the question mark could be written as
			<TT><FONT COLOR="#cc0000">{0,1}</FONT></TT>. In practice, it's
			unusual to need any curly-brace quantifiers, since the three
			shortcut characters are nearly always the only ones needed. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic14" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-8-SECT-3"></A>8.3 Anchors</H3>
			<P><A NAME="IXT-8-336201"></A>By default, if a pattern doesn't
			match at the start of the string, it can &quot;float&quot; on down
			the string, trying to match somewhere else. But there are a number
			of anchors that may be used to hold the pattern at a particular
			point in a string. 
			</P>
			<P><A NAME="IXT-8-336202"></A><A NAME="IXT-8-336203"></A><A NAME="IXT-8-336204"></A>
			The caret<A HREF="#">[6]</A> anchor (<TT><FONT COLOR="#cc0000">^</FONT></TT>)
			marks the beginning of the string, while the dollar sign (<TT><FONT COLOR="#cc0000">$</FONT></TT>)
			marks the end.<A HREF="#">[7]</A> So the pattern <TT><FONT COLOR="#cc0000">/^fred/</FONT></TT>
			will match <TT><FONT COLOR="#cc0000">fred</FONT></TT> only at the
			start of the string; it wouldn't match <TT><FONT COLOR="#cc0000">manfred
			mann</FONT></TT>. And <TT><FONT COLOR="#cc0000">/rock$/</FONT></TT>
			will match <TT><FONT COLOR="#cc0000">rock</FONT></TT> only at the
			end of the string; it wouldn't match <TT><FONT COLOR="#cc0000">knute
			rockne</FONT></TT>. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP> Yes,
			you've seen that caret is already used in another way in patterns.
			As the first character of a character class, it negates the class.
			But outside of a character class, it's a metacharacter in a
			different way, being the start-of-string anchor. There are only so
			many characters, so we have to use some of them twice.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP>
			Actually, it matches either the end of the string, or at a newline
			at the end of the string. That's so that you can match the end of
			the string whether it has a trailing newline or not. Most folks
			don't worry about this distinction much, but once in a long while
			it's important to remember that <TT><FONT COLOR="#cc0000">/^fred$/</FONT></TT>will
			match either <TT><FONT COLOR="#cc0000">&quot;fred&quot;</FONT></TT>
			or <TT><FONT COLOR="#cc0000">&quot;fred\n&quot;</FONT></TT> with
			equal ease.</P>
			<P>Sometimes, you'll want to use both of these anchors, to ensure
			that the pattern matches an entire string. A common example is
			<TT><FONT COLOR="#cc0000">/^\s*$/</FONT></TT>, which matches a
			blank line. But this &quot;blank&quot; line may include some
			whitespace characters, like tabs and spaces, which are invisible
			to you and me. Any line that matches that pattern looks just like
			any other one on paper, so this pattern treats all blank lines as
			equivalent. Without the anchors, it would match nonblank lines as
			well. 
			</P>
			<H4><A NAME="lperl3-CHP-8-SECT-3.1"></A>8.3.1 Word Anchors</H4>
			<P><A NAME="IXT-8-336205"></A><A NAME="IXT-8-336206"></A>Anchors
			aren't just at the ends of the string. The word-boundary anchor,
			<TT><FONT COLOR="#cc0000">\b</FONT></TT>, matches at either end of
			a word.<A HREF="#">[8]</A> So we can use <TT><FONT COLOR="#cc0000">/\bfred\b/</FONT></TT>
			to match the word <TT><FONT COLOR="#cc0000">fred</FONT></TT> but
			not <TT><FONT COLOR="#cc0000">frederick</FONT></TT> or <TT><FONT COLOR="#cc0000">alfred</FONT></TT>
			or <TT><FONT COLOR="#cc0000">manfred mann</FONT></TT>. This is
			similar to the feature often called something like &quot;match
			whole words only&quot; in a word processor's search command. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> Some
			regular expression implementations have one anchor for
			start-of-word and another for end-of-word, but Perl uses <TT><FONT COLOR="#cc0000">\b</FONT></TT>
			for both.</P>
			<P><A NAME="IXT-8-336207"></A>Alas, these aren't words as you and
			I are likely to think of them; they're those <TT><FONT COLOR="#cc0000">\w</FONT></TT>-type
			words made up of ordinary letters, digits, and underscores. The <TT><FONT COLOR="#cc0000">\b</FONT></TT>
			anchor matches at the start or end of a group of <TT><FONT COLOR="#cc0000">\w</FONT></TT>
			characters. 
			</P>
			<P>In <A HREF="#lperl3-CHP-8-FIG-1">Figure 8-1</A>, there's a grey
			underline under each &quot;word,&quot; and the arrows show the
			corresponding places where <TT><FONT COLOR="#cc0000">\b</FONT></TT>
			could match. There are always an even number of word boundaries in
			a given string, since there's an end-of-word for every
			start-of-word. 
			</P>
			<P>The &quot;words&quot; are sequences of letters, digits, and
			underscores; that is, a word in this sense is what's matched by
			<TT><FONT COLOR="#cc0000">/\w+/</FONT></TT>. There are five words
			in that sentence: <TT><FONT COLOR="#cc0000">That</FONT></TT>, <TT><FONT COLOR="#cc0000">s</FONT></TT>,
			<TT><FONT COLOR="#cc0000">a</FONT></TT>, <TT><FONT COLOR="#cc0000">word</FONT></TT>,
			and <TT><FONT COLOR="#cc0000">boundary</FONT></TT>.<A HREF="#">[9]</A>
			Notice that the quote marks around <TT><FONT COLOR="#cc0000">word</FONT></TT>
			don't change the word boundaries; these words are made of <TT><FONT COLOR="#cc0000">\w</FONT></TT>
			characters. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP> You
			can see why we wish that we could change the definition of &quot;word&quot;;
			<TT><FONT COLOR="#cc0000">That's</FONT></TT> should be one word,
			not two words with an apostrophe in-between. And even in text that
			may be mostly ordinary English, it's normal to find a soup&ccedil;on
			of other characters spicing things up. 
			</P>
			<P>Each arrow points to the beginning or the end of one of the
			grey underlines, since the word boundary anchor <TT><FONT COLOR="#cc0000">\b</FONT></TT>
			matches only at the beginning or the end of a group of word
			characters. 
			</P>
			<H5 ALIGN=CENTER><A NAME="lperl3-CHP-8-FIG-1"></A>Figure 8-1.
			Word-boundary matches with \b</H5>
			<P ALIGN=CENTER><IMG SRC="lrnp_0801.gif" NAME="Graphic15" ALT="lrnp_0801.gif" ALIGN=BOTTOM WIDTH=281 HEIGHT=57 BORDER=0></P>
			<P><A NAME="IXT-8-336208"></A>The word-boundary anchor is useful
			to ensure that we don't accidentally find <TT><FONT COLOR="#cc0000">cat</FONT></TT>
			in <TT><FONT COLOR="#cc0000">delicatessen</FONT></TT>, <TT><FONT COLOR="#cc0000">dog</FONT></TT>
			in <TT><FONT COLOR="#cc0000">boondoggle</FONT></TT>, or <TT><FONT COLOR="#cc0000">fish</FONT></TT>
			in <TT><FONT COLOR="#cc0000">selfishness</FONT></TT>. Sometimes
			you'll want just one word-boundary anchor, as when using <TT><FONT COLOR="#cc0000">/\bhunt/</FONT></TT>
			to match words like <TT><FONT COLOR="#cc0000">hunt</FONT></TT> or
			<TT><FONT COLOR="#cc0000">hunting</FONT></TT> or <TT><FONT COLOR="#cc0000">hunter</FONT></TT>,
			but not <TT><FONT COLOR="#cc0000">shunt</FONT></TT>, or when using
			<TT><FONT COLOR="#cc0000">/stone\b/</FONT></TT> to match words
			like <TT><FONT COLOR="#cc0000">sandstone</FONT></TT> or <TT><FONT COLOR="#cc0000">flintstone</FONT></TT>
			but not <TT><FONT COLOR="#cc0000">capstones</FONT></TT>. 
			</P>
			<P><A NAME="IXT-8-336209"></A>The nonword-boundary anchor is <TT><FONT COLOR="#cc0000">\B</FONT></TT>;
			it matches at any point where <TT><FONT COLOR="#cc0000">\b</FONT></TT>
			would not match. So the pattern <TT><FONT COLOR="#cc0000">/\bsearch\B/</FONT></TT>
			will match <TT><FONT COLOR="#cc0000">searches</FONT></TT>,
			<TT><FONT COLOR="#cc0000">searching</FONT></TT>, and <TT><FONT COLOR="#cc0000">searched</FONT></TT>,
			but not <TT><FONT COLOR="#cc0000">search</FONT></TT> or
			<TT><FONT COLOR="#cc0000">researching</FONT></TT>. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-8-SECT-4"></A>8.4 Memory Parentheses</H3>
			<P><A NAME="lperl3-IDXTERM-555"></A><A NAME="lperl3-IDXTERM-556"></A>
			You remember that parentheses (&quot;<TT><FONT COLOR="#cc0000">(
			)</FONT></TT>&quot;) may be used for grouping together parts of a
			pattern. They also have a second function: they tell the regular
			expression engine to remember what was in the substring matched by
			the pattern in the parentheses. That is to say, it doesn't
			remember what was in the pattern itself; it remembers what was in
			the corresponding part of the string. Whenever you use parentheses
			for grouping, they automatically work as memory parentheses as
			well. 
			</P>
			<P><A NAME="IXT-8-336210"></A>So, if you use <TT><FONT COLOR="#cc0000">/./</FONT></TT>,
			you'll match any single character (except newline); if you use
			<TT><FONT COLOR="#cc0000">/(.)/</FONT></TT>, you'll still match
			any single character, but now it will be kept in a regular
			expression memory. For each pair of parentheses in the pattern,
			you'll have one regular expression memory. 
			</P>
			<H4><A NAME="lperl3-CHP-8-SECT-4.1"></A>8.4.1 Backreferences</H4>
			<P><A NAME="IXT-8-336211"></A><A NAME="IXT-8-336212"></A><A NAME="IXT-8-336213"></A>
			A <I>backreference</I> refers back to a memory that was saved
			earlier in the current pattern's processing. Backreferences are
			made with a backslash, which is easy to remember. For example, <TT><FONT COLOR="#cc0000">\1</FONT></TT>
			contains the first regular expression memory (that is, the part of
			the string matched by the first pair of parentheses). 
			</P>
			<P>Backreferences are used to go back and match the exact same<A HREF="#">[10]</A>
			string that was matched earlier in the pattern. So, <TT><FONT COLOR="#cc0000">/(.)\1/</FONT></TT>
			means to match any one character, remember it as memory one, then
			match memory one again. In other words, match any character,
			followed by the same character. So, this pattern will match
			strings with doubled-letters, as in <TT><FONT COLOR="#cc0000">bamm-bamm</FONT></TT>
			and <TT><FONT COLOR="#cc0000">betty</FONT></TT>. Of course, the
			dot will match characters other than letters, so if a string has
			two spaces in a row, two tabs in a row, or two asterisks in a row,
			it will match. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[10]</SUP>
			Well, if the pattern is case-insensitive, as we'll learn in the
			next chapter, the capitalization doesn't have to match. Other than
			that, though, the string must be the same.</P>
			<P>That's not the same as the pattern <TT><FONT COLOR="#cc0000">/../</FONT></TT>,
			which will match any character followed by any character&iuml;&frac34;—those
			two could be the same, or they could be different. <TT><FONT COLOR="#cc0000">/(.)\1/</FONT></TT>
			means to match any character followed by the same character. 
			</P>
			<P>A typical usage of these memories might be if you have some
			HTML-like<A HREF="#">[11]</A> text to process. For example, maybe
			you want to match a tag like these two, which may use either
			single quotes or double quotes: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP>
			These examples are intentionally <I>not</I> HTML, because there
			are too many tricky things that crop up in real HTML, or any
			similar markup language like XML or SGML. If you need to work with
			HTML, don't use simple patterns like these. Get a robust module
			from CPAN, so that you can start with code that's already written
			and debugged. If you don't, we promise that you'll be sorry. Don't
			say we didn't warn you.</P>
			<PRE><FONT COLOR="#cc0000">&lt;image source='fred.png'&gt;</FONT>
<FONT COLOR="#cc0000">&lt;image source=&quot;fred's-birthday.png&quot;&gt;</FONT></PRE><P>
			The tag may have either single quotes or double quotes, since the
			quoted data may include the other kind of mark (as with the
			apostrophe in the second example tag). So the pattern might look
			like this: <TT><FONT COLOR="#cc0000">/&lt;image
			source=(['&quot;]).*\1&gt;/</FONT></TT>. That says that the
			opening quote mark may be of either type, but there must be a
			matching mark at the end of the quote.<A HREF="#">[12]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP> If
			you realize that there may be problems with using this pattern on
			a markup language like HTML, that's okay. There are lots of
			problems with that! This is just an example to illustrate a use of
			a backreference. You shouldn't use simple patterns to parse
			anything as complex as HTML anyway.</P>
			<P>If you have more sets of parentheses, you can have more
			backreferences. As you might guess, <TT><FONT COLOR="#cc0000">\17</FONT></TT>
			is the contents of the seventeenth regular expression memory, if
			you have at least that many sets of parentheses.<A HREF="#">[13]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP> If
			you don't have that many sets of parentheses before that point in
			the pattern, backreferences <TT><FONT COLOR="#cc0000">\10</FONT></TT>
			and beyond will be treated as octal character escapes. To keep an
			octal character escape like <TT><FONT COLOR="#cc0000">\12</FONT></TT>
			from accidentally meaning a backreference, just use a leading
			zero: <TT><FONT COLOR="#cc0000">\012</FONT></TT> is always a
			character, never a backreference.</P>
			<P><A NAME="IXT-8-336214"></A>In numbering backreferences, you can
			just count the left (opening) parentheses. The
			pattern<TT><FONT COLOR="#cc0000">/((fred|wilma) (flintstone)) \1/</FONT></TT>
			says to match strings like <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			<TT><FONT COLOR="#cc0000">flintstone fred flintstone</FONT></TT>,
			since the first opening parenthesis and its corresponding closing
			parenthesis hold a pattern that matches <TT><FONT COLOR="#cc0000">fred
			flintstone</FONT></TT>.<A HREF="#">[14]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP>
			This pattern would also match <TT><FONT COLOR="#cc0000">wilma
			flintstone wilma flintstone</FONT></TT>.</P>
			<P>If we wrote <TT><FONT COLOR="#cc0000">/((fred|wilma)
			(flintstone)) \2/</FONT></TT> instead, we would match strings like
			<TT><FONT COLOR="#cc0000">fred flintstone fred</FONT></TT>; memory
			two is the choice of <TT><FONT COLOR="#cc0000">fred</FONT></TT> or
			<TT><FONT COLOR="#cc0000">wilma</FONT></TT>. (Notice that it
			wouldn't match <TT><FONT COLOR="#cc0000">fred flintsone wilma</FONT></TT>,
			since the backreference can match only the same name that was
			matched earlier: either <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			or <TT><FONT COLOR="#cc0000">wilma</FONT></TT>. But it could match
			<TT><FONT COLOR="#cc0000">wilma flintstone wilma</FONT></TT>,
			since that one uses the same name.) And the pattern <TT><FONT COLOR="#cc0000">/((fred|wilma)
			(flintstone)) \3/</FONT></TT> would match strings like <TT><FONT COLOR="#cc0000">fred
			flintstone flintstone</FONT></TT>. It's uncommon to have a literal
			string like <TT><FONT COLOR="#cc0000">flintstone</FONT></TT> in
			memory parentheses, though; we did that one just to have a third
			example. 
			</P>
			<H4><A NAME="lperl3-CHP-8-SECT-4.2"></A>8.4.2 Memory Variables</H4>
			<P><A NAME="IXT-8-336215"></A><A NAME="IXTR3-51"></A><A NAME="IXTR3-52"></A>
			When we get to the next chapter and back into the world of Perl,
			we'll see that the contents of these regular expression memories
			are available to us in special variables like <TT><FONT COLOR="#cc0000">$1</FONT></TT>
			after the pattern match is done. We mention this here just so
			you'll know that the memories aren't merely used for
			backreferences; if you see what seem to be unnecessary parentheses
			in a pattern, they may actually be setting up those memories. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic16" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-8-SECT-5"></A>8.5 Precedence</H3>
			<P><A NAME="lperl3-IDXTERM-565"></A>With all of these
			metacharacters in regular expressions, you may feel that you can't
			keep track of the players without a scorecard. That's the
			precedence chart, which shows us which parts of the pattern &quot;stick
			together&quot; the most tightly. Unlike the precedence chart for
			operators, the regular expression precedence chart is simple, with
			only four levels. As a bonus, this section will review all of the
			metacharacters that Perl uses in patterns. 
			</P>
			<OL>
				<LI><P>At the top of the precedence chart are the parentheses,
				(&quot;<TT><FONT COLOR="#cc0000">( )</FONT></TT>&quot;), used for
				grouping and memory. Anything in parentheses will &quot;stick
				together&quot; more tightly than anything else. 
				</P>
				<LI><P>The second level is the quantifiers. These are the repeat
				operators&iuml;&frac34;—star (<TT><FONT COLOR="#cc0000">*</FONT></TT>),
				plus (<TT><FONT COLOR="#cc0000">+</FONT></TT>), and question mark
				(<TT><FONT COLOR="#cc0000">?</FONT></TT>)&iuml;&frac34;—as well
				as the quantifiers made with curly braces, like <TT><FONT COLOR="#cc0000">{5,15}</FONT></TT>,
				<TT><FONT COLOR="#cc0000">{3,}</FONT></TT>, and <TT><FONT COLOR="#cc0000">{5}</FONT></TT>.
				These always stick to the item they're following. 
				</P>
				<LI><P>The third level of the precedence chart holds anchors and
				sequence. The anchors are the caret (<TT><FONT COLOR="#cc0000">^</FONT></TT>)
				start-of-string anchor, the dollar-sign (<TT><FONT COLOR="#cc0000">$</FONT></TT>)
				end-of-string anchor, the <TT><FONT COLOR="#cc0000">\b</FONT></TT>
				word-boundary anchor, and the <TT><FONT COLOR="#cc0000">\B</FONT></TT>
				nonword-boundary anchor. Sequence (putting one item after
				another) is actually an operator, even though it doesn't use a
				metacharacter. That means that letters in a word will stick
				together just as tightly as the anchors stick to the letters. 
				</P>
				<LI><P>The lowest level of precedence is the vertical bar (<TT><FONT COLOR="#cc0000">|</FONT></TT>)
				of alternation. Since this is at the bottom of the chart, it
				effectively cuts the pattern into pieces. It's at the bottom of
				the chart because we want the letters in the words in
				<TT><FONT COLOR="#cc0000">/fred|barney/</FONT></TT> to stick
				together more tightly than the alternation. If alternation were
				higher priority than sequence, that pattern would mean to match
				<TT><FONT COLOR="#cc0000">fre</FONT></TT>, followed by a choice
				of <TT><FONT COLOR="#cc0000">d</FONT></TT> or <TT><FONT COLOR="#cc0000">b</FONT></TT>,
				followed by <TT><FONT COLOR="#cc0000">arney</FONT></TT>. So,
				alternation is at the bottom of the chart, and the letters within
				the names stick together. 
				</P>
			</OL>
			<P>Besides the precedence chart, there are the so-called <I>atoms</I>
			that make up the most basic pieces of the pattern. These are the
			individual characters, character classes, and backreferences. 
			</P>
			<H4><A NAME="lperl3-CHP-8-SECT-5.1"></A>8.5.1 Examples of
			Precedence</H4>
			<P>When you need to decipher a complex regular expression, you'll
			need to do as Perl does, and use the precedence chart to see
			what's really going on. 
			</P>
			<P>For example, <TT><FONT COLOR="#cc0000">/^fred|barney$/</FONT></TT>
			is probably not what the programmer intended. That's because the
			vertical bar of alternation is very low precedence; it cuts the
			pattern in two. That pattern matches either <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			at the beginning of the string or <TT><FONT COLOR="#cc0000">barney</FONT></TT>
			at the end. It's much more likely that the programmer wanted
			<TT><FONT COLOR="#cc0000">/^(fred|barney)$/</FONT></TT>, which
			will match if the whole line has nothing but <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
			or nothing but <TT><FONT COLOR="#cc0000">barney</FONT></TT>.<A HREF="#">[15]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP>
			And, perhaps, a newline at the end of the string, as we mentioned
			earlier in connection with the <TT><FONT COLOR="#cc0000">$</FONT></TT>
			anchor.</P>
			<P>And what will <TT><FONT COLOR="#cc0000">/(wilma|pebbles?)/</FONT></TT>
			match? The question mark applies to the previous character,<A HREF="#">[16]</A>
			so that will match either <TT><FONT COLOR="#cc0000">wilma</FONT></TT>
			or <TT><FONT COLOR="#cc0000">pebbles</FONT></TT> or <TT><FONT COLOR="#cc0000">pebble</FONT></TT>,
			perhaps as part of a larger string (since there are no anchors). 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP>
			Because a quantifier sticks to the letter <TT><FONT COLOR="#cc0000">s</FONT></TT>
			more tightly than the <TT><FONT COLOR="#cc0000">s</FONT></TT>
			sticks to the other letters in <TT><FONT COLOR="#cc0000">pebbles</FONT></TT>.</P>
			<P><A NAME="IXT-8-336216"></A>The pattern <TT><FONT COLOR="#cc0000">/^(\w+)\s+(\w+)$/</FONT></TT>
			matches lines that have a &quot;word,&quot; some required
			whitespace, and another &quot;word,&quot; with nothing else before
			or after. That might be used to match lines like <TT><FONT COLOR="#cc0000">fred
			flintstone</FONT></TT>, for example. The parentheses around the
			words aren't needed for grouping, so they may be intended to save
			those substrings into the regular expression memories, which we'll
			see more about in the next chapter. 
			</P>
			<P><A NAME="IXTR3-53"></A>When you're trying to understand a
			complex pattern, it may be helpful to add parentheses to clarify
			the precedence. That's okay, but remember that grouping
			parentheses are also automatically memory parentheses; you may
			need to change the numbering of other memories when you add the
			parentheses.<A HREF="#">[17]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP> But
			look in the perlre manpage for information about nonmemory
			parentheses, which are used for grouping without memory.</P>
			<H4><A NAME="lperl3-CHP-8-SECT-5.2"></A>8.5.2 And There's More</H4>
			<P><A NAME="IXT-8-336217"></A><A NAME="IXT-8-336218"></A><A NAME="IXT-8-336219"></A><A NAME="IXT-8-336220"></A>
			Although we've covered all of the regular expression features that
			most people are likely to need for everyday programming, there are
			more features being added all the time. Check the perlre,
			perlrequick, and perlretut manpages for the latest news about what
			patterns in Perl can do.<A HREF="#">[18]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP> And
			check out <TT><FONT COLOR="#cc0000">YAPE::Regexp::Explain</FONT></TT>
			in CPAN as a regular-expression-to-English translator.</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-8-SECT-6"></A>8.6 Exercises</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-7#lperl3-APP-A-SECT-7">Section
			A.7</A> for answers to the following exercises. These exercises
			are among the most challenging in the entire book. But don't get
			too discouraged! The following chapters will actually be easier,
			partly because you'll have the power of regular expressions to
			help you. 
			</P>
			<OL>
				<LI><P>[4] Using the test program from the previous chapter, make
				a pattern that matches only lines containing either the word <TT><FONT COLOR="#cc0000">fred</FONT></TT>
				or <TT><FONT COLOR="#cc0000">wilma</FONT></TT>, followed by some
				whitespace, and then the word <TT><FONT COLOR="#cc0000">flintstone</FONT></TT>.
				So it should match the string <TT><FONT COLOR="#cc0000">I am fred
				flintstone</FONT></TT> (with one or more spaces or tabs between
				the names). 
				</P>
				<LI><P STYLE="font-weight: medium">[10] Here, we give you the
				answer; you decide what problem it's trying to solve. What do
				these real-world patterns match? What might they be used for? 
				</P>
				<PRE STYLE="font-weight: medium"><FONT COLOR="#cc0000">/&quot;([^&quot;]*)&quot;/</FONT>
<FONT COLOR="#cc0000">/^0?[0-3]?[0-7]{1,2}$/</FONT>
<FONT COLOR="#cc0000">/^\b[\w.]{1,12}\b$/</FONT></PRE><P STYLE="font-weight: medium">
				Try each of them in the test program. It may help to find some
				strings that match (and that fail to match) each one. 
				</P>
				<LI><P>[8] Make a pattern that will match a string containing
				nothing but a scalar variable's name (not its value!), like
				<TT><FONT COLOR="#cc0000">$fred</FONT></TT>, <TT><FONT COLOR="#cc0000">$barney</FONT></TT>,
				or <TT><FONT COLOR="#cc0000">$_</FONT></TT> (but you shouldn't
				match special variables like <TT><FONT COLOR="#cc0000">$0</FONT></TT>).
				That is, if the line of input has the six characters <TT><FONT COLOR="#cc0000">$wilma</FONT></TT>,
				the pattern should match. If the input says <TT><FONT COLOR="#cc0000">wilma</FONT></TT>,
				it should not match. 
				</P>
				<LI><P>[12] Make a pattern that matches any line of input that
				has the same word repeated two or more times in a row. Words in
				this problem can be considered to be sequences of letters <TT><FONT COLOR="#cc0000">a</FONT></TT>
				to <TT><FONT COLOR="#cc0000">z</FONT></TT> or <TT><FONT COLOR="#cc0000">A</FONT></TT>
				to <TT><FONT COLOR="#cc0000">Z</FONT></TT>, digits, and
				underscores. Whitespace between words may differ. For example,
				the classic observation-test string <TT><FONT COLOR="#cc0000">Paris
				in the the spring</FONT></TT> should match, since it has a
				doubled word. Also, <TT><FONT COLOR="#cc0000">I thought that that
				was the problem</FONT></TT> should match, even though that may be
				a correct use of a doubled word. Does your pattern match all
				three words in <TT><FONT COLOR="#cc0000">I thought that that that
				was the problem</FONT></TT> (with extra spaces between only some
				of the words)? Does it match <TT><FONT COLOR="#cc0000">This is a</FONT></TT>
				<TT><FONT COLOR="#cc0000">test</FONT></TT>? How about <TT><FONT COLOR="#cc0000">This
				shouldn't match, according to the theory</FONT></TT> <TT><FONT COLOR="#cc0000">of
				regular expressions</FONT></TT>? 
				</P>
			</OL>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H2><A NAME="lperl3-CHP-9"></A>Chapter 9. Using Regular
			Expressions</H2>
			<P><A NAME="lperl3-IDXTERM-572"></A>Now that we've seen what goes
			inside a regular expression, let's take what we've learned back
			into Perl. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-1"></A>9.1 Matches with m//</H3>
			<P><A NAME="IXT-9-336221"></A><A NAME="IXT-9-336222"></A><A NAME="IXT-9-336223"></A>
			We've been writing patterns in pairs of forward slashes, like
			<TT><FONT COLOR="#cc0000">/fred/</FONT></TT>. But this is actually
			a shortcut for the <TT><FONT COLOR="#cc0000">m//</FONT></TT>
			(pattern match) operator. As we saw with the <TT><FONT COLOR="#cc0000">qw//</FONT></TT>
			operator, you may choose any pair of delimiters to quote the
			contents. So, we could write that same expression as <TT><FONT COLOR="#cc0000">m(fred)</FONT></TT>,
			<TT><FONT COLOR="#cc0000">m&lt;fred&gt;</FONT></TT>, <TT><FONT COLOR="#cc0000">m{fred}</FONT></TT>,
			or <TT><FONT COLOR="#cc0000">m[fred]</FONT></TT> using those
			paired delimiters, or as <TT><FONT COLOR="#cc0000">m,fred,</FONT></TT>,
			<TT><FONT COLOR="#cc0000">m!fred!</FONT></TT>, <TT><FONT COLOR="#cc0000">m^fred^</FONT></TT>,
			or many other ways using nonpaired delimiters.<A HREF="#">[1]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-9-336224"></A><A NAME="IXT-9-336225"></A>
			<SUP>[1]</SUP> Nonpaired delimiters are the ones that don't have a
			different &quot;left&quot; and &quot;right&quot; variety; the same
			punctuation mark is used for both ends.</P>
			<P><A NAME="IXT-9-336226"></A><A NAME="IXT-9-336227"></A>The
			shortcut is that if you choose the forward slash as the delimiter,
			you may omit the initial <TT><FONT COLOR="#cc0000">m</FONT></TT>.
			Since Perl folks love to avoid typing extra characters, you'll see
			most pattern matches written using slashes, as in <TT><FONT COLOR="#cc0000">/fred/</FONT></TT>.
			
			</P>
			<P>Of course, you should wisely choose a delimiter that doesn't
			appear in your pattern.<A HREF="#">[2]</A> If you wanted to make a
			pattern to match the beginning of an ordinary web URL, you might
			start to write <TT><FONT COLOR="#cc0000">/^http:\/\//</FONT></TT>
			to match the initial <TT><FONT COLOR="#cc0000">&quot;http://&quot;</FONT></TT>.
			But that's easier to read, write, maintain, and debug if you use a
			better choice of delimiter: <TT><FONT COLOR="#cc0000">m%^http://%</FONT></TT>.<A HREF="#">[3]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> If
			you're using paired delimiters, you shouldn't generally have to
			worry about using the delimiter inside the pattern, since that
			delimiter will generally be paired inside your pattern. That is,
			<TT><FONT COLOR="#cc0000">m(fred(.*)barney)</FONT></TT> and
			<TT><FONT COLOR="#cc0000">m{\w{2,}}</FONT></TT> and <TT><FONT COLOR="#cc0000">m[wilma[\n
			\t]+betty]</FONT></TT> are all fine, even though the pattern
			contains the quoting character, since each &quot;left&quot; has a
			corresponding &quot;right&quot;. But the angle brackets (&quot;<TT><FONT COLOR="#cc0000">&lt;</FONT></TT>&quot;
			and &quot;<TT><FONT COLOR="#cc0000">&gt;</FONT></TT>&quot;) aren't
			regular expression metacharacters, so they may not be paired; if
			the pattern were <TT><FONT COLOR="#cc0000">m{(\d+)\s*&gt;=?\s*(\d+)}</FONT></TT>,
			quoting it with angle brackets would mean having to backslash the
			greater-than sign so that it wouldn't prematurely end the pattern.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP>
			Remember, the forward slash is not a metacharacter, so it doesn't
			need to be backslashed when it's not the delimiter.</P>
			<P>It's common to use curly braces as the delimiter. If you use a
			programmers' text editor, it probably has the ability to jump from
			an opening curly brace to the corresponding closing one, which can
			be handy in maintaining code. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-2"></A>9.2 Option Modifiers</H3>
			<P><A NAME="IXT-9-336228"></A><A NAME="IXT-9-336229"></A>There are
			several option modifier letters, sometimes called <I>flags</I>,
			which may be appended as a group right after the ending delimiter
			of a regular expression to change its behavior from the default. 
			</P>
			<H4><A NAME="lperl3-CHP-9-SECT-2.1"></A>9.2.1 Case-insensitive
			Matching with /i</H4>
			<P><A NAME="IXT-9-336230"></A><A NAME="IXT-9-336231"></A><A NAME="IXT-9-336232"></A>
			To make a case-insensitive pattern match, so that you can match
			<TT><FONT COLOR="#cc0000">FRED</FONT></TT> as easily as <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			or <TT><FONT COLOR="#cc0000">Fred</FONT></TT>, use the <TT><FONT COLOR="#cc0000">/i</FONT></TT>
			modifier: 
			</P>
			<PRE><FONT COLOR="#cc0000">print &quot;Would you like to play a game? &quot;;</FONT>
<FONT COLOR="#cc0000">chomp($_ = &lt;STDIN&gt;);</FONT>
<FONT COLOR="#cc0000">if (/\byes\b/i) {  # case-insensitive match</FONT>
<FONT COLOR="#cc0000">  print &quot;In that case, I recommend that you go bowling.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-2.2"></A>9.2.2 Matching Any Character
			with /s</H4>
			<P><A NAME="IXT-9-336233"></A><A NAME="IXT-9-336234"></A><A NAME="IXT-9-336235"></A><A NAME="IXT-9-336236"></A>
			Do you ever feel frustrated that the dot (<TT><FONT COLOR="#cc0000">.</FONT></TT>)
			won't match newline? If you might have newlines in your strings,
			and you want the dot to be able to match them, the <TT><FONT COLOR="#cc0000">/s</FONT></TT>
			modifier will do the job. It changes every dot<A HREF="#">[4]</A>
			in the pattern to act like the character class <TT><FONT COLOR="#cc0000">[\d\D]</FONT></TT>
			does, which is to match any character, even if it is a newline. Of
			course, you have to have a string with newlines for this to make a
			difference: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP> If
			you wish to change just some of them, and not all, you'll probably
			want to replace just those few with <TT><FONT COLOR="#cc0000">[\d\D]</FONT></TT>.</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;I saw Barney\ndown at the bowling alley\nwith Fred\nlast night.\n&quot;;</FONT>
<FONT COLOR="#cc0000">if (/\bBarney\b.*\bFred\b/s) {</FONT>
<FONT COLOR="#cc0000">  print &quot;That string mentions Fred after Barney!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Without the <TT><FONT COLOR="#cc0000">/s</FONT></TT> modifier,
			that match would fail, since the two names aren't on the same
			line. 
			</P>
			<H4><A NAME="lperl3-CHP-9-SECT-2.3"></A>9.2.3 Combining Option
			Modifiers</H4>
			<P>If you have more than one option modifier to use on the same
			pattern, they may be used one after the other; their order isn't
			significant: 
			</P>
			<PRE><FONT COLOR="#cc0000">if (/\bbarney\b.*\bfred\b/si) {  # both /s and /i</FONT>
<FONT COLOR="#cc0000">  print &quot;That string mentions Fred after Barney!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-2.4"></A>9.2.4 Other Options</H4>
			<P>There are many other option modifiers available. We'll cover
			those as we get to them, or you can read about them in the perlop
			manpage and in the descriptions of <TT><FONT COLOR="#cc0000">m//</FONT></TT>
			and the other regular expression operators that we'll see later in
			this chapter. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic17" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-3"></A>9.3 The Binding Operator, =~</H3>
			<P><A NAME="IXT-9-336237"></A><A NAME="IXT-9-336238"></A><A NAME="IXT-9-336239"></A><A NAME="IXT-9-336240"></A>
			Matching against <TT><FONT COLOR="#cc0000">$_</FONT></TT> is
			merely the default; the <I>binding operator</I> (<TT><FONT COLOR="#cc0000">=~</FONT></TT>)
			tells Perl to match the pattern on the right against the string on
			the left, instead of matching against <TT><FONT COLOR="#cc0000">$_</FONT></TT>.<A HREF="#">[5]</A>
			For example: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[5]</SUP> The
			binding operator is also used with some other operations besides
			the pattern match, as we'll see later.</P>
			<PRE><FONT COLOR="#cc0000">my $some_other = &quot;I dream of betty rubble.&quot;;</FONT>
<FONT COLOR="#cc0000">if ($some_other =~ /\brub/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;Aye, there's the rub.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The first time you see it, the binding operator looks like some
			kind of assignment operator. But it's no such thing! It is simply
			saying, &quot;this pattern match which would attach to <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			by default&iuml;&frac34;—make it work with this string on the
			left instead.&quot; If there's no binding operator, the expression
			is using <TT><FONT COLOR="#cc0000">$_</FONT></TT> by default. 
			</P>
			<P>In the (somewhat unusual) example below, <TT><FONT COLOR="#cc0000">$likes_perl</FONT></TT>
			is set to a Boolean value according to what the user typed at the
			prompt. This is a little on the quick-and-dirty side, because the
			line of input itself is discarded. This code reads the line of
			input, tests that string against the pattern, then discards the
			line of input.<A HREF="#">[6]</A> It doesn't use or change <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			at all. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP>
			Remember, the line of input is not automatically stored into
			<TT><FONT COLOR="#cc0000">$_</FONT></TT>unless the line-input
			operator (<TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>) is
			all alone in the conditional expression of a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop.</P>
			<PRE><FONT COLOR="#cc0000">print &quot;Do you like Perl? &quot;;</FONT>
<FONT COLOR="#cc0000">my $likes_perl = (&lt;STDIN&gt; =~ /\byes\b/i);</FONT>
<FONT COLOR="#cc0000">...  # Time passes...</FONT>
<FONT COLOR="#cc0000">if ($likes_perl) {</FONT>
<FONT COLOR="#cc0000">  print &quot;You said earlier that you like Perl, so...\n&quot;;</FONT>
<FONT COLOR="#cc0000">  ...</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The parentheses around the pattern-test expression aren't
			required, so the following line does the same thing as the one
			above&iuml;&frac34;—it stores the result of the test (and not
			the line of input) into the variable: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $likes_perl = &lt;STDIN&gt; =~ /\byes\b/i;</FONT></PRE><P>
			<A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic18" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-4"></A>9.4 Interpolating into
			Patterns</H3>
			<P><A NAME="IXT-9-336241"></A>The regular expression is
			double-quote interpolated, just as if it were a double-quoted
			string. This allows us to write a quick <I>grep</I>-like program
			like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">#!/usr/bin/perl -w</FONT>
<FONT COLOR="#cc0000">my $what = &quot;larry&quot;;</FONT>

<FONT COLOR="#cc0000">while (&lt;&gt;) {</FONT>
<FONT COLOR="#cc0000">  if (/^($what)/) {  # pattern is anchored at beginning of string</FONT>
<FONT COLOR="#cc0000">    print &quot;We saw $what in beginning of $_&quot;;</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The pattern will be built up out of whatever's in <TT><FONT COLOR="#cc0000">$what</FONT></TT>
			when we run the pattern match. In this case, it's the same as if
			we had written <TT><FONT COLOR="#cc0000">/^(larry)/</FONT></TT>,
			looking for <TT><FONT COLOR="#cc0000">larry</FONT></TT> at the
			start of each line. 
			</P>
			<P>But we didn't have to get the value of <TT><FONT COLOR="#cc0000">$what</FONT></TT>
			from a literal string; we could have gotten it instead from the
			command-line arguments in <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>:
			
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $what = shift @ARGV;</FONT></PRE><P>
			Now, if the first command-line argument were <TT><FONT COLOR="#cc0000">fred|barney</FONT></TT>,
			the pattern becomes <TT><FONT COLOR="#cc0000">/^(fred|barney)/</FONT></TT>,
			looking for <TT><FONT COLOR="#cc0000">fred</FONT></TT> or <TT><FONT COLOR="#cc0000">barney</FONT></TT>
			at the start of each line.<A HREF="#">[7]</A> The parentheses
			(which weren't really necessary when searching for <TT><FONT COLOR="#cc0000">larry</FONT></TT>)
			are important, now, because without them we'd be matching <TT><FONT COLOR="#cc0000">fred</FONT></TT>
			at the start or <TT><FONT COLOR="#cc0000">barney</FONT></TT>
			anywhere in the string. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP> The
			astute reader will know that you can't generally type <TT><FONT COLOR="#cc0000">fred|barney</FONT></TT>
			as an argument at the command line because the vertical bar is a
			shell metacharacter. See the documentation to your shell to learn
			about how to quote command-line arguments.</P>
			<P>With that line changed to get the pattern from <TT><FONT COLOR="#cc0000">@ARGV</FONT></TT>,
			this program resembles the Unix <I>grep</I> command. But we have
			to watch out for metacharacters in the string. If <TT><FONT COLOR="#cc0000">$what</FONT></TT>
			contains <TT><FONT COLOR="#cc0000">'fred(barney'</FONT></TT>, the
			pattern would look like <TT><FONT COLOR="#cc0000">/^(fred(barney)/</FONT></TT>,
			and you know that can't work right&iuml;&frac34;—it'll crash
			your program with an invalid regular expression error. With some
			advanced techniques,<A HREF="#">[8]</A> you can trap this kind of
			error (or prevent the magic of the metacharacters in the first
			place) so that it won't crash your program. But for now, just know
			that if you give your users the power of regular expressions,
			they'll also need the responsibility to use them correctly. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> In
			this case, you would use an <TT><FONT COLOR="#cc0000">eval</FONT></TT>
			block to trap the error, or you would quote the interpolated text
			using <TT><FONT COLOR="#cc0000">quotemeta</FONT></TT> (or its <TT><FONT COLOR="#cc0000">\Q</FONT></TT>
			equivalent form) so that it's no longer treated as a regular
			expression.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic19" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-5"></A>9.5 The Match Variables</H3>
			<P><A NAME="lperl3-IDXTERM-594"></A><A NAME="lperl3-IDXTERM-595"></A>
			Do you remember the regular expression memories, which we used
			with backreferences in the previous chapter? Those memories are
			also available after the pattern match is done, after we return to
			Perl. They're strings, so they are kept in scalar variables with
			names like <TT><FONT COLOR="#cc0000">$1</FONT></TT> and <TT><FONT COLOR="#cc0000">$2</FONT></TT>.
			There are as many of these variables as there are pairs of memory
			parentheses in the pattern. As you'd expect, <TT><FONT COLOR="#cc0000">$4</FONT></TT>
			means the string matched by the fourth set of parentheses. This is
			the same string that <TT><FONT COLOR="#cc0000">\4</FONT></TT>
			referred to inside the pattern match. 
			</P>
			<P>Why are there two different ways to refer to that same string?
			They're not really referring to the same string at the same time;
			<TT><FONT COLOR="#cc0000">$4</FONT></TT> means the fourth memory
			of an already completed pattern match, while <TT><FONT COLOR="#cc0000">\4</FONT></TT>
			is a backreference referring back to the fourth memory of the
			currently matching regular expression. Besides, backreferences
			work inside regular expressions only; once we're back in the world
			of Perl, we'll use <TT><FONT COLOR="#cc0000">$4</FONT></TT>. 
			</P>
			<P>These match variables are a big part of the power of regular
			expressions, because they let us pull out the parts of a string: 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;Hello there, neighbor&quot;;</FONT>
<FONT COLOR="#cc0000">if (/\s(\w+),/) {             # memorize the word between space and comma</FONT>
<FONT COLOR="#cc0000">  print &quot;the word was $1\n&quot;;  # the word was there</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Or you could use more than one memory at once:</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;Hello there, neighbor&quot;;</FONT>
<FONT COLOR="#cc0000">if (/(\S+) (\S+), (\S+)/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;words were $1 $2 $3\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			That tells us that the <TT><FONT COLOR="#cc0000">words were Hello
			there neighbor</FONT></TT>. Notice that there's no comma in the
			output (because the comma is outside of the memory parentheses).
			That leaves the comma out of memory two. Using this technique, we
			can choose exactly what we want in the memories, as well as what
			we want to leave out. 
			</P>
			<P>You could even have an empty match variable,<A HREF="#">[9]</A>
			if that part of the pattern might be empty. That is, a match
			variable may contain the empty string: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP> As
			opposed to an undefined one. If you have three or fewer sets of
			parentheses in the pattern, <TT><FONT COLOR="#cc0000">$4</FONT></TT>
			will be <TT><FONT COLOR="#cc0000">undef</FONT></TT>.</P>
			<PRE><FONT COLOR="#cc0000">my $dino = &quot;I fear that I'll be extinct after 1000 years.&quot;;</FONT>
<FONT COLOR="#cc0000">if ($dino =~ /(\d*) years/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;That said '$1' years.\n&quot;;  # 1000</FONT>
<FONT COLOR="#cc0000">}</FONT>

<FONT COLOR="#cc0000">$dino = &quot;I fear that I'll be extinct after a few million years.&quot;;</FONT>
<FONT COLOR="#cc0000">if ($dino =~ /(\d*) years/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;That said '$1' years.\n&quot;;  # empty string</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-5.1"></A>9.5.1 The Persistence of
			Memory</H4>
			<P><A NAME="IXT-9-336242"></A>These match variables generally stay
			around until the next successful pattern match.<A HREF="#">[10]</A>
			That is, an unsuccessful match leaves the previous memories
			intact, but a successful one resets them all. But this correctly
			implies that you shouldn't use these match variables unless the
			match succeeded; otherwise, you could be seeing a memory from some
			previous pattern. The following (bad) example is supposed to print
			a word matched from <TT><FONT COLOR="#cc0000">$_</FONT></TT>. But
			if the match fails, it's using whatever leftover string happens to
			be found in <TT><FONT COLOR="#cc0000">$1</FONT></TT>: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[10]</SUP> The
			actual scoping rule is much more complex (see the documentation if
			you need it), but as long as you don't expect the match variables
			to be untouched many lines after a pattern match, you shouldn't
			have problems.</P>
			<PRE><FONT COLOR="#cc0000">$wilma =~ /(\w+)/;  # BAD! Untested match result</FONT>
<FONT COLOR="#cc0000">print &quot;Wilma's word was $1... or was it?\n&quot;;</FONT></PRE><P>
			This is another reason that a pattern match is almost always found
			in the conditional expression of an <TT><FONT COLOR="#cc0000">if</FONT></TT>
			or <TT><FONT COLOR="#cc0000">while</FONT></TT>: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ($wilma =~ /(\w+)/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;Wilma's word was $1.\n&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;Wilma doesn't have a word.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Since these memories don't stay around forever, you shouldn't use
			a match variable like <TT><FONT COLOR="#cc0000">$1</FONT></TT>
			more than a few lines after its pattern match. If your maintenance
			programmer adds a new regular expression between your regular
			expression and your use of <TT><FONT COLOR="#cc0000">$1</FONT></TT>,
			you'll be getting the value of <TT><FONT COLOR="#cc0000">$1</FONT></TT>
			for the second match, rather than the first. For this reason, if
			you need a memory for more than a few lines, it's generally best
			to copy it into an ordinary variable. Doing this helps make the
			code more readable at the same time: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ($wilma =~ /(\w+)/) {</FONT>
<FONT COLOR="#cc0000">  my $wilma_word = $1;</FONT>
<FONT COLOR="#cc0000">  ...</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Later, in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-14#lperl3-CHP-14">Chapter
			14</A>, we'll see how to get the memory value directly into the
			variable at the same time as the pattern match happens, without
			having to use <TT><FONT COLOR="#cc0000">$1</FONT></TT> explicitly.
			
			</P>
			<H4><A NAME="lperl3-CHP-9-SECT-5.2"></A>9.5.2 The Automatic Match
			Variables</H4>
			<P>There are three more match variables that you get for free,<A HREF="#">[11]</A>
			whether the pattern has memory parentheses or not. That's the good
			news; the bad news is that these variables have weird names. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP>
			Yeah, right. There's no such thing as a free match. These are
			&quot;free&quot; only in the sense that they don't require match
			parentheses. Don't worry; we'll mention their real cost a little
			later, though.</P>
			<P><A NAME="IXT-9-336243"></A><A NAME="IXT-9-336244"></A><A NAME="IXT-9-336245"></A>
			Now, Larry probably would have been happy enough to call these by
			slightly-less-weird names, like perhaps <TT><FONT COLOR="#cc0000">$gazoo</FONT></TT>
			or <TT><FONT COLOR="#cc0000">$ozmodiar</FONT></TT>. But those are
			names that you just might want to use in your own code. To keep
			ordinary Perl programmers from having to memorize the names of all
			of Perl's special variables before choosing their first variable
			names in their first programs,<A HREF="#">[12]</A> Larry has given
			strange names to many of Perl's builtin variables, names that
			&quot;break the rules.&quot; In this case, the names are
			punctuation marks: <TT><FONT COLOR="#cc0000">$&amp;</FONT></TT>,
			<TT><FONT COLOR="#cc0000">$`</FONT></TT>, and <TT><FONT COLOR="#cc0000">$'</FONT></TT>.
			They're strange, ugly, and weird, but those are their names.<A HREF="#">[13]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP> You
			should still avoid a few classical variable names like <TT><FONT COLOR="#cc0000">$ARGV</FONT></TT>,
			but these few are all in all-caps. All of Perl's builtin variables
			are documented in the perlvar manpage.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP> If
			you really can't stand these names, check out the <TT><FONT COLOR="#cc0000">English</FONT></TT>
			module, which attempts to give all of Perl's strangest variables
			nearly normal names. But the use of this module has never really
			caught on; instead, Perl programmers have grown to love the
			punctuation-mark variable names, strange as they are. 
			</P>
			<P><A NAME="IXT-9-336246"></A>The part of the string that actually
			matched the pattern is automatically stored in <TT><FONT COLOR="#cc0000">$&amp;</FONT></TT>:
			
			</P>
			<PRE><FONT COLOR="#cc0000">if (&quot;Hello there, neighbor&quot; =~ /\s(\w+),/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;That actually matched '$&amp;'.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			That tells us that the part that matched was <TT><FONT COLOR="#cc0000">&quot;
			there,&quot;</FONT></TT> (with a space, a word, and a comma).
			Memory one, in <TT><FONT COLOR="#cc0000">$1</FONT></TT>, has just
			the five-letter word <TT><FONT COLOR="#cc0000">there</FONT></TT>,
			but <TT><FONT COLOR="#cc0000">$&amp;</FONT></TT> has the entire
			matched section. 
			</P>
			<P><A NAME="IXT-9-336247"></A><A NAME="IXT-9-336248"></A>Whatever
			came before the matched section is in <TT><FONT COLOR="#cc0000">$`</FONT></TT>,
			and whatever was after it is in <TT><FONT COLOR="#cc0000">$'</FONT></TT>.
			Another way to say that is that <TT><FONT COLOR="#cc0000">$`</FONT></TT>
			holds whatever the regular expression engine had to skip over
			before it found the match, and <TT><FONT COLOR="#cc0000">$'</FONT></TT>
			has the remainder of the string that the pattern never got to. If
			you glue these three strings together in order, you'll always get
			back the original string: 
			</P>
			<PRE><FONT COLOR="#cc0000">if (&quot;Hello there, neighbor&quot; =~ /\s(\w+),/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;That was ($`)($&amp;)($').\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The message shows the string as <TT><FONT COLOR="#cc0000">(Hello)(
			there,)( neighbor)</FONT></TT>, showing the three automatic match
			variables in action. This may seem familiar, and for good reason:
			These automatic memory variables are what the pattern test program
			(from <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-7#lperl3-CHP-7">Chapter
			7</A>) was using in its line of &quot;mystery&quot; code, to show
			what part of the string was being matched by the pattern: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print &quot;Matched: |$`&lt;$&amp;&gt;$'|\n&quot;;  # The three automatic match variables</FONT></PRE><P>
			Any or all of these three automatic match variables may be empty,
			of course, just like the numbered match variables. And they have
			the same scope as the numbered match variables. Generally, that
			means that they'll stay around until the next successful pattern
			match. 
			</P>
			<P><A NAME="IXT-9-336249"></A><A NAME="IXT-9-336250"></A>Now, we
			said earlier that these three are &quot;free.&quot; Well, freedom
			has its price. In this case, the price is that once you use any
			one of these automatic match variables anywhere in your entire
			program, other regular expressions will run a little more slowly.
			Now, this isn't a giant slowdown, but it's enough of a worry that
			many Perl programmers will simply never use these automatic match
			variables.<A HREF="#">[14]</A> Instead, they'll use a workaround.
			For example, if the only one you need is <TT><FONT COLOR="#cc0000">$&amp;</FONT></TT>,
			just put parentheses around the whole pattern and use <TT><FONT COLOR="#cc0000">$1</FONT></TT>
			instead (you may need to renumber the pattern's memories, of
			course). 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP>
			Most of these folks haven't actually benchmarked their programs to
			see whether their workarounds actually save time, though; it's as
			though these variables were poisonous or something. But we can't
			blame them for not benchmarking&iuml;&frac34;—many programs that
			could benefit from these three variables take up only a few
			minutes of CPU time in a week, so benchmarking and optimizing
			would be a waste of time. But in that case, why fear a possible
			extra millisecond? By the way, the Perl developers are working on
			this problem, but there will probably be no solution before Perl
			6.</P>
			<P><A NAME="IXTR3-54"></A><A NAME="IXTR3-55"></A>Match variables
			(both the automatic ones and the numbered ones) are most often
			used in substitutions, which are the topic of the next section. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic20" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-6"></A>9.6 Substitutions with s///</H3>
			<P><A NAME="lperl3-IDXTERM-607"></A><A NAME="lperl3-IDXTERM-608"></A><A NAME="lperl3-IDXTERM-609"></A><A NAME="lperl3-IDXTERM-610"></A>
			If you think of the <TT><FONT COLOR="#cc0000">m//</FONT></TT>
			pattern match as being like your word processor's &quot;search&quot;
			feature, the &quot;search and replace&quot; feature would have to
			be Perl's <TT><FONT COLOR="#cc0000">s///</FONT></TT> substitution
			operator. This simply replaces whatever part of a variable<A HREF="#">[15]</A>
			matches a pattern with a replacement string: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP>
			Unlike <TT><FONT COLOR="#cc0000">m//</FONT></TT>, which can match
			against any string expression, <TT><FONT COLOR="#cc0000">s///</FONT></TT>
			is modifying data that must therefore be contained in what's known
			as an <I>lvalue</I>. This is nearly always a variable, although it
			could actually be anything that could be used on the left side of
			an assignment operator.</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;He's out bowling with Barney tonight.&quot;;</FONT>
<FONT COLOR="#cc0000">s/Barney/Fred/;  # Replace Barney with Fred</FONT>
<FONT COLOR="#cc0000">print &quot;$_\n&quot;;</FONT></PRE><P>
			If the match fails, nothing happens, and the variable is
			untouched:</P>
			<PRE><FONT COLOR="#cc0000"># Continuing from above; $_ has &quot;He's out bowling with Fred tonight.&quot;</FONT>
<FONT COLOR="#cc0000">s/Wilma/Betty/;  # Replace Wilma with Betty (fails)</FONT></PRE><P>
			Of course, both the pattern and the replacement string could be
			more complex. Here, the replacement string uses the first memory
			variable, which is set by the pattern match: 
			</P>
			<PRE><FONT COLOR="#cc0000">s/with (\w+)/against $1/;</FONT>
<FONT COLOR="#cc0000">print &quot;$_\n&quot;;  # says &quot;He's out bowling against Fred tonight.&quot;</FONT></PRE><P>
			Here are some other possible substitutions. (These are here only
			as samples; in the real world, it would not be typical to do so
			many unrelated substitutions in a row.) 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;green scaly dinosaur&quot;;</FONT>
<FONT COLOR="#cc0000">s/(\w+) (\w+)/$2, $1/;  # Now it's &quot;scaly, green dinosaur&quot;</FONT>
<FONT COLOR="#cc0000">s/^/huge, /;            # Now it's &quot;huge, scaly, green dinosaur&quot;</FONT>
<FONT COLOR="#cc0000">s/,.*een//;             # Empty replacement: Now it's &quot;huge dinosaur&quot;</FONT>
<FONT COLOR="#cc0000">s/green/red/;           # Failed match: still &quot;huge dinosaur&quot;</FONT>
<FONT COLOR="#cc0000">s/\w+$/($`!)$&amp;/;        # Now it's &quot;huge (huge !)dinosaur&quot;</FONT>
<FONT COLOR="#cc0000">s/\s+(!\W+)/$1 /;       # Now it's &quot;huge (huge!) dinosaur&quot;</FONT>
<FONT COLOR="#cc0000">s/huge/gigantic/;       # Now it's &quot;gigantic (huge!) dinosaur&quot;</FONT></PRE><P>
			There's a return value from <TT><FONT COLOR="#cc0000">s///</FONT></TT>;
			it's true if a substitution was successful; otherwise it's false: 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;fred flintstone&quot;;</FONT>
<FONT COLOR="#cc0000">if (s/fred/wilma/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;Successfully replaced fred with wilma!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-6.1"></A>9.6.1 Global Replacements with
			/g</H4>
			<P><A NAME="IXT-9-336251"></A>As you may have noticed in a
			previous example, <TT><FONT COLOR="#cc0000">s///</FONT></TT> will
			make just one replacement, even if others are possible. Of course,
			that's just the default. The <TT><FONT COLOR="#cc0000">/g</FONT></TT>
			modifier tells <TT><FONT COLOR="#cc0000">s///</FONT></TT> to make
			all possible nonoverlapping<A HREF="#">[16]</A> replacements: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP>
			It's nonoverlapping because each new match starts looking just
			beyond the latest replacement.</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;home, sweet home!&quot;;</FONT>
<FONT COLOR="#cc0000">s/home/cave/g;</FONT>
<FONT COLOR="#cc0000">print &quot;$_\n&quot;;  # &quot;cave, sweet cave!&quot;</FONT></PRE><P>
			<A NAME="IXT-9-336252"></A><A NAME="IXT-9-336253"></A>A fairly
			common use of a global replacement is to collapse whitespace; that
			is, to turn any arbitrary whitespace into a single space: 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;Input  data\t may have    extra whitespace.&quot;;</FONT>
<FONT COLOR="#cc0000">s/\s+/ /g;  # Now it says &quot;Input data may have extra whitespace.&quot;</FONT></PRE><P>
			Once we show collapsing whitespace, everyone wants to know about
			stripping leading and trailing whitespace. That's easy enough, in
			two steps:<A HREF="#">[17]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP> It
			could be done in one step, but this way is better.</P>
			<PRE><FONT COLOR="#cc0000">s/^\s+//;  # Replace leading whitespace with nothing</FONT>
<FONT COLOR="#cc0000">s/\s+$//;  # Replace trailing whitespace with nothing</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-6.2"></A>9.6.2 Different Delimiters</H4>
			<P><A NAME="IXT-9-336254"></A>Just as we did with <TT><FONT COLOR="#cc0000">m//</FONT></TT>
			and <TT><FONT COLOR="#cc0000">qw//</FONT></TT>, we can change the
			delimiters for <TT><FONT COLOR="#cc0000">s///</FONT></TT>. But the
			substitution uses three delimiter characters, so things are a
			little different. 
			</P>
			<P>With ordinary (non-paired) characters, which don't have a left
			and right variety, just use three of them, as we did with the
			forward slash. Here, we've chosen the pound sign<A HREF="#">[18]</A>
			aSs the delimiter: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP>
			With apologies to our British friends, to whom the pound sign is
			something else! Although the pound sign is generally the start of
			a comment in Perl, it won't start a comment when the parser knows
			to expect a delimiter&iuml;&frac34;—in this case, immediately
			after the <TT><FONT COLOR="#cc0000">s</FONT></TT> that starts the
			substitution.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">s#^https://#http://#;</FONT></PRE><P>
			But if you use paired characters, which have a left and right
			variety, you have to use two pairs: one to hold the pattern and
			one to hold the replacement string. In this case, the delimiters
			don't have to be the same kind around the string as they are
			around the pattern. In fact, the delimiters of the string could
			even be non-paired. These are all the same: 
			</P>
			<PRE><FONT COLOR="#cc0000">s{fred}{barney};</FONT>
<FONT COLOR="#cc0000">s[fred](barney);</FONT>
<FONT COLOR="#cc0000">s&lt;fred&gt;#barney#;</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-6.3"></A>9.6.3 Option Modifiers</H4>
			<P><A NAME="IXT-9-336255"></A><A NAME="IXT-9-336256"></A>In
			addition to the <TT><FONT COLOR="#cc0000">/g</FONT></TT>
			modifier,<A HREF="#">[19]</A> substitutions may use the <TT><FONT COLOR="#cc0000">/i</FONT></TT>
			and <TT><FONT COLOR="#cc0000">/s</FONT></TT> modifiers that we saw
			in ordinary pattern matching. The order of modifiers isn't
			significant. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[19]</SUP> We
			speak of the modifiers with names like &quot;<TT><FONT COLOR="#cc0000">/i</FONT></TT>&quot;
			, even if the delimiter is something different than a slash.</P>
			<PRE><FONT COLOR="#cc0000">s#wilma#Wilma#gi;  # replace every WiLmA or WILMA with Wilma</FONT>
<FONT COLOR="#cc0000">s{__END_  _.*}{}s;   # chop off the end marker and all following lines</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-6.4"></A>9.6.4 The Binding Operator</H4>
			<P><A NAME="IXT-9-336257"></A>Just as we saw with <TT><FONT COLOR="#cc0000">m//</FONT></TT>,
			we can choose a different target for <TT><FONT COLOR="#cc0000">s///</FONT></TT>
			by using the binding operator: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$file_name =~ s#^.*/##s;  # In $file_name, remove any Unix-style path</FONT></PRE><H4>
			<A NAME="lperl3-CHP-9-SECT-6.5"></A>9.6.5 Case Shifting</H4>
			<P><A NAME="IXT-9-336258"></A><A NAME="IXT-9-336259"></A><A NAME="IXT-9-336260"></A><A NAME="IXT-9-336261"></A><A NAME="IXT-9-336262"></A><A NAME="IXT-9-336263"></A>
			It often happens in a substitution that you'll want to make sure
			that a replacement word is properly capitalized (or not, as the
			case may be). That's easy to accomplish with Perl, by using some
			backslash escapes. The <TT><FONT COLOR="#cc0000">\U</FONT></TT>
			escape forces what follows to all uppercase: 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;I saw Barney with Fred.&quot;;</FONT>
<FONT COLOR="#cc0000">s/(fred|barney)/\U$1/gi;  # $_ is now &quot;I saw BARNEY with FRED.&quot;</FONT></PRE><P>
			<A NAME="IXT-9-336264"></A>Similarly, the <TT><FONT COLOR="#cc0000">\L</FONT></TT>
			escape forces lowercase. Continuing from the previous code: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">s/(fred|barney)/\L$1/gi;  # $_ is now &quot;I saw barney with fred.&quot;</FONT></PRE><P>
			<A NAME="IXT-9-336265"></A>By default, these affect the rest of
			the (replacement) string; or you can turn off case shifting with
			<TT><FONT COLOR="#cc0000">\E</FONT></TT>: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">s/(\w+) with (\w+)/\U$2\E with $1/i;  # $_ is now &quot;I saw FRED with barney.&quot;</FONT></PRE><P>
			<A NAME="IXT-9-336266"></A><A NAME="IXT-9-336267"></A>When written
			in lowercase (<TT><FONT COLOR="#cc0000">\l</FONT></TT> and <TT><FONT COLOR="#cc0000">\u</FONT></TT>),
			they affect only the next character: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">s/(fred|barney)/\u$1/ig;  # $_ is now &quot;I saw FRED with Barney.&quot;</FONT></PRE><P>
			You can even stack them up. Using <TT><FONT COLOR="#cc0000">\u</FONT></TT>
			with <TT><FONT COLOR="#cc0000">\L</FONT></TT> means &quot;all
			lower case, but capitalize the first letter&quot;:<A HREF="#">[20]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[20]</SUP> The
			<TT><FONT COLOR="#cc0000">\L</FONT></TT> and <TT><FONT COLOR="#cc0000">\u</FONT></TT>
			may appear together in either order. Larry realized that people
			would sometimes get those two backwards, so he made Perl figure
			out that you want just the first letter capitalized and the rest
			lowercase. Larry is a pretty nice guy.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">s/(fred|barney)/\u\L$1/ig;  # $_ is now &quot;I saw Fred with Barney.&quot;</FONT></PRE><P>
			As it happens, although we're covering case shifting in relation
			to substitutions, it's available in any double-quotish string: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><A NAME="IXTR3-56"></A><A NAME="IXTR3-57"></A><FONT COLOR="#cc0000">print &quot;Hello, \L\u$name\E, would you like to play a game?\n&quot;;</FONT></PRE><P>
			<A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic21" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-7"></A>9.7 The split Operator</H3>
			<P><A NAME="IXT-9-336268"></A>Another operator that uses regular
			expressions is <TT><FONT COLOR="#cc0000">split</FONT></TT>, which
			breaks up a string according to a separator. This is useful for
			tab-separated data, or colon-separated, whitespace-separated, or
			anything-separated data, really.<A HREF="#">[21]</A> So long as
			you can specify the separator with a regular expression (and
			generally, it's a simple regular expression), you can use <TT><FONT COLOR="#cc0000">split</FONT></TT>.
			It looks like this: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[21]</SUP>
			Except &quot;comma-separated values,&quot; normally called CSV
			files. Those are a pain to do with <TT><FONT COLOR="#cc0000">split</FONT></TT>;
			you're better off getting the <TT><FONT COLOR="#cc0000">Text::CSV</FONT></TT>
			module from CPAN.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">@fields = split /separator/, $string;</FONT></PRE><P>
			The <TT><FONT COLOR="#cc0000">split</FONT></TT> operator<A HREF="#">[22]</A>
			drags the pattern through a string and returns a list of fields
			(substrings) that were separated by the separators. Whenever the
			pattern matches, that's the end of one field and the start of the
			next. So, anything that matches the pattern will never show up in
			the returned fields. Here's a typical <TT><FONT COLOR="#cc0000">split</FONT></TT>
			pattern, splitting on colons: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[22]</SUP>
			It's an operator, even though it acts a lot like a function, and
			everyone generally calls it a function. But the technical details
			of the difference are beyond the scope of this book.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">@fields = split /:/, &quot;abc:def:g:h&quot;;  # gives (&quot;abc&quot;, &quot;def&quot;, &quot;g&quot;, &quot;h&quot;)</FONT></PRE><P>
			You could even have an empty field, if there were two delimiters
			together: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">@fields = split /:/, &quot;abc:def::g:h&quot;;  # gives (&quot;abc&quot;, &quot;def&quot;, &quot;&quot;, &quot;g&quot;, &quot;h&quot;)</FONT></PRE><P>
			Here's a rule that seems odd at first, but it rarely causes
			problems: Leading empty fields are always returned, but trailing
			empty fields are discarded:<A HREF="#">[23]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[23]</SUP>
			This is merely the default. It's this way for efficiency. If you
			worry about losing trailing empty fields, use <TT><FONT COLOR="#cc0000">-1</FONT></TT>
			as a third argument to <TT><FONT COLOR="#cc0000">split</FONT></TT>
			and they'll be kept; see the perlfunc manpage.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">@fields = split /:/, &quot;:::a:b:c:::&quot;;  # gives (&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</FONT></PRE><P>
			<A NAME="IXT-9-336269"></A>It's also common to <TT><FONT COLOR="#cc0000">split</FONT></TT>
			on whitespace, using <TT><FONT COLOR="#cc0000">/\s+/</FONT></TT>
			as the pattern. Under that pattern, all whitespace runs are
			equivalent to a single space: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $some_input = &quot;This  is a \t        test.\n&quot;;</FONT>
<FONT COLOR="#cc0000">my @args = split /\s+/, $some_input;  # (&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test.&quot;)</FONT></PRE><P>
			The default for <TT><FONT COLOR="#cc0000">split</FONT></TT> is to
			break up <TT><FONT COLOR="#cc0000">$_</FONT></TT> on whitespace: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my @fields = split;  # like split /\s+/, $_;</FONT></PRE><P>
			This is almost the same as using <TT><FONT COLOR="#cc0000">/\s+/</FONT></TT>
			as the pattern, except that a leading empty field is
			suppressed&iuml;&frac34;—so, if the line starts with whitespace,
			you won't see an empty field at the start of the list. (If you'd
			like to get the same behavior when splitting another string on
			whitespace, just use a single space in place of the pattern: <TT><FONT COLOR="#cc0000">split</FONT></TT>
			<TT><FONT COLOR="#cc0000">' ', $other_string</FONT></TT>. Using a
			space instead of the pattern is a special kind of <TT><FONT COLOR="#cc0000">split</FONT></TT>.)
			
			</P>
			<P><A NAME="IXT-9-336270"></A>Generally, the patterns used for
			<TT><FONT COLOR="#cc0000">split</FONT></TT> are as simple as the
			ones you see here. But if the pattern becomes more complex, be
			sure to avoid using memory parentheses in the pattern; see the
			<TT><FONT COLOR="#cc0000">perlfunc</FONT></TT> manpage for more
			information.<A HREF="#">[24]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[24]</SUP> And
			you might want to check out the nonmemory grouping-only
			parenthesis notation as well, in the perlre manpage.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic22" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-8"></A>9.8 The join Function</H3>
			<P><A NAME="IXT-9-336271"></A><A NAME="IXT-9-336272"></A>The <TT><FONT COLOR="#cc0000">join</FONT></TT>
			function doesn't use patterns. So why is it in this chapter? It's
			here because, in a sense, <TT><FONT COLOR="#cc0000">join</FONT></TT>
			performs the opposite function of <TT><FONT COLOR="#cc0000">split</FONT></TT>:
			<TT><FONT COLOR="#cc0000">split</FONT></TT> breaks up a string
			into a number of pieces, and <TT><FONT COLOR="#cc0000">join</FONT></TT>
			glues together a bunch of pieces to make a single string. The <TT><FONT COLOR="#cc0000">join</FONT></TT>
			function looks like this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $result = join $glue, @pieces;</FONT></PRE><P>
			The first argument to <TT><FONT COLOR="#cc0000">join</FONT></TT>
			is the glue, which may be any string. The remaining arguments are
			a list of pieces. <TT><FONT COLOR="#cc0000">join</FONT></TT> puts
			the glue string between the pieces and returns the resulting
			string: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $x = join &quot;:&quot;, 4, 6, 8, 10, 12;  # $x is &quot;4:6:8:10:12&quot;</FONT></PRE><P>
			In that example, we had five items, so there are only four colons.
			That is, there are four pieces of glue. The glue shows up only
			between the pieces, never before or after them. So, there will be
			one fewer piece of glue than the number of items in the list. 
			</P>
			<P>This means that there may be no glue at all, if the list
			doesn't have at least two elements: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $y = join &quot;foo&quot;, &quot;bar&quot;;       # gives just &quot;bar&quot;, since no fooglue is needed</FONT>
<FONT COLOR="#cc0000">my @empty;                       # empty array</FONT>
<FONT COLOR="#cc0000">my $empty = join &quot;baz&quot;, @empty;  # no items, so it's an empty string</FONT></PRE><P>
			Using <TT><FONT COLOR="#cc0000">$x</FONT></TT> from above, we can
			break up a string and put it back together with a different
			delimiter: 
			</P>
			<PRE><FONT COLOR="#cc0000">my @values = split /:/, $x;  # @values is (4, 6, 8, 10, 12)</FONT>
<FONT COLOR="#cc0000">my $z = join &quot;-&quot;, @values;   # $z is &quot;4-6-8-10-12&quot;</FONT></PRE><P>
			Although <TT><FONT COLOR="#cc0000">split</FONT></TT> and <TT><FONT COLOR="#cc0000">join</FONT></TT>
			work well together, don't forget that the first argument to <TT><FONT COLOR="#cc0000">join</FONT></TT>
			is always a string, not a pattern. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic23" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-9-SECT-9"></A>9.9 Exercises</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-8#lperl3-APP-A-SECT-8">Section
			A.8</A> for answers to the following exercises: 
			</P>
			<OL>
				<LI><P>[7] Make a pattern that will match three consecutive
				copies of whatever is currently contained in <TT><FONT COLOR="#cc0000">$what</FONT></TT>.
				That is, if <TT><FONT COLOR="#cc0000">$what</FONT></TT> is <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
				your pattern should match <TT><FONT COLOR="#cc0000">fredfredfred</FONT></TT>.
				If <TT><FONT COLOR="#cc0000">$what</FONT></TT> is <TT><FONT COLOR="#cc0000">fred|barney</FONT></TT>,
				your pattern should match <TT><FONT COLOR="#cc0000">fredfredbarney</FONT></TT>
				or <TT><FONT COLOR="#cc0000">barneyfredfred</FONT></TT> or
				<TT><FONT COLOR="#cc0000">barneybarneybarney</FONT></TT> or many
				other variations. (Hint: You should set <TT><FONT COLOR="#cc0000">$what</FONT></TT>
				at the top of the pattern test program with a statement like <TT><FONT COLOR="#cc0000">my
				$what = 'fred|barney';</FONT></TT>.) 
				</P>
				<LI><P>[15] Write a program that looks through the <TT><FONT COLOR="#cc0000">perlfunc.pod</FONT></TT>
				file for lines that start with <TT><FONT COLOR="#cc0000">=item</FONT></TT>
				and some whitespace, followed by a Perl identifier name (made of
				letters, digits, and underscores, but never starting with a
				digit), like the lines below. (There may be more text on the line
				after the identifier name; just ignore it.) You can locate the
				<TT><FONT COLOR="#cc0000">perlfunc.pod</FONT></TT> file on your
				system with the command <TT><FONT COLOR="#cc0000">perldoc -l
				perlfunc</FONT></TT>, or ask your local expert. (Hint: You'll
				need the diamond operator to open this file. How will it get the
				filename?) Have the program print each identifier name as it
				finds it; there will be hundreds of them, and many will appear
				more than once in the file. 
				</P>
				<P>As an example, the following lines of input resemble what
				you'll find in <TT><FONT COLOR="#cc0000">perlfunc.pod</FONT></TT>.
				For the first line, the program should print <TT><FONT COLOR="#cc0000">wilma</FONT></TT>.
				For the second, it should print <TT><FONT COLOR="#cc0000">fred</FONT></TT>
				(ignoring the word <TT><FONT COLOR="#cc0000">flintstone</FONT></TT>,
				since we're interested only in the identifier name): 
				</P>
				<PRE STYLE="font-weight: medium"><FONT COLOR="#cc0000">=item wilma </FONT>
<FONT COLOR="#cc0000">=item fred flintstone</FONT></PRE>
				<LI><P><A NAME="IXTR3-58"></A>[10] Modify the previous program to
				list only the identifier names that appear more than twice on
				those <TT><FONT COLOR="#cc0000">=item</FONT></TT> lines, and tell
				how many times each one appeared. (That is, we want to know which
				identifier names appear on at least three separate <TT><FONT COLOR="#cc0000">=item</FONT></TT>
				lines in the file.) There should be a couple of dozen, depending
				upon your version of Perl. 
				</P>
			</OL>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic24" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H2><A NAME="lperl3-CHP-10"></A>Chapter 10. More Control
			Structures</H2>
			<P><A NAME="lperl3-IDXTERM-634"></A>In this chapter, we'll see
			some alternative ways to write Perl code. For the most part, these
			techniques don't make the language more powerful, but they make it
			easier or more convenient to get the job done. You don't have to
			use these techniques in your own code, but don't be tempted to
			skip this chapter&iuml;&frac34;—you're certain to see these
			control structures in other people's code, sooner or later (in
			fact, you're absolutely certain to see these things in use by the
			time you finish reading this book). 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-1"></A>10.1 The unless Control
			Structure</H3>
			<P><A NAME="IXT-10-336273"></A><A NAME="IXT-10-336274"></A>In an
			<TT><FONT COLOR="#cc0000">if</FONT></TT> control structure, the
			block of code is executed only when the conditional expression is
			true. If you want a block of code to be executed only when the
			conditional is false, change <TT><FONT COLOR="#cc0000">if</FONT></TT>
			to <TT><FONT COLOR="#cc0000">unless</FONT></TT> : 
			</P>
			<PRE><FONT COLOR="#cc0000">unless ($fred =~ /^[A-Z_]\w*$/i) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value of \$fred doesn't look like a Perl identifier name.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Using <TT><FONT COLOR="#cc0000">unless</FONT></TT> says to run the
			block of code unless this condition is true. It's just like using
			an <TT><FONT COLOR="#cc0000">if</FONT></TT> test with the opposite
			condition. Another way to say it is that it's like having the <TT><FONT COLOR="#cc0000">else</FONT></TT>
			clause on its own. That is, whenever you see an <TT><FONT COLOR="#cc0000">unless</FONT></TT>
			that you don't understand, you can rewrite it (either in your head
			or in reality) to be an <TT><FONT COLOR="#cc0000">if</FONT></TT>
			test: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ($fred =~ /^[A-Z_]\w*$/i) {</FONT>
<FONT COLOR="#cc0000">  # Do nothing</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value of \$fred doesn't look like a Perl identifier name.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-10-336275"></A>It's no more or less efficient, and it
			should compile to the same internal byte codes. Or, another way to
			rewrite it would be to negate the conditional expression by using
			the negation operator (<TT><FONT COLOR="#cc0000">!</FONT></TT>): 
			</P>
			<PRE><FONT COLOR="#cc0000">if ( ! ($fred =~ /^[A-Z_]\w*$/i) ) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value of \$fred doesn't look like a Perl identifier name.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Generally, you should pick the way of writing code that makes the
			most sense to you, since that will probably make the most sense to
			your maintenance programmer. If it makes the most sense to write
			<TT><FONT COLOR="#cc0000">if</FONT></TT> with a negation, do that.
			More often, however, you'll probably find it natural to use
			<TT><FONT COLOR="#cc0000">unless</FONT></TT>. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-1.1"></A>10.1.1 The else Clause
			with unless</H4>
			<P><A NAME="IXT-10-336276"></A>You could even have an <TT><FONT COLOR="#cc0000">else</FONT></TT>
			clause with an <TT><FONT COLOR="#cc0000">unless</FONT></TT>. While
			this syntax is supported, it's potentially confusing: 
			</P>
			<PRE><FONT COLOR="#cc0000">unless ($mon =~ /^(Feb)/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;This month has at least thirty days.\n&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;Do you see what's going on here?\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-10-336277"></A>Some people may wish to use this,
			especially when the first clause is very short (perhaps only one
			line) and the second is several lines of code. But we'd make this
			one a negated <TT><FONT COLOR="#cc0000">if</FONT></TT>, or maybe
			simply swap the clauses to make a normal <TT><FONT COLOR="#cc0000">if</FONT></TT>:
			
			</P>
			<PRE><FONT COLOR="#cc0000">if ($mon =~ /^(Feb)/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;Do you see what's going on here?\n&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;This month has at least thirty days.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-10-336278"></A><A NAME="IXT-10-336279"></A>It's
			important to remember that you're always writing code for two
			readers: the computer that will run the code and the human being
			who has to keep the code working. If the human can't understand
			what you've written, pretty soon the computer won't be doing the
			right thing either. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-2"></A>10.2 The until Control
			Structure</H3>
			<P><A NAME="IXT-10-336280"></A><A NAME="IXT-10-336281"></A>Sometimes
			you'll want to reverse the condition of a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop. To do that, just use <TT><FONT COLOR="#cc0000">until</FONT></TT>:
			
			</P>
			<PRE><FONT COLOR="#cc0000">until ($j &gt; $i) {</FONT>
<FONT COLOR="#cc0000">  $j *= 2;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			This loop runs until the conditional expression returns true. But
			it's really just a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop in disguise, except that this one repeats as long as the
			conditional is false, rather than true. The conditional expression
			is evaluated before the first iteration, so this is still a
			zero-or-more-times loop, just like the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop.<A HREF="#">[1]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP>
			Pascal programmers, take note: in Pascal, the repeat-until always
			runs at least one iteration, but an <TT><FONT COLOR="#cc0000">until</FONT></TT>
			loop in Perl may not run at all, if the conditional expression is
			true before the loop starts.</P>
			<P>As with <TT><FONT COLOR="#cc0000">if</FONT></TT> and <TT><FONT COLOR="#cc0000">unless</FONT></TT>,
			you could rewrite any <TT><FONT COLOR="#cc0000">until</FONT></TT>
			loop to become a <TT><FONT COLOR="#cc0000">while</FONT></TT> loop
			by negating the condition. But generally, you'll find it simple
			and natural to use <TT><FONT COLOR="#cc0000">until</FONT></TT>
			from time to time. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-3"></A>10.3 Expression Modifiers</H3>
			<P><A NAME="IXT-10-336282"></A><A NAME="IXT-10-336283"></A>In
			order to have a more compact notation, an expression may be
			followed by a modifier that controls it. For example, the <TT><FONT COLOR="#cc0000">if</FONT></TT>
			modifier works in a way analogous to an <TT><FONT COLOR="#cc0000">if</FONT></TT>
			block: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print &quot;$n is a negative number.\n&quot; if $n &lt; 0;</FONT></PRE><P>
			That gives exactly the same result as if we had used this code,
			except that we saved some typing by leaving out the parentheses
			and curly braces:<A HREF="#">[2]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> We
			also left out the line breaks. But we should mention that the
			curly-brace form does create a new scope. In the rare case that
			you need the full details, check the documentation.</P>
			<PRE><FONT COLOR="#cc0000">if ($n &lt; 0) {</FONT>
<FONT COLOR="#cc0000">  print &quot;$n is a negative number.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			As we've said, Perl folks generally like to avoid typing. And the
			shorter form reads like in English: print this message, if <TT><FONT COLOR="#cc0000">$n</FONT></TT>
			is less than zero. 
			</P>
			<P><A NAME="IXT-10-336284"></A>Notice that the conditional
			expression is still evaluated first, even though it's written at
			the end. This is backwards from the usual left-to-right ordering;
			in understanding Perl code, we'll have to do as Perl's internal
			compiler does, and read to the end of the statement before we can
			tell what it's really doing. 
			</P>
			<P><A NAME="IXT-10-336285"></A><A NAME="IXT-10-336286"></A><A NAME="IXT-10-336287"></A><A NAME="IXT-10-336288"></A>
			There are other modifiers as well: 
			</P>
			<PRE><FONT COLOR="#cc0000">&amp;error(&quot;Invalid input&quot;) unless &amp;valid($input);</FONT>
<FONT COLOR="#cc0000">$i *= 2 until $i &gt; $j;</FONT>
<FONT COLOR="#cc0000">print &quot; &quot;, ($n += 2) while $n &lt; 10;</FONT>
<FONT COLOR="#cc0000">&amp;greet($_) foreach @person;</FONT></PRE><P>
			These all work just as (we hope) you would expect. That is, each
			one could be rewritten in a similar way to rewriting the
			<TT><FONT COLOR="#cc0000">if</FONT></TT>-modifier example earlier.
			Here is one: 
			</P>
			<PRE><FONT COLOR="#cc0000">while ($n &lt; 10) {</FONT>
<FONT COLOR="#cc0000">  print &quot; &quot;, ($n += 2);</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The expression in parentheses inside the <TT><FONT COLOR="#cc0000">print</FONT></TT>
			argument list is noteworthy because it adds two to <TT><FONT COLOR="#cc0000">$n</FONT></TT>,
			storing the result back into <TT><FONT COLOR="#cc0000">$n</FONT></TT>.
			Then it returns that new value, which will be printed. 
			</P>
			<P>These shorter forms read almost like a natural language: call
			the <TT><FONT COLOR="#cc0000">&amp;greet</FONT></TT> subroutine
			for each <TT><FONT COLOR="#cc0000">@person</FONT></TT> in the
			list. Double <TT><FONT COLOR="#cc0000">$i</FONT></TT> until it's
			larger than <TT><FONT COLOR="#cc0000">$j</FONT></TT>.<A HREF="#">[3]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP>
			Well, it helps us to think of them like that.</P>
			<P>One of the common uses of these modifiers is in a statement
			like this one: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print &quot;fred is '$fred', barney is '$barney'\n&quot;           if $I_am_curious;</FONT></PRE><P>
			By writing the code &quot;in reverse&quot; like this, you can put
			the important part of the statement at the beginning. The point of
			that statement is to monitor some variables; the point is not to
			check whether you're curious.<A HREF="#">[4]</A> Some people
			prefer to write the whole statement on one line, perhaps with some
			tab characters before the <TT><FONT COLOR="#cc0000">if</FONT></TT>,
			to move it over toward the right margin, as we showed in the
			previous example, while others put the <TT><FONT COLOR="#cc0000">if</FONT></TT>
			modifier indented on a new line: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP> Of
			course, we made up the name <TT><FONT COLOR="#cc0000">$I_am_curious</FONT></TT>;
			it's not a builtin Perl variable. Generally, folks who use this
			technique will either call their variable <TT><FONT COLOR="#cc0000">$TRACING</FONT></TT>,
			or will use a constant declared with the <TT><FONT COLOR="#cc0000">constant</FONT></TT>
			pragma.</P>
			<PRE><FONT COLOR="#cc0000">print &quot;fred is '$fred', barney is '$barney'\n&quot;</FONT>
<FONT COLOR="#cc0000">    if $I_am_curious;</FONT></PRE><P>
			<A NAME="IXT-10-336289"></A><A NAME="IXT-10-336290"></A><A NAME="IXT-10-336291"></A><A NAME="IXT-10-336292"></A>
			Although you can rewrite any of these expressions with modifiers
			as a block (the &quot;old-fashioned&quot; way), the converse isn't
			necessarily true. Only a single expression is allowed on either
			side of the modifier. So you can't write something <TT><FONT COLOR="#cc0000">if</FONT></TT>
			something <TT><FONT COLOR="#cc0000">while</FONT></TT> something
			<TT><FONT COLOR="#cc0000">until</FONT></TT> something <TT><FONT COLOR="#cc0000">unless</FONT></TT>
			something <TT><FONT COLOR="#cc0000">foreach</FONT></TT> something,
			which would just be too confusing. And you can't put multiple
			statements on the left of the modifier. If you need more than just
			a simple expression on each side, just write the code the
			old-fashioned way, with the parentheses and curly braces. 
			</P>
			<P>As we mentioned in relation to the <TT><FONT COLOR="#cc0000">if</FONT></TT>
			modifier, the control expression (on the right) is always
			evaluated first, just as it would be in the old-fashioned form. 
			</P>
			<P>With the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			modifier, there's no way to choose a different control
			variable&iuml;&frac34;—it's always <TT><FONT COLOR="#cc0000">$_</FONT></TT>.
			Usually, that's no problem, but if you want to use a different
			variable, you'll need to rewrite it as a traditional <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic25" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-4"></A>10.4 The Naked Block
			Control Structure</H3>
			<P><A NAME="IXT-10-336293"></A><A NAME="IXT-10-336294"></A>The
			so-called &quot;naked&quot; block is one without a keyword or
			condition. That is, suppose you start with a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop, which looks something like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">while (condition) {</FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Now, take away the <TT><FONT COLOR="#cc0000">while</FONT></TT>
			keyword and the conditional expression, and you'll have a naked
			block: 
			</P>
			<PRE><FONT COLOR="#cc0000">{</FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-10-336295"></A>The naked block is like a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			or <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop, except that
			it doesn't loop; it just executes the body of the loop once, and
			it's done. It's an un-loop! 
			</P>
			<P>We'll see in a while that there are other uses for the naked
			block, but one of its features is that it provides a scope for
			temporary lexical variables: 
			</P>
			<PRE><FONT COLOR="#cc0000">{</FONT>
<FONT COLOR="#cc0000">  print &quot;Please enter a number: &quot;;</FONT>
<FONT COLOR="#cc0000">  chomp(my $n = &lt;STDIN&gt;);</FONT>
<FONT COLOR="#cc0000">  my $root = sqrt $n;  # calculate the square root</FONT>
<FONT COLOR="#cc0000">  print &quot;The square root of $n is $root.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-10-336296"></A>In this block, <TT><FONT COLOR="#cc0000">$n</FONT></TT>
			and <TT><FONT COLOR="#cc0000">$root</FONT></TT> are temporary
			variables scoped to the block. As a general guideline, all
			variables should be declared in the smallest scope available. If
			you need a variable for just a few lines of code, you can put
			those lines into a naked block and declare the variable inside
			that block. Of course, if we would need the value of either <TT><FONT COLOR="#cc0000">$n</FONT></TT>
			or <TT><FONT COLOR="#cc0000">$root</FONT></TT> later, we would
			need to declare them in a larger scope. 
			</P>
			<P><A NAME="IXT-10-336297"></A><A NAME="IXT-10-336298"></A>You may
			have noticed the <TT><FONT COLOR="#cc0000">sqrt</FONT></TT>
			function in that code and wondered about it&iuml;&frac34;—yes,
			it's a function we haven't shown before. Perl has many builtin
			functions that are beyond the scope of this book. When you're
			ready, check the perlfunc manpage to learn about more of them. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-5"></A>10.5 The elsif Clause</H3>
			<P><A NAME="IXT-10-336299"></A>Every so often, you may need to
			check a number of conditional expressions, one after another, to
			see which one of them is true. This can be done with the <TT><FONT COLOR="#cc0000">if</FONT></TT>
			control structure's <TT><FONT COLOR="#cc0000">elsif</FONT></TT>
			clause, as in this example: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ( ! defined $dino) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value is undef.\n&quot;;</FONT>
<FONT COLOR="#cc0000">} elsif ($dino =~ /^-?\d+\.?$/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value is an integer.\n&quot;;</FONT>
<FONT COLOR="#cc0000">} elsif ($dino =~ /^-?\d*\.\d+$/) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value is a _simple_ floating-point number.\n&quot;;</FONT>
<FONT COLOR="#cc0000">} elsif ($dino eq '') {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value is the empty string.\n&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;The value is the string '$dino'.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Perl will test the conditional expressions one after another. When
			one succeeds, the corresponding block of code is executed, and
			then the whole control structure is done,<A HREF="#">[6]</A> and
			execution goes on to the rest of the program. If none has
			succeeded, the <TT><FONT COLOR="#cc0000">else</FONT></TT> block at
			the end is executed. (Of course, the <TT><FONT COLOR="#cc0000">else</FONT></TT>
			clause is still optional, although in this case it's often a good
			idea to include it.) 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP>
			There's no &quot;fall-through&quot; to the next block, as in the
			&quot;switch&quot; structure of languages like C.</P>
			<P><A NAME="IXT-10-336300"></A>There's no limit to the number of
			<TT><FONT COLOR="#cc0000">elsif</FONT></TT> clauses, but remember
			that Perl has to evaluate the first ninety-nine tests before it
			can get to the hundredth. If you'll have more than half a dozen
			<TT><FONT COLOR="#cc0000">elsif</FONT></TT>s, you should consider
			whether there's a more efficient way to write it. The Perl FAQ
			(see the <TT><FONT COLOR="#cc0000">perlfaq</FONT></TT> manpage)
			has a number of suggestions for emulating the &quot;case&quot; or
			&quot;switch&quot; statements of other languages. 
			</P>
			<P>You may have noticed by this point that the keyword is spelled
			<TT><FONT COLOR="#cc0000">elsif</FONT></TT>, with only one <TT><FONT COLOR="#cc0000">e</FONT></TT>.
			If you write it as &quot;elseif&quot;, with a second <TT><FONT COLOR="#cc0000">e</FONT></TT>,
			Perl will tell you that it is not the correct spelling. Why not?
			Because Larry says so.<A HREF="#">[7]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP> In
			fact, he resists any suggestion that it even be permitted as a
			valid alternative spelling. &quot;If you want to spell it with a
			second <TT><FONT COLOR="#cc0000">e</FONT></TT>, it's simple. Step
			1&iuml;&frac34;—Make up your own language. Step 2&iuml;&frac34;—Make
			it popular.&quot; When you make your own programming language, you
			can spell the keywords in any way you'd like. We hope that you
			will decide that yours shouldn't be the first to have an
			&quot;elseunless&quot;.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic26" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-6"></A>10.6 Autoincrement and
			Autodecrement</H3>
			<P><A NAME="lperl3-IDXTERM-663"></A><A NAME="lperl3-IDXTERM-664"></A><A NAME="IXT-10-336301"></A><A NAME="IXT-10-336302"></A><A NAME="IXT-10-336303"></A>
			You'll often want a scalar variable to count up or down by one.
			Since these are frequent constructs, there are shortcuts for them,
			like nearly everything else we do frequently. 
			</P>
			<P>The autoincrement operator (&quot;<TT><FONT COLOR="#cc0000">++</FONT></TT>&quot;)
			adds one to a scalar variable, like the same operator in C and
			similar languages: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $bedrock = 42;</FONT>
<FONT COLOR="#cc0000">$bedrock++;  # add one to $bedrock; it's now 43</FONT></PRE><P>
			Just like other ways of adding one to a variable, the scalar will
			be created if necessary: 
			</P>
			<PRE><FONT COLOR="#cc0000">my @people = qw{ fred barney fred wilma dino barney fred pebbles };</FONT>
<FONT COLOR="#cc0000">my %count;                     # new empty hash</FONT>
<FONT COLOR="#cc0000">$count{$_}++ foreach @people;  # creates new keys and values as needed</FONT></PRE><P>
			The first time through that <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, <TT><FONT COLOR="#cc0000">$count{$_}</FONT></TT> is
			incremented. That's <TT><FONT COLOR="#cc0000">$count{&quot;fred&quot;}</FONT></TT>,
			which thus goes from <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			(since it didn't previously exist in the hash) up to <TT><FONT COLOR="#cc0000">1</FONT></TT>.
			The next time through the loop, <TT><FONT COLOR="#cc0000">$count{&quot;barney&quot;}</FONT></TT>
			becomes <TT><FONT COLOR="#cc0000">1</FONT></TT>; after that,
			<TT><FONT COLOR="#cc0000">$count{&quot;fred&quot;}</FONT></TT>
			becomes <TT><FONT COLOR="#cc0000">2</FONT></TT>. Each time through
			the loop, one element in <TT><FONT COLOR="#cc0000">%count</FONT></TT>
			is incremented, and possibly created as well. After that loop is
			done, <TT><FONT COLOR="#cc0000">$count{&quot;fred&quot;}</FONT></TT>
			is <TT><FONT COLOR="#cc0000">3</FONT></TT>. This provides a quick
			and easy way to see which items are in a list and how many times
			each one appears. 
			</P>
			<P>Similarly, the autodecrement operator (&quot;<TT><FONT COLOR="#cc0000">--</FONT></TT>&quot;)
			subtracts one from a scalar variable: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$bedrock--;  # subtract one from $bedrock; it's 42 again</FONT></PRE><H4>
			<A NAME="lperl3-CHP-10-SECT-6.1"></A>10.6.1 The Value of
			Autoincrement</H4>
			<P><A NAME="IXT-10-336304"></A>You can fetch the value of a
			variable and change that value at the same time. Put the <TT><FONT COLOR="#cc0000">++</FONT></TT>
			operator in front of the variable name to increment the variable
			first and then fetch its value. This is a <I>preincrement</I>: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $a = 5;</FONT>
<FONT COLOR="#cc0000">my $b = ++$a;  # increment $a to 6, and put that value into $b</FONT></PRE><P>
			Or put the <TT><FONT COLOR="#cc0000">--</FONT></TT> operator in
			front to decrement the variable first and then fetch its value.
			This is a <I>predecrement</I>: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $c = --$a;  # decrement $a to 5, and put that value into $c</FONT></PRE><P>
			<A NAME="IXT-10-336305"></A>Here's the tricky part. Put the
			variable name first to fetch the value first, and then do the
			increment or decrement. This is called a <I>postincrement</I> or
			<I>postdecrement</I>: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $d = $a++;  # $d gets the old value (5), then increment $a to 6</FONT>
<FONT COLOR="#cc0000">my $e = $a--;  # $e gets the old value (6), then decrement $a to 5</FONT></PRE><P>
			It's tricky because we're doing two things at once. We're fetching
			the value, and we're changing it in the same expression. If the
			operator is first, we increment (or decrement) first, then use the
			new value. If the variable is first, we return its (old) value
			first, then do the increment or decrement. Another way to say it
			is that these operators return a value, but they also have the
			side effect of modifying the variable's value. 
			</P>
			<P>If you write these in an expression of their own,<A HREF="#">[8]</A>
			not using the value but only the side effect, there's no
			difference<A HREF="#">[9]</A> whether you put the operator before
			or after the variable: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> That
			is, in a void context. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP>
			Programmers who get inside the implementations of languages may
			expect that postincrement and postdecrement would be less
			efficient than their counterparts, but Perl's not like that. Perl
			automatically optimizes the post- forms when they're used in a
			void context.</P>
			<PRE><FONT COLOR="#cc0000">$bedrock++;  # adds one to $bedrock</FONT>
<FONT COLOR="#cc0000">++$bedrock;  # just the same; adds one to $bedrock</FONT></PRE><P>
			<A NAME="IXT-10-336306"></A>A common use of these operators is in
			connection with a hash, to identify when an item has been seen
			before: 
			</P>
			<PRE><FONT COLOR="#cc0000">my @people = qw{ fred barney bamm-bamm wilma dino barney betty pebbles };</FONT>
<FONT COLOR="#cc0000">my %seen;</FONT>

<FONT COLOR="#cc0000">foreach (@people) {</FONT>
<FONT COLOR="#cc0000">  print &quot;I've seen you somewhere before, $_!\n&quot;</FONT>
<FONT COLOR="#cc0000">    if $seen{$_}++;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXTR3-59"></A><A NAME="IXTR3-60"></A>When <TT><FONT COLOR="#cc0000">barney</FONT></TT>
			shows up for the first time, the value of <TT><FONT COLOR="#cc0000">$seen{$_}++</FONT></TT>
			is false, since it's the value of <TT><FONT COLOR="#cc0000">$seen{$_}</FONT></TT>,
			which is <TT><FONT COLOR="#cc0000">$seen{&quot;barney&quot;}</FONT></TT>,
			which is <TT><FONT COLOR="#cc0000">undef</FONT></TT>. But that
			expression has the side effect of incrementing <TT><FONT COLOR="#cc0000">$seen{&quot;barney&quot;}</FONT></TT>.
			When <TT><FONT COLOR="#cc0000">barney</FONT></TT> shows up again,
			<TT><FONT COLOR="#cc0000">$seen{&quot;barney&quot;}</FONT></TT> is
			now a true value, so the message is printed. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic27" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-7"></A>10.7 The for Control
			Structure</H3>
			<P><A NAME="lperl3-IDXTERM-673"></A><A NAME="lperl3-IDXTERM-674"></A>
			Perl's <TT><FONT COLOR="#cc0000">for</FONT></TT> control structure
			is like the common <TT><FONT COLOR="#cc0000">for</FONT></TT>
			control structure you may have seen in other languages such as C.
			It looks like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">for (<I>initialization; test; increment</I>) {</FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			To Perl, though, this kind of loop is really a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop in disguise, something like this:<A HREF="#">[10]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-10-336307"></A><A NAME="IXT-10-336308"></A>
			<SUP>[10]</SUP> Actually, the increment happens in a <TT><FONT COLOR="#cc0000">continue</FONT></TT>
			block, which is beyond the scope of this book. See the perlsyn
			manpage for the truth.</P>
			<PRE><FONT COLOR="#cc0000"><I>initialization;</I></FONT>
<FONT COLOR="#cc0000">while (<I>test</I>) {</FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">  <I>body;</I></FONT>
<FONT COLOR="#cc0000">  <I>increment;</I></FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The most common use of the <TT><FONT COLOR="#cc0000">for</FONT></TT>
			loop, by far, is for making computed iterations: 
			</P>
			<PRE><FONT COLOR="#cc0000">for ($i = 1; $i &lt;= 10; $i++) {  # count from 1 to 10</FONT>
<FONT COLOR="#cc0000">  print &quot;I can count to $i!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			When you've seen these before, you'll know what the first line is
			saying even before you read the comment. Before the loop starts,
			the control variable, <TT><FONT COLOR="#cc0000">$i</FONT></TT>, is
			set to <TT><FONT COLOR="#cc0000">1</FONT></TT>. Then, the loop is
			really a <TT><FONT COLOR="#cc0000">while</FONT></TT> loop in
			disguise, looping while <TT><FONT COLOR="#cc0000">$i</FONT></TT>
			is less than or equal to <TT><FONT COLOR="#cc0000">10</FONT></TT>.
			Between each iteration and the next is the increment, which here
			is a literal increment, adding one to the control variable, which
			is <TT><FONT COLOR="#cc0000">$i</FONT></TT>. 
			</P>
			<P>So, the first time through this loop, <TT><FONT COLOR="#cc0000">$i</FONT></TT>
			is <TT><FONT COLOR="#cc0000">1</FONT></TT>. Since that's less than
			or equal to <TT><FONT COLOR="#cc0000">10</FONT></TT>, we see the
			message. Although the increment is written at the top of the loop,
			it logically happens at the bottom of the loop, after printing the
			message. So, <TT><FONT COLOR="#cc0000">$i</FONT></TT> becomes <TT><FONT COLOR="#cc0000">2</FONT></TT>,
			which is less than or equal to <TT><FONT COLOR="#cc0000">10</FONT></TT>,
			so we print the message again, and <TT><FONT COLOR="#cc0000">$i</FONT></TT>
			is incremented to <TT><FONT COLOR="#cc0000">3</FONT></TT>, which
			is less than or equal to <TT><FONT COLOR="#cc0000">10</FONT></TT>,
			and so on. 
			</P>
			<P>Eventually, we print the message that our program can count to
			<TT><FONT COLOR="#cc0000">9</FONT></TT>. Then <TT><FONT COLOR="#cc0000">$i</FONT></TT>
			is incremented to <TT><FONT COLOR="#cc0000">10</FONT></TT>, which
			is less than or equal to <TT><FONT COLOR="#cc0000">10</FONT></TT>,
			so we run the loop one last time and print that our program can
			count to <TT><FONT COLOR="#cc0000">10</FONT></TT>. Finally, <TT><FONT COLOR="#cc0000">$i</FONT></TT>
			is incremented for the last time, to <TT><FONT COLOR="#cc0000">11</FONT></TT>,
			which is not less than or equal to <TT><FONT COLOR="#cc0000">10</FONT></TT>.
			So control drops out of the loop, and we're on to the rest of the
			program. 
			</P>
			<P>All three parts are together at the top of the loop so that
			it's easy for an experienced programmer to read that first line
			and say, &quot;Ah, it's a loop that counts <TT><FONT COLOR="#cc0000">$i</FONT></TT>
			from one to ten.&quot; 
			</P>
			<P>Note that after the loop is done, the control variable has a
			value &quot;after&quot; the loop. That is, in this case, the
			control variable has gone all the way to <TT><FONT COLOR="#cc0000">11.</FONT></TT><A HREF="#">[11]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP>
			Obligatory This is Spinal Tap outdated pop-culture reference.</P>
			<P>This loop is a very versatile loop, since you can make it count
			in all sorts of ways. This loop counts from <TT><FONT COLOR="#cc0000">-150</FONT></TT>
			to <TT><FONT COLOR="#cc0000">1000</FONT></TT> by threes:<A HREF="#">[12]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP> Of
			course, it never gets to <TT><FONT COLOR="#cc0000">1000</FONT></TT>
			exactly. The last iteration uses <TT><FONT COLOR="#cc0000">999</FONT></TT>,
			since each value of <TT><FONT COLOR="#cc0000">$i</FONT></TT> is a
			multiple of three.</P>
			<PRE><FONT COLOR="#cc0000">for ($i = -150; $i &lt;= 1000; $i += 3) {</FONT>
<FONT COLOR="#cc0000">  print &quot;$i\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			In fact, you could make any of the three control parts
			(initialization, test, or increment) empty, if you wish, but you
			still need the two semicolons. In this (quite unusual) example,
			the test is a substitution, and the increment is empty: 
			</P>
			<PRE><FONT COLOR="#cc0000">for ($_ = &quot;bedrock&quot;; s/(.)//; ) {  # loops while the s/// is successful</FONT>
<FONT COLOR="#cc0000">  print &quot;One character is: $1\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The test expression (in the implied <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop) is the substitution, which will return a true value if it
			succeeded. In this case, the first time through the loop, the
			substitution will remove the <TT><FONT COLOR="#cc0000">b</FONT></TT>
			from <TT><FONT COLOR="#cc0000">bedrock</FONT></TT>. Each iteration
			will remove another letter. When the string is empty, the
			substitution will fail, and the loop is done. 
			</P>
			<P>If the test expression (the one between the two semicolons) is
			empty, it's automatically true, making an infinite loop. But don't
			make an infinite loop like this until you see how to break out of
			such a loop, which we'll discuss later in this chapter: 
			</P>
			<PRE><FONT COLOR="#cc0000">for (;;) {</FONT>
<FONT COLOR="#cc0000">  print &quot;It's an infinite loop!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			A more Perl-like way to write an intentional infinite loop, when
			you really want one,<A HREF="#">[13]</A> is with <TT><FONT COLOR="#cc0000">while</FONT></TT>:
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP> If
			you somehow made an infinite loop that's gotten away from you, see
			whether Control-C will halt it. It's possible that you'll get a
			lot of output even after typing Control-C, depending upon your
			system's I/O and other factors. Hey, we warned you.</P>
			<PRE><FONT COLOR="#cc0000">while (1) {</FONT>
<FONT COLOR="#cc0000">  print &quot;It's another infinite loop!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXTR3-61"></A>Although C programmers are familiar with
			the first way, even a beginning Perl programmer should recognize
			that <TT><FONT COLOR="#cc0000">1</FONT></TT> is always true,
			making an intentional infinite loop, so the second is generally a
			better way to write it. Perl is smart enough to recognize a
			constant expression like that and optimize it away, so there's no
			difference in efficiency. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-7.1"></A>10.7.1 The Secret
			Connection Between foreach and for</H4>
			<P><A NAME="IXT-10-336309"></A><A NAME="IXT-10-336310"></A><A NAME="IXT-10-336311"></A>
			It turns out that, inside the Perl grammar, the keyword <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			is exactly equivalent to the keyword <TT><FONT COLOR="#cc0000">for</FONT></TT>.
			That is, any time Perl sees one of them, it's the same as if you
			had typed the other. Perl can tell which you meant by looking
			inside the parentheses. If you've got the two semicolons, it's a
			computed <TT><FONT COLOR="#cc0000">for</FONT></TT> loop (like
			we've just been talking about). If you don't have the semicolons,
			it's really a <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop: 
			</P>
			<PRE><FONT COLOR="#cc0000">for (1..10) {  # Really a foreach loop from 1 to 10</FONT>
<FONT COLOR="#cc0000">  print &quot;I can count to $_!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			That's really a <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, but it's written <TT><FONT COLOR="#cc0000">for</FONT></TT>.
			Except for that one example, all through this book, we'll spell
			out <TT><FONT COLOR="#cc0000">foreach</FONT></TT> wherever it
			appears. But in the real world, do you think that Perl folks will
			type those extra four letters?<A HREF="#">[14]</A> Excepting only
			beginners' code, it's always written <TT><FONT COLOR="#cc0000">for</FONT></TT>,
			and you'll have to do as Perl does and look for the semicolons to
			tell which kind of loop it is. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP> If
			you think that, you haven't been paying attention. Among
			programmers, especially Perl programmers, laziness is one of the
			classical virtues. If you don't believe us, ask someone at the
			next Perl Mongers' meeting.</P>
			<P>In Perl, the true <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop is almost always a better choice. In the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop (written <TT><FONT COLOR="#cc0000">for</FONT></TT>) in that
			previous example, it's easy to see at a glance that the loop will
			go from <TT><FONT COLOR="#cc0000">1</FONT></TT> to <TT><FONT COLOR="#cc0000">10</FONT></TT>.
			But do you see what's wrong with this computed loop that's trying
			to do the same thing? Don't peek at the answer in the footnote
			until you think you've found what's wrong:<A HREF="#">[15]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP>
			There are two and one-half bugs. First, the conditional uses a
			less-than sign, so the loop will run nine times, instead of ten.
			It's easy to get a so-called &quot;fencepost&quot; bug with this
			kind of loop, like what happened when the rancher needed enough
			fenceposts to make a 30-meter-long fence with a post every three
			meters. (The answer is not ten fenceposts.) Second, the control
			variable is <TT><FONT COLOR="#cc0000">$i</FONT></TT>, but the loop
			body is using <TT><FONT COLOR="#cc0000">$_</FONT></TT>. And second
			and a half, it's a lot more work to read, write, maintain, and
			debug this type of loop, which is why we say that the true <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			is generally a better choice in Perl.</P>
			<PRE><A NAME="IXTR3-62"></A><FONT COLOR="#cc0000">for ($i = 1; $i &lt; 10; $i++) {  # Oops! Something is wrong here!</FONT>
<FONT COLOR="#cc0000">  print &quot;I can count to $_!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-8"></A>10.8 Loop Controls</H3>
			<P><A NAME="lperl3-IDXTERM-681"></A><A NAME="lperl3-IDXTERM-682"></A><A NAME="IXT-10-336312"></A>
			As you've surely noticed by now, Perl is one of the so-called
			&quot;structured&quot; programming languages. In particular,
			there's just one entrance to any block of code, which is at the
			top of that block. But there are times when you may need more
			control or versatility than what we've shown so far. For example,
			you may need to make a loop like a <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop, but one that always runs at least once. Or maybe you need to
			occasionally exit a block of code early. Perl has three
			loop-control operators you can use in loop blocks to make the loop
			do all sorts of tricks. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-8.1"></A>10.8.1 The last Operator</H4>
			<P><A NAME="IXT-10-336313"></A><A NAME="IXT-10-336314"></A><A NAME="IXT-10-336315"></A><A NAME="IXT-10-336316"></A><A NAME="IXT-10-336317"></A>
			The <TT><FONT COLOR="#cc0000">last</FONT></TT> operator
			immediately ends execution of the loop. (If you've used the
			&quot;break&quot; operator in C or a similar language, it's like
			that.) It's the &quot;emergency exit&quot; for loop blocks. When
			you hit <TT><FONT COLOR="#cc0000">last</FONT></TT>, the loop is
			done. For example: 
			</P>
			<PRE><FONT COLOR="#cc0000"># Print all input lines mentioning fred, until the __END__ marker</FONT>
<FONT COLOR="#cc0000">while (&lt;STDIN&gt;) {</FONT>
<FONT COLOR="#cc0000">  if (/__END__/) {</FONT>
<FONT COLOR="#cc0000">    # No more input on or after this marker line</FONT>
<FONT COLOR="#cc0000">    last;</FONT>
<FONT COLOR="#cc0000">  } elsif (/fred/) {</FONT>
<FONT COLOR="#cc0000">    print;</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT>
<FONT COLOR="#cc0000">## last comes here ##</FONT></PRE><P>
			<A NAME="IXT-10-336318"></A>Once an input line has the <TT><FONT COLOR="#cc0000">__END__</FONT></TT>
			marker, that loop is done. Of course, that comment line at the end
			is merely a comment&iuml;&frac34;—it's not required in any way.
			We just threw that in to make it clearer what's happening. 
			</P>
			<P><A NAME="IXT-10-336319"></A>There are five kinds of loop blocks
			in Perl. These are the blocks of <TT><FONT COLOR="#cc0000">for</FONT></TT>,
			<TT><FONT COLOR="#cc0000">foreach</FONT></TT>, <TT><FONT COLOR="#cc0000">while</FONT></TT>,
			<TT><FONT COLOR="#cc0000">until</FONT></TT>, or the naked
			block.<A HREF="#">[16]</A> The curly braces of an <TT><FONT COLOR="#cc0000">if</FONT></TT>
			block or subroutine<A HREF="#">[17]</A> don't qualify. As you may
			have noticed in the example above, the <TT><FONT COLOR="#cc0000">last</FONT></TT>
			operator applied to the entire loop block. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP>
			Yes, you can use <TT><FONT COLOR="#cc0000">last</FONT></TT> to
			jump out of a naked block. Be sure to check your local laws before
			doing so.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP>
			It's probably not a good idea, but you could use these loop
			control operators from inside a subroutine to control a loop that
			is outside the subroutine. That is, if a subroutine is called in a
			loop block, and the subroutine executes <TT><FONT COLOR="#cc0000">last</FONT></TT>
			when there's no loop block running inside the subroutine, the flow
			of control will jump to just after the loop block in the main
			code. This ability to use loop control from within a subroutine
			may go away in a future version of Perl, and no one is likely to
			miss it.</P>
			<P>The <TT><FONT COLOR="#cc0000">last</FONT></TT> operator will
			apply to the innermost currently running loop block. To jump out
			of outer blocks, stay tuned; that's coming up in a little bit. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-8.2"></A>10.8.2 The next Operator</H4>
			<P><A NAME="lperl3-IDXTERM-691"></A><A NAME="IXT-10-336320"></A>Sometimes
			you're not ready for the loop to finish, but you're done with the
			current iteration. That's what the <TT><FONT COLOR="#cc0000">next</FONT></TT>
			operator is good for. It jumps to the inside of the bottom of the
			current loop block.<A HREF="#">[18]</A> After <TT><FONT COLOR="#cc0000">next</FONT></TT>,
			control continues with the next iteration of the loop (much like
			the &quot;continue&quot; operator in C or a similar language): 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-10-336321"></A><A NAME="IXT-10-336322"></A>
			<SUP>[18]</SUP> This is another of our many lies. In truth, <TT><FONT COLOR="#cc0000">next</FONT></TT>
			jumps to the start of the (usually omitted) <TT><FONT COLOR="#cc0000">continue</FONT></TT>
			block for the loop. See the perlsyn manpage for the full details.</P>
			<PRE><FONT COLOR="#cc0000"># Analyze words in the input file or files</FONT>
<FONT COLOR="#cc0000">while (&lt;&gt;) {</FONT>
<FONT COLOR="#cc0000">  foreach (split) {  # break $_ into words, assign each to $_ in turn</FONT>
<FONT COLOR="#cc0000">    $total++;</FONT>
<FONT COLOR="#cc0000">    next if /\W/;    # strange words skip the remainder of the loop</FONT>
<FONT COLOR="#cc0000">    $valid++;</FONT>
<FONT COLOR="#cc0000">    $count{$_}++;    # count each separate word</FONT>
<FONT COLOR="#cc0000">    ## next comes here ##</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT>

<FONT COLOR="#cc0000">print &quot;total things = $total, valid words = $valid\n&quot;;</FONT>
<FONT COLOR="#cc0000">foreach $word (sort keys %count) {</FONT>
<FONT COLOR="#cc0000">  print &quot;$word was seen $count{$word} times.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			This one is a little more complex than most of our examples up to
			this point, so let's take it step by step. The <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop is reading lines of input from the diamond operator, one
			after another, into <TT><FONT COLOR="#cc0000">$_</FONT></TT>;
			we've seen that before. Each time through that loop, another line
			of input will be in <TT><FONT COLOR="#cc0000">$_</FONT></TT>. 
			</P>
			<P>Inside that loop, the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop is iterating over the return value <TT><FONT COLOR="#cc0000">split</FONT></TT>.
			Do you remember the default for <TT><FONT COLOR="#cc0000">split</FONT></TT>
			with no arguments?<A HREF="#">[19]</A> That splits <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			on whitespace, in effect breaking <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			into a list of words. Since the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop doesn't mention some other control variable, the control
			variable will be <TT><FONT COLOR="#cc0000">$_</FONT></TT>. So,
			we'll see one word after another in <TT><FONT COLOR="#cc0000">$_</FONT></TT>.
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[19]</SUP> If
			you don't remember it, don't worry too much. Don't waste any brain
			cells remembering things that you can look up with <I>perldoc</I>.</P>
			<P>But didn't we just say that <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			holds one line of input after another? Well, in the outer loop,
			that's what it is. But inside the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, it holds one word after another. It's no problem for Perl to
			reuse <TT><FONT COLOR="#cc0000">$_</FONT></TT> for a new purpose;
			this happens all the time. 
			</P>
			<P>Now, inside the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, we're seeing one word at a time in <TT><FONT COLOR="#cc0000">$_</FONT></TT>.
			<TT><FONT COLOR="#cc0000">$total</FONT></TT> is incremented, so it
			must be the total number of words. But the next line (which is the
			point of this example) checks to see whether the word has any
			nonword characters&iuml;&frac34;—anything but letters, digits,
			and underscores. So, if the word is <TT><FONT COLOR="#cc0000">Tom's</FONT></TT>,
			or if it is <TT><FONT COLOR="#cc0000">full-sized</FONT></TT>, or
			if it has an adjoining comma, quote mark, or any other strange
			character, it will match that pattern and we'll skip the rest of
			the loop, going on to the next word. 
			</P>
			<P>But let's say that it's an ordinary word, like <TT><FONT COLOR="#cc0000">fred</FONT></TT>.
			In that case, we count <TT><FONT COLOR="#cc0000">$valid</FONT></TT>
			up by one, and also <TT><FONT COLOR="#cc0000">$count{$_}</FONT></TT>,
			keeping a count for each different word. So, when we finish the
			two loops, we've counted every word in every line of input from
			every file the user wanted us to use. 
			</P>
			<P>We're not going to explain the last few lines. By now, we hope
			you've got stuff like that down already. 
			</P>
			<P><A NAME="IXT-10-336323"></A>Like <TT><FONT COLOR="#cc0000">last</FONT></TT>,
			<TT><FONT COLOR="#cc0000">next</FONT></TT> may be used in any of
			the five kinds of loop blocks: <TT><FONT COLOR="#cc0000">for</FONT></TT>,
			<TT><FONT COLOR="#cc0000">foreach</FONT></TT>, <TT><FONT COLOR="#cc0000">while</FONT></TT>,
			<TT><FONT COLOR="#cc0000">until</FONT></TT>, or the naked block.
			Also, if loop blocks are nested, <TT><FONT COLOR="#cc0000">next</FONT></TT>
			works with the innermost one. We'll see how to change that at the
			end of this section. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-8.3"></A>10.8.3 The redo Operator</H4>
			<P><A NAME="IXT-10-336324"></A>The third member of the loop
			control triad is <TT><FONT COLOR="#cc0000">redo</FONT></TT>. It
			says to go back to the top of the current loop block, without
			testing any conditional expression or advancing to the next
			iteration. (If you've used C or a similar language, you've never
			seen this one before. Those languages don't have this kind of
			operator.) Here's an example: 
			</P>
			<PRE><FONT COLOR="#cc0000"># Typing test</FONT>
<FONT COLOR="#cc0000">my @words = qw{ fred barney pebbles dino wilma betty };</FONT>
<FONT COLOR="#cc0000">my $errors = 0;</FONT>

<FONT COLOR="#cc0000">foreach (@words) {</FONT>
<FONT COLOR="#cc0000">  ## redo comes here ##</FONT>
<FONT COLOR="#cc0000">  print &quot;Type the word '$_': &quot;;</FONT>
<FONT COLOR="#cc0000">  chomp(my $try = &lt;STDIN&gt;);</FONT>
<FONT COLOR="#cc0000">  if ($try ne $_) {</FONT>
<FONT COLOR="#cc0000">    print &quot;Sorry - That's not right.\n\n&quot;;</FONT>
<FONT COLOR="#cc0000">    $errors++;</FONT>
<FONT COLOR="#cc0000">    redo;  # jump back up to the top of the loop</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT>
<FONT COLOR="#cc0000">print &quot;You've completed the test, with $errors errors.\n&quot;;</FONT></PRE><P>
			Like the other two operators, <TT><FONT COLOR="#cc0000">redo</FONT></TT>
			will work with any of the five kinds of loop blocks, and it will
			work with the innermost loop block when they're nested. 
			</P>
			<P>The big difference between <TT><FONT COLOR="#cc0000">next</FONT></TT>
			and <TT><FONT COLOR="#cc0000">redo</FONT></TT> is that <TT><FONT COLOR="#cc0000">next</FONT></TT>
			will advance to the next iteration, but <TT><FONT COLOR="#cc0000">redo</FONT></TT>
			will redo the current iteration. Here's an example program that
			you can play with to get a feel for how these three operators
			work:<A HREF="#">[20]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[20]</SUP> If
			you've downloaded the example files from the O'Reilly website (as
			described in the Preface), you'll find this program called
			<I>lnr-example.</I></P>
			<PRE><FONT COLOR="#cc0000">foreach (1..10) {</FONT>
<FONT COLOR="#cc0000">  print &quot;Iteration number $_.\n\n&quot;;</FONT>
<FONT COLOR="#cc0000">  print &quot;Please choose: last, next, redo, or none of the above? &quot;;</FONT>
<FONT COLOR="#cc0000">  chomp(my $choice = &lt;STDIN&gt;);</FONT>
<FONT COLOR="#cc0000">  print &quot;\n&quot;;</FONT>
<FONT COLOR="#cc0000">  last if $choice =~ /last/i;</FONT>
<FONT COLOR="#cc0000">  next if $choice =~ /next/i;</FONT>
<FONT COLOR="#cc0000">  redo if $choice =~ /redo/i;</FONT>
<FONT COLOR="#cc0000">  print &quot;That wasn't any of the choices... onward!\n\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT>
<FONT COLOR="#cc0000">print &quot;That's all, folks!\n&quot;;</FONT></PRE><P>
			<A NAME="IXTR3-63"></A>If you just press return without typing
			anything (try it two or three times), the loop counts along from
			one number to the next. If you choose <TT><FONT COLOR="#cc0000">last</FONT></TT>
			when you get to number four, the loop is done, and you won't go on
			to number five. If you choose <TT><FONT COLOR="#cc0000">next</FONT></TT>
			when you're on four, you're on to number five without printing the
			&quot;onward&quot; message. And if you choose <TT><FONT COLOR="#cc0000">redo</FONT></TT>
			when you're on four, you're back to doing number four all over
			again. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-8.4"></A>10.8.4 Labeled Blocks</H4>
			<P><A NAME="IXT-10-336325"></A><A NAME="IXT-10-336326"></A>When
			you need to work with a loop block that's not the innermost one,
			use a label. Labels in Perl are like other identifiers&iuml;&frac34;—made
			of letters, digits, and underscores, but they can't start with a
			digit&iuml;&frac34;—however, since they have no prefix
			character, labels could be confused with the names of builtin
			function names, or even with your own subroutines' names. So, it
			would be a poor choice to make a label called <TT><FONT COLOR="#cc0000">print</FONT></TT>
			or <TT><FONT COLOR="#cc0000">if</FONT></TT>. Because of that,
			Larry recommends that they be all uppercase. That not only ensures
			that the label won't conflict with another identifier but it also
			makes it easy to spot the label in the code. In any case, labels
			are rare, only showing up in a small percentage of Perl programs. 
			</P>
			<P>To label a loop block, just put the label and a colon in front
			of the loop. Then, inside the loop, you may use the label after
			<TT><FONT COLOR="#cc0000">last</FONT></TT>, <TT><FONT COLOR="#cc0000">next</FONT></TT>,
			or <TT><FONT COLOR="#cc0000">redo</FONT></TT> as needed: 
			</P>
			<PRE><FONT COLOR="#cc0000">LINE: while (&lt;&gt;) {</FONT>
<FONT COLOR="#cc0000">  foreach (split) {</FONT>
<FONT COLOR="#cc0000">    last LINE if /_ _END_  _/;  # bail out of the LINE loop</FONT>
<FONT COLOR="#cc0000">    ...;</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			For readability, it's generally nice to put the label at the left
			margin, even if the current code is at a higher indentation.
			Notice that the label names the entire block; it's not marking a
			target point in the code.<A HREF="#">[21]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[21]</SUP>
			This isn't <TT><FONT COLOR="#cc0000">goto</FONT></TT>, after all.</P>
			<P>In that previous snippet of sample code, the special <TT><FONT COLOR="#cc0000">__END__</FONT></TT>
			token marks the end of all input. Once that token shows up, the
			program will ignore any remaining lines (even from other files). 
			</P>
			<P><A NAME="IXTR3-64"></A><A NAME="IXTR3-65"></A>It often makes
			sense to choose a noun as the name of the loop.<A HREF="#">[22]</A>
			That is, the outer loop is processing a line at a time, so we
			called it <TT><FONT COLOR="#cc0000">LINE</FONT></TT>. If we had to
			name the inner loop, we would have called it <TT><FONT COLOR="#cc0000">WORD</FONT></TT>,
			since it processes a word at a time. That makes it convenient to
			say things like &quot;(move on to the) <TT><FONT COLOR="#cc0000">next</FONT></TT>
			<TT><FONT COLOR="#cc0000">WORD</FONT></TT>&quot; or &quot;<TT><FONT COLOR="#cc0000">redo</FONT></TT>
			(the current) <TT><FONT COLOR="#cc0000">LINE</FONT></TT>&quot;. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[22]</SUP>
			That is, it makes more sense to do that than not to do that. Perl
			doesn't care if you call your loop labels things like <TT><FONT COLOR="#cc0000">XYZZY</FONT></TT>
			or <TT><FONT COLOR="#cc0000">PLUGH</FONT></TT>. However, unless
			you were friendly with the Colossal Cave in the 70's, you might
			not get the reference.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic28" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-9"></A>10.9 Logical Operators</H3>
			<P><A NAME="lperl3-IDXTERM-702"></A><A NAME="lperl3-IDXTERM-703"></A><A NAME="IXT-10-336327"></A><A NAME="IXT-10-336328"></A><A NAME="IXT-10-336329"></A><A NAME="IXT-10-336330"></A>
			As you might expect, Perl has all of the necessary logical
			operators needed to work with Boolean (true/false) values. For
			example, it's often useful to combine logical tests by using the
			logical AND operator (<TT><FONT COLOR="#cc0000">&amp;&amp;</FONT></TT>)
			and the logical OR operator (<TT><FONT COLOR="#cc0000">||</FONT></TT>):
			
			</P>
			<PRE><FONT COLOR="#cc0000">if ($dessert{'cake'} &amp;&amp; $dessert{'ice cream'}) {</FONT>
<FONT COLOR="#cc0000">  # Both are true</FONT>
<FONT COLOR="#cc0000">  print &quot;Hooray! Cake and ice cream!\n&quot;;</FONT>
<FONT COLOR="#cc0000">} elsif ($dessert{'cake'} || $dessert{'ice cream'}) {</FONT>
<FONT COLOR="#cc0000">  # At least one is true</FONT>
<FONT COLOR="#cc0000">  print &quot;That's still good...\n&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  # Neither is true - do nothing (we're sad)</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			There may be a shortcut. If the left side of a logical AND
			operation is false, the whole thing is false, since logical AND
			needs both sides to be true in order to return true. In that case,
			there's no reason to check the right side, so it will not even be
			evaluated. Consider what happens in this example if <TT><FONT COLOR="#cc0000">$hour</FONT></TT>
			is <TT><FONT COLOR="#cc0000">3</FONT></TT>: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ( (9 &lt;= $hour) &amp;&amp; ($hour &lt; 17) ) {</FONT>
<FONT COLOR="#cc0000">  print &quot;Aren't you supposed to be at work...?\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Similarly, if the left side of a logical OR operation is true, the
			right side will not be evaluated. Consider what happens here if
			<TT><FONT COLOR="#cc0000">$name</FONT></TT> is <TT><FONT COLOR="#cc0000">fred</FONT></TT>:
			
			</P>
			<PRE><FONT COLOR="#cc0000">if ( ($name eq 'fred') || ($name eq 'barney') ) {</FONT>
<FONT COLOR="#cc0000">  print &quot;You're my kind of guy!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-10-336331"></A>Because of this behavior, these
			operators are called &quot;short-circuit&quot; logical operators.
			They take a short circuit to the result whenever they can. In
			fact, it's fairly common to rely upon this short-circuit behavior.
			Suppose you need to calculate an average: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ( ($n != 0) &amp;&amp; ($total/$n &lt; 5) ) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The average is below five.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			In that example, the right side will be evaluated only if the left
			side is true, so we can't accidentally divide by zero and crash
			the program. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-9.1"></A>10.9.1 The Value of a
			Short-Circuit Operator</H4>
			<P><A NAME="IXT-10-336332"></A>Unlike what happens in C (and
			similar languages), the value of a short-circuit logical operator
			is the last part evaluated, not just a Boolean value. This
			provides the same result, in that the last part evaluated is
			always true when the whole thing should be true, and it's always
			false when the whole thing should be false. 
			</P>
			<P>But it's a much more useful return value. Among other things,
			the logical OR operator is quite handy for selecting a default
			value: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $last_name = $last_name{$someone} || '(No last name)';</FONT></PRE><P>
			If <TT><FONT COLOR="#cc0000">$someone</FONT></TT> is not listed in
			the hash, the left side will be <TT><FONT COLOR="#cc0000">undef</FONT></TT>,
			which is false. So, the logical OR will have to look to the right
			side for the value, making the right side the default.<A HREF="#">[23]</A>
			We'll see other uses for this behavior later. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[23]</SUP> But
			do note that in this idiom the default value won't merely replace
			<TT><FONT COLOR="#cc0000">undef</FONT></TT>; it would replace any
			false value equally well. That's fine for most names, but don't
			forget that zero and the empty string are useful values that are
			nevertheless false. This idiom should be used only when you're
			willing to replace any false value with the expression on the
			right.</P>
			<H4><A NAME="lperl3-CHP-10-SECT-9.2"></A>10.9.2 The Ternary
			Operator, ?:</H4>
			<P><A NAME="IXT-10-336333"></A><A NAME="IXT-10-336334"></A><A NAME="IXT-10-336335"></A><A NAME="IXT-10-336336"></A>
			When Larry was deciding which operators to make available in Perl,
			he didn't want former C programmers to be left wishing for
			something that C had and Perl didn't, so he brought over all of
			C's operators to Perl.<A HREF="#">[24]</A> That meant bringing
			over C's most confusing operator: the ternary <TT><FONT COLOR="#cc0000">?:</FONT></TT>
			operator. While it may be confusing, it can also be quite useful. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[24]</SUP>
			Well, to be sure, he did leave out the ones that have no use in
			Perl, such as the operator that turns a number into the memory
			address of a variable. And he added several operators (like the
			string concatenation operator), which make C folks jealous of
			Perl.</P>
			<P><A NAME="IXT-10-336337"></A>The ternary operator is like an
			if-then-else test, all rolled into an expression. It is called a
			&quot;ternary&quot; operator because it takes three operands. It
			looks like this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">expression ? if_true_expr : if_false_expr</FONT></PRE><P>
			First, the expression is evaluated to see whether it's true or
			false. If it's true, the second expression is used; otherwise, the
			third expression is used. Every time, one of the two expressions
			on the right is evaluated, and one is ignored. That is, if the
			first expression is true, then the second expression is evaluated,
			and the third is ignored. If the first expression is false, then
			the second is ignored, and the third is evaluated as the value of
			the whole thing. 
			</P>
			<P>In this example, the result of the subroutine <TT><FONT COLOR="#cc0000">&amp;is_weekend</FONT></TT>
			determines which string expression will be assigned to the
			variable: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my $location = &amp;is_weekend($day) ? &quot;home&quot; : &quot;work&quot;;</FONT></PRE><P>
			And here, we calculate and print out an average&iuml;&frac34;—or
			just a placeholder line of hyphens, if there's no average
			available: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $average = $n ? ($total/$n) : &quot;-----&quot;;</FONT>
<FONT COLOR="#cc0000">print &quot;Average: $average\n&quot;;</FONT></PRE><P>
			You could always rewrite any use of the <TT><FONT COLOR="#cc0000">?:</FONT></TT>
			operator as an <TT><FONT COLOR="#cc0000">if</FONT></TT> structure,
			often much less conveniently and less concisely: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $average;</FONT>
<FONT COLOR="#cc0000">if ($n) {</FONT>
<FONT COLOR="#cc0000">  $average = $total / $n;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  $average = &quot;-----&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT>
<FONT COLOR="#cc0000">print &quot;Average: $average\n&quot;;</FONT></PRE><P>
			Here's a trick you might see, used to code up a nice multiway
			branch: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $size =</FONT>
<FONT COLOR="#cc0000">  ($width &lt; 10) ? &quot;small&quot;  :</FONT>
<FONT COLOR="#cc0000">  ($width &lt; 20) ? &quot;medium&quot; :</FONT>
<FONT COLOR="#cc0000">  ($width &lt; 50) ? &quot;large&quot;  :</FONT>
<FONT COLOR="#cc0000">                  &quot;extra-large&quot;; # default</FONT></PRE><P>
			That is really just three nested <TT><FONT COLOR="#cc0000">?:</FONT></TT>
			operators, and it works quite well, once you get the hang of it. 
			</P>
			<P>Of course, you're not obliged to use this operator. Beginners
			may wish to avoid it. But you'll see it in others' code, sooner or
			later, and we hope that one day you'll find a good reason to use
			it in your own programs. 
			</P>
			<H4><A NAME="lperl3-CHP-10-SECT-9.3"></A>10.9.3 Control Structures
			Using Partial-Evaluation Operators</H4>
			<P><A NAME="lperl3-IDXTERM-715"></A><A NAME="lperl3-IDXTERM-716"></A>
			These three operators that we've just seen&iuml;&frac34;—<TT><FONT COLOR="#cc0000">&amp;&amp;</FONT></TT>,
			<TT><FONT COLOR="#cc0000">||</FONT></TT>, and <TT><FONT COLOR="#cc0000">?:</FONT></TT>&iuml;&frac34;—all
			share a peculiar property: depending upon whether the value on the
			left side is true or false, they may or may not evaluate an
			expression. Sometimes the expression is evaluated, and sometimes
			it isn't. For that reason, these are sometimes called
			<I>partial-evaluation</I> operators, since they may not evaluate
			all of the expressions around them. And partial-evaluation
			operators are automatically control structures.<A HREF="#">[25]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[25]</SUP>
			Some of you were wondering why these logical operators are being
			covered in this chapter, weren't you?</P>
			<P>It's not as if Larry felt a burning need to add more control
			structures to Perl. But once he had decided to put these
			partial-evaluation operators into Perl, they automatically became
			control structures as well. After all, anything that can activate
			and deactivate a chunk of code is a control structure. 
			</P>
			<P>Fortunately, you'll notice this only when the controlled
			expression has side effects, like altering a variable's value or
			causing some output. For example, suppose you ran across this line
			of code: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">($a &lt; $b) &amp;&amp; ($a = $b);</FONT></PRE><P>
			Right away, you should notice that the result of the logical AND
			isn't being assigned anywhere.<A HREF="#">[26]</A> Why not? 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[26]</SUP> But
			don't forget to consider that it might be a return value, as the
			last expression in a subroutine.</P>
			<P>If <TT><FONT COLOR="#cc0000">$a</FONT></TT> is really less than
			<TT><FONT COLOR="#cc0000">$b</FONT></TT>, the left side is true,
			so the right side will be evaluated, thereby doing the assignment.
			But if <TT><FONT COLOR="#cc0000">$a</FONT></TT> is not less than
			<TT><FONT COLOR="#cc0000">$b</FONT></TT>, the left side will be
			false, and thus the right side would be skipped. So that line of
			code would do essentially the same thing as this one, which is
			easier to understand: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">if ($a &lt; $b) { $a = $b; }</FONT></PRE><P>
			<A NAME="IXT-10-336338"></A>Or maybe you'll be maintaining a
			program, and you'll see a line like this one: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">($a &gt; 10) || print &quot;why is it not greater?\n&quot;;</FONT></PRE><P>
			If <TT><FONT COLOR="#cc0000">$a</FONT></TT> is really greater than
			ten, the left side is true, and the logical OR is done. But if
			it's not, the left side is false, and this will go on to print the
			message. Once again, this could (and probably should) be written
			in the traditional way, probably with <TT><FONT COLOR="#cc0000">if</FONT></TT>
			or <TT><FONT COLOR="#cc0000">unless</FONT></TT>. 
			</P>
			<P>If you have a particularly twisted brain, you might even learn
			to read these lines as if they were written in English. For
			example: check that <TT><FONT COLOR="#cc0000">$a</FONT></TT> is
			less than <TT><FONT COLOR="#cc0000">$b</FONT></TT>, and if it is,
			then do the assignment. Check that <TT><FONT COLOR="#cc0000">$a</FONT></TT>
			is more than ten, or if it's not, then print the message. 
			</P>
			<P>It's generally former C programmers or old-time Perl
			programmers who most often use these ways of writing control
			structures. Why do they do it? Some have the mistaken idea that
			these are more efficient. Some think these tricks make their code
			cooler. Some are merely copying what they saw someone else do. 
			</P>
			<P>In the same way, the ternary operator may be used for control.
			In this case, we want to assign <TT><FONT COLOR="#cc0000">$c</FONT></TT>
			to the smaller of two variables: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">($a &lt; $b) ? ($a = $c) : ($b = $c);</FONT></PRE><P>
			If <TT><FONT COLOR="#cc0000">$a</FONT></TT> is smaller, it gets
			<TT><FONT COLOR="#cc0000">$c</FONT></TT>. Otherwise, <TT><FONT COLOR="#cc0000">$b</FONT></TT>
			does. 
			</P>
			<P><A NAME="IXT-10-336339"></A><A NAME="IXT-10-336340"></A><A NAME="IXT-10-336341"></A>
			There is another way to write the logical AND and logical OR
			operators. You may wish to write them out as words: <TT><FONT COLOR="#cc0000">and</FONT></TT>
			and <TT><FONT COLOR="#cc0000">or</FONT></TT>.<A HREF="#">[27]</A>
			These word-operators have the same behaviors as the ones written
			with punctuation, but the words are much lower on the precedence
			chart. Since the words don't &quot;stick&quot; so tightly to the
			nearby parts of the expression, they may need fewer parentheses: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-10-336342"></A><A NAME="IXT-10-336343"></A>
			<SUP>[27]</SUP> There are also the low-precedence <TT><FONT COLOR="#cc0000">not</FONT></TT>
			(like the logical-negation operator, &quot;<TT><FONT COLOR="#cc0000">!</FONT></TT>&quot;)
			and the rare <TT><FONT COLOR="#cc0000">xor</FONT></TT>.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$a &lt; $b and $a = $b;  # but better written as the corresponding if</FONT></PRE><P>
			<A NAME="IXT-10-336344"></A>Then again, you may need more
			parentheses. Precedence is a bugaboo. Be sure to use parentheses
			to say what you mean, unless you're sure of the precedence.
			Nevertheless, since the word forms are very low precedence, you
			can generally understand that they cut the expression into big
			pieces, doing everything on the left first, and then (if needed)
			everything on the right. 
			</P>
			<P>Despite the fact that using logical operators as control
			structures can be confusing, sometimes they're the accepted way to
			write code. We'll see a common use of the <TT><FONT COLOR="#cc0000">or</FONT></TT>
			operator starting in the next chapter. 
			</P>
			<P><A NAME="IXTR3-66"></A><A NAME="IXTR3-67"></A><A NAME="IXTR3-68"></A><A NAME="IXTR3-69"></A>
			So, using these operators as control structures is part of
			idiomatic Perl&iuml;&frac34;—Perl as she is spoken. Used
			properly, they can make your code more powerful; otherwise they
			can make your code unmaintainable. Don't overuse them.<A HREF="#">[28]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[28]</SUP>
			Using these weird forms more than once per month counts as
			overuse.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic29" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-10-SECT-10"></A>10.10 Exercise</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-9#lperl3-APP-A-SECT-9">Section
			A.9</A> for an answer to the following exercise: 
			</P>
			<OL>
				<LI><P><A NAME="IXTR3-70"></A>[25] Make a program that will
				repeatedly ask the user to guess a secret number from 1 to 100
				until the user guesses the secret number. Your program should
				pick the number at random by using the magical formula <TT><FONT COLOR="#cc0000">int(1
				+</FONT></TT> <TT><FONT COLOR="#cc0000">rand 100)</FONT></TT>.<A HREF="#">[29]</A>
				When the user guesses wrong, the program should respond &quot;Too
				high&quot; or &quot;Too low&quot;. If the user enters the word
				<TT><FONT COLOR="#cc0000">quit</FONT></TT> or <TT><FONT COLOR="#cc0000">exit</FONT></TT>,
				or if the user enters a blank line, the program should quit. Of
				course, if the user guesses correctly, the program should quit
				then as well! 
				</P>
				<P STYLE="margin-right: 1cm"><SUP>[29]</SUP> See what the
				perlfunc manpage says about <TT><FONT COLOR="#cc0000">int</FONT></TT>
				and <TT><FONT COLOR="#cc0000">rand</FONT></TT> if you're curious
				about these functions.</P>
			</OL>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic30" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-11-SECT-1"></A>11.1 What Is a Filehandle?</H3>
			<P><A NAME="lperl3-IDXTERM-729"></A><A NAME="IXT-11-336345"></A><A NAME="IXT-11-336346"></A>
			A filehandle is the name in a Perl program for an I/O connection
			between your Perl process and the outside world. That is, it's the
			name of a connection, not necessarily the name of a file. 
			</P>
			<P>Filehandles are named like other Perl identifiers (letters,
			digits, and underscores, but they can't start with a digit), but
			since they don't have any prefix character, they might be confused
			with present or future reserved words, as we saw with labels. Once
			again, as with labels, the recommendation from Larry is that you<SPAN STYLE="background: #94bd5e">
			use all uppercase letters in the name of your filehandle</SPAN>&iuml;&frac34;—not
			only will it stand out better, but it will also guarantee that
			your program won't fail when a future (lowercase) reserved word is
			introduced. 
			</P>
			<P>But there are also six special filehandle names that Perl
			already uses for its own purposes: <TT><FONT COLOR="#cc0000">STDIN</FONT></TT>,
			<TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>, <TT><FONT COLOR="#cc0000">STDERR</FONT></TT>,
			<TT><FONT COLOR="#cc0000">DATA</FONT></TT>, <TT><FONT COLOR="#cc0000">ARGV</FONT></TT>,
			and <TT><FONT COLOR="#cc0000">ARGVOUT</FONT></TT>.<A HREF="#">[1]</A>
			Although you may choose any filehandle name you'd like, you
			shouldn't choose one of those six unless you intend to use that
			one's special properties.<A HREF="#">[2]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP> Some
			people hate typing in all-caps, even for a moment, and will try
			spelling these in lowercase, like <TT><FONT COLOR="#cc0000">stdin</FONT></TT>.
			Perl may even let you get away with that from time to time, but
			not always. The details of when these work and when they fail are
			beyond the scope of this book. But the important thing is that
			programs that rely upon this kindness will one day break, so it is
			best to avoid lowercase here.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> In
			some cases, you could (re-)use these names without a problem. But
			your maintenance programmer may think that you're using the name
			for its builtin features, and thus may be confused. 
			</P>
			<P><A NAME="IXT-11-336347"></A><A NAME="IXT-11-336348"></A>Maybe
			you recognized some of those names already. When your program
			starts, <TT><FONT COLOR="#cc0000">STDIN</FONT></TT> is the
			filehandle naming the connection between the Perl process and
			wherever the program should get its input, known as the <I>standard
			input stream</I>. This is generally the user's keyboard unless the
			user asked for something else to be the source of input, such as
			reading the input from a file or reading the output of another
			program through a pipe.<A HREF="#">[3]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP> The
			defaults we speak of in this chapter for the three main I/O
			streams are what the Unix shells do by default. But it's not just
			shells that launch programs, of course. We'll see in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-14#lperl3-CHP-14">Chapter
			14</A> what happens when you launch another program from Perl.</P>
			<P><A NAME="IXT-11-336349"></A><A NAME="IXT-11-336350"></A><A NAME="IXT-11-336351"></A>
			There's also the <I>standard output stream</I>, which is <TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>.
			By default, this one goes to the user's display screen, but the
			user may send the output to a file or to another program, as we'll
			see shortly. These standard streams come to us from the Unix
			&quot;standard I/O&quot; library, but they work in much the same
			way on most modern operating systems.<A HREF="#">[4]</A> The
			general idea is that your program should blindly read from <TT><FONT COLOR="#cc0000">STDIN</FONT></TT>
			and blindly write to <TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>,
			trusting in the user (or generally whichever program is starting
			your program) to have set those up. In that way, the user can type
			a command like this one at the shell prompt: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-11-336352"></A>
			<SUP>[4]</SUP> If you're not already familiar with how your
			non-Unix system provides standard input and output, see the
			perlport manpage and the documentation for that system's
			equivalent to the Unix shell (the program that runs programs based
			upon your keyboard input).</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$ <B>./your_program &lt;dino &gt;wilma</B></FONT></PRE><P>
			That command tells the shell that the program's input should be
			read from the file <I>dino</I>, and the output should go to the
			file <I>wilma</I>. As long as the program blindly reads its input
			from <TT><FONT COLOR="#cc0000">STDIN</FONT></TT>, processes it (in
			whatever way we need), and blindly writes its output to <TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>,
			this will work just fine. 
			</P>
			<P><A NAME="IXT-11-336353"></A><A NAME="IXT-11-336354"></A>And at
			no extra charge, the program will work in a <SPAN STYLE="background: #94bd5e"><I>pipeline</I>.</SPAN>
			This is another concept from Unix, which lets us write command
			lines like this one: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">$ <B>cat fred barney | sort | ./your_program | grep something | lpr</B></SPAN></FONT></PRE><P>
			Now, if you're not familiar with these Unix commands, that's okay.
			This line says that the <I>cat</I> command should print out all of
			the lines of file <I>fred</I> followed by all of the lines of file
			<I>barney</I>. Then that output should be the input of the <I>sort</I>
			command, which sorts those lines and passes them on to
			<I>your_program</I>. After it has done its processing,
			<I>your_program</I> will send the data on to <I>grep</I>, which
			discards certain lines in the data, sending the others on to the
			<I>lpr</I> command, which should print everything that it gets on
			a printer. Whew! 
			</P>
			<P>But pipelines like that are common in Unix and many other
			systems today because they let you put together a powerful,
			complex command out of simple, standard building blocks. 
			</P>
			<P><A NAME="IXT-11-336355"></A><A NAME="IXT-11-336356"></A>There's
			one more standard I/O stream. If (in the previous example)
			<I>your_program</I> had to emit any warnings or other diagnostic
			messages, those shouldn't go down the pipeline. The <I>grep</I>
			command is set to discard anything that it hasn't specifically
			been told to look for, and so it will most likely discard the
			warnings. Even if it did keep the warnings, we probably don't want
			those to be passed downstream to the other programs in the
			pipeline. So that's why there's also the <I>standard error stream</I>:
			<TT><FONT COLOR="#cc0000">STDERR</FONT></TT>. Even if the standard
			output is going to another program or file, the errors will go to
			wherever the user desires. By default, the errors will generally
			go to the user's display screen,<A HREF="#">[5]</A> but the user
			may send the errors to a file with a shell command like this one: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[5]</SUP>
			Also, generally, errors aren't buffered. That means that if the
			standard error and standard output streams are both going to the
			same place (such as the monitor), the errors may appear earlier
			than the normal output. For example, if your program prints a line
			of ordinary text, then tries to divide by zero, the output may
			show the message about dividing by zero first, and the ordinary
			text second.</P>
			<PRE><FONT COLOR="#cc0000">$ <B>netstat | ./your_program 2&gt;/tmp/my_errors</B></FONT></PRE>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-11-SECT-2"></A>11.2 Opening a Filehandle</H3>
			<P><A NAME="lperl3-IDXTERM-742"></A><A NAME="lperl3-IDXTERM-743"></A>
			So we see that Perl provides three filehandles&iuml;&frac34;—<TT><FONT COLOR="#cc0000">STDIN</FONT></TT>,
			<TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>, and <TT><FONT COLOR="#cc0000">STDERR</FONT></TT>&iuml;&frac34;—which
			are automatically open to files or devices established by the
			program's parent process (probably the shell). When you need other
			filehandles, use the <TT><FONT COLOR="#cc0000">open</FONT></TT>
			operator to tell Perl to ask the operating system to open the
			connection between your program and the outside world. Here are
			some examples: 
			</P>
			<PRE><FONT COLOR="#cc0000">open CONFIG, &quot;dino&quot;;</FONT>
<FONT COLOR="#cc0000">open CONFIG, &quot;&lt;dino&quot;;</FONT>
<FONT COLOR="#cc0000">open BEDROCK, &quot;&gt;fred&quot;;</FONT>
<FONT COLOR="#cc0000">open LOG, &quot;&gt;&gt;logfile&quot;;</FONT></PRE><P>
			The first one opens a filehandle called <TT><FONT COLOR="#cc0000">CONFIG</FONT></TT>
			to a file called <I>dino</I>. That is, the (existing) file <I>dino</I>
			will be opened and whatever it holds will come into our program
			through the filehandle named <TT><FONT COLOR="#cc0000">CONFIG</FONT></TT>.
			This is similar to the way that data from a file could come in
			through <TT><FONT COLOR="#cc0000">STDIN</FONT></TT> if the command
			line had a shell redirection like <TT><FONT COLOR="#cc0000">&lt;dino</FONT></TT>.
			In fact, the second example uses exactly that sequence. The second
			does the same as the first, but the less-than sign explicitly says
			&quot;this filename is to be used for input,&quot; even though
			that's the default.<A HREF="#">[6]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP> This
			may be important for security reasons. As we'll see in a moment
			(and in further detail in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-14#lperl3-CHP-14">Chapter
			14</A>), there are a number of magical characters that may be used
			in filenames. If <TT><FONT COLOR="#cc0000">$name</FONT></TT> holds
			a user-chosen filename, simply opening <TT><FONT COLOR="#cc0000">$name</FONT></TT>
			will allow any of these magical characters to come into play. This
			could be a convenience for the user, or it could be a security
			hole. But opening <TT><FONT COLOR="#cc0000">&quot;&lt;$name&quot;</FONT></TT>
			is much safer, since it explicitly says to open the given name for
			input. Still, this doesn't prevent all possible mischief. For more
			information on different ways of opening files, especially when
			security may be a concern, see the perlopentut manpage.</P>
			<P><A NAME="IXT-11-336357"></A><A NAME="IXT-11-336358"></A><A NAME="IXT-11-336359"></A><A NAME="IXT-11-336360"></A>
			Although you don't have to use the less-than sign to open a file
			for input, we include that because, as you can see in the third
			example, a <SPAN STYLE="background: #94bd5e">greater-than sign
			means to create a new file for output</SPAN>. This opens the
			filehandle <TT><TT><FONT COLOR="#cc0000">BEDROCK</FONT></TT></TT>
			for output to the new file <I>fred</I>. Just as when the
			greater-then sign is used in shell redirection, we're sending the
			output to a new file called <I>fred</I>. If there's already a file
			of that name, we're asking to wipe it out and replace it with this
			new one. 
			</P>
			<P><A NAME="IXT-11-336361"></A>The fourth example shows how two
			greater-than signs may be used (again, as the shell does) to open
			a file for appending. That is, if the file already exists, we will
			add new data at the end. If it doesn't exist, it will be created
			in much the same way as if we had used just one greater-than sign.
			This is handy for log files; your program could write a few lines
			to the end of a log file each time it's run. So that's why the
			fourth example names the filehandle <TT><FONT COLOR="#cc0000">LOG</FONT></TT>
			and the file <I>logfile</I>. 
			</P>
			<P>You can use any scalar expression in place of the filename
			specifier, although typically you'll want to be explicit about the
			direction specification: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $selected_output = &quot;my_output&quot;;</FONT>
<FONT COLOR="#cc0000">open LOG, &quot;&gt; $selected_output&quot;;</FONT></PRE><P>
			<A NAME="IXT-11-336362"></A><SPAN STYLE="background: #94bd5e">Note
			the space after the greater-than. Perl ignores this,</SPAN><A HREF="#"><SPAN STYLE="background: #94bd5e">[7]</SPAN></A><SPAN STYLE="background: #94bd5e">
			but it keeps unexpected things from happening if </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">$selected_output</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			were </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">&quot;&gt;passwd&quot;</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			</SPAN>for example (which would make an append instead of a
			write). 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP> Yes,
			this means that if your filename were to have leading whitespace,
			that would also be ignored by Perl. See perlfunc and perlopentut
			if you're worried about this.</P>
			<P>We'll see how to use these filehandles later in this chapter.</P>
			<H4><A NAME="lperl3-CHP-11-SECT-2.1"></A>11.2.1 Closing a
			Filehandle</H4>
			<P><A NAME="IXT-11-336363"></A>When you are finished with a
			filehandle, you may close it with the <TT><FONT COLOR="#cc0000">close</FONT></TT>
			operator like this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">close BEDROCK;</FONT></PRE><P>
			Closing a filehandle tells Perl to inform the operating system
			that we're all done with the given data stream, so any last output
			data should be written to disk in case someone is waiting for
			it.<A HREF="#">[8]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> If
			you know much about I/O systems, you'll know there's more to the
			story. Generally, though, when a filehandle is closed, here's what
			happens. If there's input remaining in a file, it's ignored. If
			there's input remaining in a pipeline, the writing program may get
			a signal that the pipeline is closed. If there's output going to a
			file or pipeline, the buffer is flushed (that is, pending output
			is sent on its way). If the filehandle had a lock, the lock is
			released. See your system's I/O documentation for further details.</P>
			<P>Perl will automatically close a filehandle if you reopen it
			(that is, if you reuse the filehandle name in a new <TT><FONT COLOR="#cc0000">open</FONT></TT>)
			or if you exit the program.<A HREF="#">[9]</A> Because of this,
			many simple Perl programs don't bother with <TT><FONT COLOR="#cc0000">close</FONT></TT>.
			But it's there if you want to be tidy, with one <TT><FONT COLOR="#cc0000">close</FONT></TT>
			for every <TT><FONT COLOR="#cc0000">open</FONT></TT>. In general,
			it's best to close each filehandle soon after you're done with it,
			though the end of the program often arrives soon enough.<A HREF="#">[10]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP> Any
			exit from the program will close all filehandles, but if Perl
			itself breaks, pending output buffers won't get flushed. That is
			to say, if you accidentally crash your program by dividing by
			zero, for example, Perl itself is still running. Perl will ensure
			that data you've written actually gets output in that case. But if
			Perl itself can't run (because you ran out of memory or caught an
			unexpected signal), the last few pieces of output may not be
			written to disk. Usually, this isn't a big issue.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[10]</SUP>
			Closing a filehandle will flush any output buffers and release any
			locks on the file. Since someone else may be waiting for those
			things, a long-running program should generally close each
			filehandle as soon as possible. But many of our programs will take
			only one or two seconds to run to completion, so this may not
			matter. Closing a filehandle also releases possibly limited
			resources, so it's more than just being tidy.</P>
			<H4><A NAME="lperl3-CHP-11-SECT-2.2"></A>11.2.2 Bad Filehandles</H4>
			<P>Perl can't actually open a file all by itself. Like any other
			programming language, Perl can merely ask the operating system to
			let us open a file. Of course, the operating system may refuse,
			because of permission settings, an incorrect filename, or other
			reasons. 
			</P>
			<P><A NAME="IXT-11-336364"></A><A NAME="IXT-11-336365"></A><A NAME="IXT-11-336366"></A>
			If you try to read from a bad filehandle (that is, a filehandle
			that isn't properly open), you'll see an immediate end-of-file.
			(With the I/O methods we'll see in this chapter, end-of-file will
			be indicated by <TT><FONT COLOR="#cc0000">undef</FONT></TT> in a
			scalar context or an empty list in a list context.) If you try to
			write to a bad filehandle, the data is silently discarded. 
			</P>
			<P><A NAME="IXT-11-336367"></A>Fortunately, these dire
			consequences are easy to avoid. First of all, if we ask for
			warnings with <TT><FONT COLOR="#cc0000">-w</FONT></TT>, Perl will
			generally be able to tell us with a warning when it sees that
			we're using a bad filehandle. But even before that, <TT><FONT COLOR="#cc0000">open</FONT></TT>
			always tells us if it succeeded or failed, by returning true for
			success or false for failure. So you could write code like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">my $success = open LOG, &quot;&gt;&gt;logfile&quot;;  # capture the return value</FONT>
<FONT COLOR="#cc0000">unless ($success) {</FONT>
<FONT COLOR="#cc0000">  # The open failed</FONT>
<FONT COLOR="#cc0000">  ...</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXTR3-71"></A><A NAME="IXTR3-72"></A>Well, you could do
			it like that, but there's another way that we'll see in the next
			section. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-11-SECT-3"></A>11.3 Fatal Errors with die</H3>
			<P><A NAME="lperl3-IDXTERM-757"></A><A NAME="lperl3-IDXTERM-758"></A><A NAME="IXT-11-336368"></A>
			Let's step aside for a moment. We need some stuff that isn't
			directly related to (or limited to) filehandles, but is more about
			getting out of a program earlier than normal. 
			</P>
			<P>When a fatal error happens inside Perl (for example, if you
			divide by zero, use an invalid regular expression, or call a
			subroutine that hasn't been declared) your program stops with an
			error message telling why.<A HREF="#">[11]</A> But this
			functionality is available to us with the <TT><FONT COLOR="#cc0000">die</FONT></TT>
			function, so we can make our own fatal errors. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP>
			Well, it does this by default, but errors may be trapped with an
			<TT><FONT COLOR="#cc0000">eval</FONT></TT> block, as we'll see in
			<A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-17#lperl3-CHP-17">Chapter
			17</A>.</P>
			<P><A NAME="IXT-11-336369"></A>The <TT><FONT COLOR="#cc0000">die</FONT></TT>
			function prints out the message you give it (to the standard error
			stream, where such messages should go) and makes sure that your
			program exits with a nonzero exit status. 
			</P>
			<P><A NAME="IXT-11-336370"></A><A NAME="IXT-11-336371"></A><A NAME="IXT-11-336372"></A>
			You may not have known it, but every program that runs on Unix
			(and many other modern operating systems) has an exit status,
			telling whether it was successful or not. Programs that run other
			programs (like the <I>make</I> utility program) look at that exit
			status to see that everything is running correctly. The exit
			status is just a single byte, so it can't say much; traditionally,
			it is zero for success and a nonzero value for failure. Perhaps
			one means a syntax error in the command arguments, while two means
			that something went wrong during processing and three means the
			configuration file couldn't be found; the details differ from one
			command to the next. But zero always means that everything worked.
			When the exit status shows failure, a program like <I>make</I>
			knows not to go on to the next step. 
			</P>
			<P>So we could rewrite the previous example, perhaps something
			like this:</P>
			<PRE><FONT COLOR="#cc0000">unless (open LOG, &quot;&gt;&gt;logfile&quot;) {</FONT>
<FONT COLOR="#cc0000">  die &quot;Cannot create logfile: $!&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-11-336373"></A>If the <TT><FONT COLOR="#cc0000">open</FONT></TT>
			fails, <TT><FONT COLOR="#cc0000">die</FONT></TT> will terminate
			the program and tell us that it cannot create the logfile. But
			what's that <TT><FONT COLOR="#cc0000">$!</FONT></TT> in the
			message? That's the human-readable complaint from the system. In
			general, when the system refuses to do something we've requested
			(like opening a file), it will give us a reason (perhaps
			&quot;permission denied&quot; or &quot;file not found,&quot; in
			this case). This is the string that you may have obtained with
			<TT><FONT COLOR="#cc0000">perror</FONT></TT> in C or a similar
			language. This human-readable complaint message will be available
			in Perl's special variable <TT><FONT COLOR="#cc0000">$!</FONT></TT>.<A HREF="#">[12]</A>
			It's a good idea to include <TT><FONT COLOR="#cc0000">$!</FONT></TT>
			in the message when it could help the user to figure out what he
			or she did wrong. But if you use <TT><FONT COLOR="#cc0000">die</FONT></TT>
			to indicate an error that is not the failure of a system request,
			don't include <TT><FONT COLOR="#cc0000">$!</FONT></TT>, since it
			will generally hold an unrelated message left over from something
			Perl did internally. It will hold a useful value only immediately
			after a failed system request. A successful request won't leave
			anything useful there. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP> On
			some non-Unix operating systems, <TT><FONT COLOR="#cc0000">$!</FONT></TT>may
			say something like <TT><FONT COLOR="#cc0000">error number 7</FONT></TT>,
			leaving it up to the user to look that one up in the
			documentation. On Windows and VMS, the variable <TT><FONT COLOR="#cc0000">$^E</FONT></TT>
			may have additional diagnostic information. 
			</P>
			<P><A NAME="IXT-11-336374"></A><A NAME="IXT-11-336375"></A>There's
			one more thing that <TT><FONT COLOR="#cc0000">die</FONT></TT> will
			do for you: it will automatically append the Perl program name and
			line number<A HREF="#">[13]</A> to the end of the message, so you
			can easily identify which <TT><FONT COLOR="#cc0000">die</FONT></TT>
			in your program is responsible for the untimely exit. The error
			message from the previous code might look like this, if <TT><FONT COLOR="#cc0000">$!</FONT></TT>
			contained the message <TT><FONT COLOR="#cc0000">permission denied</FONT></TT>:
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-11-336376"></A>
			<SUP>[13]</SUP> If the error happened while reading from a file,
			the error message will include the &quot;chunk number&quot;
			(usually the line number) from the file and the name of the
			filehandle as well, since those are often useful in tracking down
			a bug.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">Cannot create logfile: permission denied at your_program line 1234.</FONT></PRE><P>
			<A NAME="IXT-11-336377"></A><A NAME="IXT-11-336378"></A>That's
			pretty helpful&iuml;&frac34;—in fact, we always seem to want
			more information in our error messages than we put in the first
			time around. If you don't want the line number and file revealed,
			make sure that the dying words have a newline on the end. That is,
			another way you could use <TT><FONT COLOR="#cc0000">die</FONT></TT>
			is in a line like this, with a trailing newline: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">die &quot;Not enough arguments\n&quot; if @ARGV &lt; 2;</FONT></PRE><P>
			If there aren't at least two command-line arguments, that program
			will say so and quit. It won't include the program name and line
			number, since the line number is of no use to the user; this is
			the user's error, after all. As a rule of thumb, <SPAN STYLE="background: #94bd5e">put
			the newline on messages that indicate a usage error and leave it
			off when it the error might be something you want to track down
			during debugging.</SPAN><A HREF="#">[14]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-11-336379"></A><A NAME="IXT-11-336380"></A><A NAME="IXT-11-336381"></A>
			<SUP>[14]</SUP> The program's name is in Perl's special variable
			<TT><FONT COLOR="#cc0000">$0</FONT></TT>, so you may wish to
			include that in the string: <TT><FONT COLOR="#cc0000">&quot;$0:Not
			enough arguments\n&quot;</FONT></TT>. This is useful if the
			program may be used in a pipeline or shell script, for example,
			where it's not obvious which command is complaining. <TT><FONT COLOR="#cc0000">$0</FONT></TT>
			can be changed during the execution of the program, however. You
			might also want to look into the special _ _<TT><FONT COLOR="#cc0000">FILE</FONT></TT>_
			_ and _ _<TT><FONT COLOR="#cc0000">LINE</FONT></TT>_ _tokens (or
			the <TT><FONT COLOR="#cc0000">caller</FONT></TT> function) to get
			the information that is being left out by adding the newline, so
			you can print it in your own choice of format.</P>
			<P>When opening a file fails, though, there's an easier and more
			common way instead of the <TT><FONT COLOR="#cc0000">unless</FONT></TT>
			block: 
			</P>
			<PRE><FONT COLOR="#cc0000">open LOG, &quot;&gt;&gt;logfile&quot;</FONT>
<FONT COLOR="#cc0000">  or die &quot;Cannot create logfile: $!&quot;;</FONT></PRE><P>
			<A NAME="IXT-11-336382"></A>This uses the low-precedence
			short-circuit <TT><FONT COLOR="#cc0000">or</FONT></TT> operator
			that we saw in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-10#lperl3-CHP-10">Chapter
			10</A>. If the <TT><FONT COLOR="#cc0000">open</FONT></TT>
			succeeds, it returns true, and the <TT><FONT COLOR="#cc0000">or</FONT></TT>
			is done. If the <TT><FONT COLOR="#cc0000">open</FONT></TT> fails,
			it returns false, and the short-circuit <TT><FONT COLOR="#cc0000">or</FONT></TT>
			goes on to the right side and dies with the message. You can read
			this as if it were English: &quot;Open this file, or die!&quot; It
			may not be the battle cry that will win a war, but it's a good way
			to write code. 
			</P>
			<P>You should always check the return value of <TT><FONT COLOR="#cc0000">open</FONT></TT>,
			since the rest of the program is relying upon its success. That's
			why we say that this is really the only way to write <TT><FONT COLOR="#cc0000">open</FONT></TT>&iuml;&frac34;—with
			<TT><FONT COLOR="#cc0000">or die</FONT></TT> after it.<A HREF="#">[15]</A>
			Until you're ready to be extra tricky, you should simply think of
			this as the syntax for <TT><FONT COLOR="#cc0000">open</FONT></TT>.
			Typing <TT><FONT COLOR="#cc0000">or die</FONT></TT> and a message
			takes only a moment when you're writing the program, but it can
			save hours, or possibly days of debugging time when something goes
			wrong. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP>
			Older code may use the higher-precedence <TT><FONT COLOR="#cc0000">||</FONT></TT>
			operator instead. The only difference is the precedence, but it's
			a big one! If the <TT><FONT COLOR="#cc0000">open</FONT></TT> is
			written without parentheses, the higher-precedence operator will
			bind to the filename argument, not to the return value&iuml;&frac34;—so
			the return value of <TT><FONT COLOR="#cc0000">open</FONT></TT>
			isn't being checked after all. If you use the <TT><FONT COLOR="#cc0000">||</FONT></TT>,
			be sure to use the parentheses. Better yet, just use the
			low-precedence <TT><FONT COLOR="#cc0000">or</FONT></TT> as we've
			shown here whenever you're writing <TT><FONT COLOR="#cc0000">or
			die</FONT></TT>.</P>
			<H4><A NAME="lperl3-CHP-11-SECT-3.1"></A>11.3.1 Warning Messages
			with warn</H4>
			<P><A NAME="IXT-11-336383"></A><A NAME="IXT-11-336384"></A>Just as
			<TT><FONT COLOR="#cc0000">die</FONT></TT> can indicate a fatal
			error that acts like one of Perl's builtin errors (like dividing
			by zero), you can use the <TT><FONT COLOR="#cc0000">warn</FONT></TT>
			function to cause a warning that acts like one of Perl's builtin
			warnings (like using an <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			value as if it were defined, when warnings are enabled). 
			</P>
			<P><A NAME="IXT-11-336385"></A><A NAME="IXT-11-336386"></A>The
			<TT><FONT COLOR="#cc0000">warn</FONT></TT> function works just
			like <TT><FONT COLOR="#cc0000">die</FONT></TT> does, except for
			that last step&iuml;&frac34;—it doesn't actually quit the
			program. But it adds the program name and line number if needed,
			and it prints the message to standard error, just as <TT><FONT COLOR="#cc0000">die</FONT></TT>
			would.<A HREF="#">[16]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP>
			Warnings can't be trapped with an <TT><FONT COLOR="#cc0000">eval</FONT></TT>
			block, like fatal errors can. But see the documentation for the _
			_<TT><FONT COLOR="#cc0000">WARN</FONT></TT>_ _ pseudo-signal (in
			the perlvar manpage) if you need to trap a warning.</P>
			<P><A NAME="IXTR3-73"></A><A NAME="IXTR3-74"></A>And having talked
			about death and dire warnings, we now return you to your regularly
			scheduled filehandle instructional material. Read on. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-11-SECT-4"></A>11.4 Using Filehandles</H3>
			<P><A NAME="IXT-11-336387"></A>Once a filehandle is open for
			reading, you can read lines from it just like you can read from
			standard input with <TT><FONT COLOR="#cc0000">STDIN</FONT></TT>.
			So, for example, to read lines from the Unix password file: 
			</P>
			<PRE><FONT COLOR="#cc0000">open PASSWD, &quot;/etc/passwd&quot;</FONT>
<FONT COLOR="#cc0000">  or die &quot;How did you get logged in? ($!)&quot;;</FONT>

<FONT COLOR="#cc0000">while (&lt;PASSWD&gt;) {</FONT>
<FONT COLOR="#cc0000">  chomp;</FONT>
<FONT COLOR="#cc0000">  if (/^root:/) {  # found root entry...</FONT>
<FONT COLOR="#cc0000">    ...;</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-11-336388"></A>In this example, the <TT><FONT COLOR="#cc0000">die</FONT></TT>
			message uses parentheses around <TT><FONT COLOR="#cc0000">$!</FONT></TT>.
			Those are merely parentheses around the message in the output.
			(Sometimes a punctuation mark is just a punctuation mark.) As you
			can see, what we've been calling the &quot;line-input operator&quot;
			is really made of two components; the angle brackets (the real
			line-input operator) are around an input filehandle. Each line of
			input is then tested to see if it begins with <TT><FONT COLOR="#cc0000">root</FONT></TT>
			followed by a colon, triggering unseen actions. 
			</P>
			<P><A NAME="IXT-11-336389"></A><A NAME="IXT-11-336390"></A>A
			filehandle open for writing or appending may be used with <TT><FONT COLOR="#cc0000">print</FONT></TT>
			or <TT><FONT COLOR="#cc0000">printf</FONT></TT>, appearing
			immediately after the keyword but before the list of arguments: 
			</P>
			<PRE><FONT COLOR="#cc0000">print LOG &quot;Captain's log, stardate 3.14159\n&quot;;  # output goes to LOG</FONT>
<FONT COLOR="#cc0000">printf STDERR &quot;%d percent complete.\n&quot;, $done/$total * 100;</FONT></PRE><P>
			Did you notice that there's no comma between the filehandle and
			the items to be printed?<A HREF="#">[17]</A> This looks especially
			weird if you use parentheses. Either of these forms is correct: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP> If
			you got straight A's in freshman English or Linguistics, when we
			say that this is called &quot;indirect object syntax,&quot; you
			may say &quot;Ah, of course! I see why there's no comma after the
			filehandle name&iuml;&frac34;—it's an indirect object!&quot; We
			didn't get straight A's; we don't understand why there's no comma;
			we merely omit it because Larry told us that we should omit the
			comma.</P>
			<PRE><FONT COLOR="#cc0000">printf (STDERR &quot;%d percent complete.\n&quot;, $done/$total * 100);</FONT>
<FONT COLOR="#cc0000">printf STDERR (&quot;%d percent complete.\n&quot;, $done/$total * 100);</FONT></PRE><H4>
			<A NAME="lperl3-CHP-11-SECT-4.1"></A>11.4.1 Changing the Default
			Output Filehandle</H4>
			<P><A NAME="IXT-11-336391"></A><A NAME="IXT-11-336392"></A><A NAME="IXT-11-336393"></A><A NAME="IXT-11-336394"></A>
			By default, if you don't give a filehandle to <TT><FONT COLOR="#cc0000">print</FONT></TT>
			(or to <TT><FONT COLOR="#cc0000">printf</FONT></TT>, as everything
			we say here about one applies equally well to the other), the
			output will go to <TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>.
			But that default may be changed with the <TT><FONT COLOR="#cc0000">select</FONT></TT>
			operator. Here we'll send some output lines to <TT><FONT COLOR="#cc0000">BEDROCK</FONT></TT>:
			
			</P>
			<PRE><FONT COLOR="#cc0000">select BEDROCK;</FONT>
<FONT COLOR="#cc0000">print &quot;I hope Mr. Slate doesn't find out about this.\n&quot;;</FONT>
<FONT COLOR="#cc0000">print &quot;Wilma!\n&quot;;</FONT></PRE><P>
			Once you've selected a filehandle as the default for output, it
			will stay that way. But it's generally a bad idea to confuse the
			rest of the program, so you should generally set it back to <TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>
			when you're done.<A HREF="#">[18]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP> In
			the unlikely case that <TT><FONT COLOR="#cc0000">STDOUT</FONT></TT>
			might not be the selected filehandle, you could save and restore
			the filehandle, using the technique shown in the documentation for
			<TT><FONT COLOR="#cc0000">select</FONT></TT> in the perlfunc
			manpage. And as long as we're sending you to that manpage, we may
			as well tell you that there are actually two builtin functions in
			Perl named <TT><FONT COLOR="#cc0000">select</FONT></TT>, and both
			covered in the perlfunc manpage. The other <TT><FONT COLOR="#cc0000">select</FONT></TT>
			always has four arguments, so it's sometimes called &quot;four-argument
			<TT><FONT COLOR="#cc0000">select</FONT></TT>&quot;. 
			</P>
			<P><A NAME="IXT-11-336395"></A><A NAME="IXT-11-336396"></A>Also by
			default, the output to each filehandle is buffered. Setting the
			special <TT><FONT COLOR="#cc0000">$|</FONT></TT> variable to <TT><FONT COLOR="#cc0000">1</FONT></TT>
			will set the currently selected filehandle (that is, the one
			selected at the time that the variable is modified) to always
			flush the buffer after each output operation. So if you wanted to
			be sure that the logfile gets its entries at once, in case you
			might be reading the log to monitor progress of your long-running
			program, you could use something like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">select LOG;</FONT>
<FONT COLOR="#cc0000">$| = 1;  # don't keep LOG entries sitting in the buffer</FONT>
<FONT COLOR="#cc0000">select STDOUT;</FONT>
<FONT COLOR="#cc0000"># ... time passes, babies learn to walk, tectonic plates shift, and then...</FONT>
<FONT COLOR="#cc0000">print LOG &quot;This gets written to the LOG at once!\n&quot;;</FONT></PRE><P>
			<A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic31" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<P><A HREF="perl1.html">page 1</A><BR><A HREF="">page 2</A><BR><A HREF="perl3.html">page
3</A><BR><A HREF="perl4.html">page 4</A></P>
</BODY>
</HTML>