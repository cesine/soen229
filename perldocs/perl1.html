<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>perldocs page 1</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
	<META NAME="CREATED" CONTENT="20030217;13305000">
	<META NAME="CHANGED" CONTENT="20030220;17244300">
</HEAD>
<BODY LANG="en-US" BGCOLOR="#888888">
<P><A HREF="">page 1</A><BR><A HREF="perl2.html">page 2</A><BR><A HREF="perl3.html">page
3</A><BR><A HREF="perl4.html">page 4</A></P>
<P>Learning Perl, 3rd Edition <BR>By Tom Phoenix, Randal L. Schwartz 
</P>
<P>Publisher : O'Reilly <BR>Pub Date : July 2001 <BR>ISBN :
0-596-00132-0 <BR>Pages : 330 <BR>Slots : 1 
</P>
<P>Learning Perl is the quintessential tutorial for the Perl
programming language. The third edition has not only been updated to
Perl Version 5.6, but has also been rewritten from the ground up to
reflect the needs of programmers learning Perl today. Other books may
teach you to program in Perl, but this book will turn you into a Perl
programmer.</P>
<P STYLE="border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0cm; padding-right: 0cm">
<!-- find and replace

<TT>  -> <TT><font color="#CC0000">
</TT>  -> </font color="#CC0000"></TT>

<PRE>  -><PRE><font color="#CC0000">
</PRE>  -> </font color="#CC0000"></PRE>

find all img, change directory.. get the images

--><BR><BR>
</P>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-1-SECT-1"></A>1.1 Questions and Answers</H3>
			<P>You probably have some questions about Perl, and maybe even
			some about this book; especially if you've already flipped through
			the book to see what's coming. So we'll use this chapter to answer
			them. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-1.1"></A>1.1.1 Is This the Right
			Book for You?</H4>
			<P>If you're anything like us, you're probably standing in a
			bookstore right now,<A HREF="#">[2]</A> wondering whether you
			should get this Llama book and learn Perl, or maybe that book over
			there and learn some language named after a snake, or a beverage,
			or a letter of the alphabet.<A HREF="#">[3]</A> You've got about
			two minutes before the bookstore manager comes over to tell you
			that this isn't a library,<A HREF="#">[4]</A> and you need to buy
			something or get out. Maybe you want to use these two minutes to
			see a quick Perl program, so you'll know something about how
			powerful Perl is and what it can do. In that case, you should
			check out the whirlwind tour of Perl, later in this chapter. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP>
			Actually, if you're like us, you're standing in a library, not a
			bookstore. But we're tightwads.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP>
			Before you write to tell us that it's a comedy troupe, not a
			snake, we should really explain that we're dyslexically thinking
			of CORBA.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP>
			Unless it is.</P>
			<H4><A NAME="lperl3-CHP-1-SECT-1.2"></A>1.1.2 Why Are There So
			Many Footnotes?</H4>
			<P><A NAME="IXT-1-335762"></A>Thank you for noticing. There are a
			lot of footnotes in this book. Ignore them. They're needed because
			Perl is chock-full of exceptions to its rules. This is a good
			thing, as real life is chock-full of exceptions to rules. 
			</P>
			<P>But it means that we can't honestly say, &quot;The fizzbin
			operator frobnicates the hoozistatic variables&quot; without a
			footnote giving the exceptions.<A HREF="#">[5]</A> We're pretty
			honest, so we have to write the footnotes. But you can be honest
			without reading them. (It's funny how that works out.) 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[5]</SUP>
			Except on Tuesdays, during a power outage, when you hold your
			elbow at a funny angle during the equinox, or when <TT><FONT COLOR="#cc0000">use
			integer</FONT></TT> is in effect inside a loop block being called
			by a prototyped subroutine prior to Perl version 5.6.</P>
			<P><A NAME="IXT-1-335763"></A><A NAME="IXT-1-335764"></A><A NAME="IXT-1-335765"></A>
			Many of the exceptions have to do with portability. Perl began on
			Unix systems, and it still has deep roots in Unix. But wherever
			possible, we've tried to show when something may behave
			unexpectedly, whether that's because it's running on a non-Unix
			system, or for another reason. We hope that readers who know
			nothing about Unix will nevertheless find this book a good
			introduction to Perl. (And they'll learn a little about Unix along
			the way, at no extra charge.) 
			</P>
			<P>And many of the other exceptions have to do with the old
			&quot;80/20&quot; rule. By that we mean that 80% of the behavior
			of Perl can be described in 20% of the documentation, and the
			other 20 percent of the behavior takes up the other 80% of the
			documentation. So to keep this book small, we'll talk about the
			most common, easy-to-talk-about behavior in the main text, and
			hint in the direction of the other stuff in the footnotes (which
			are in a smaller font, so we can say more in the same space).<A HREF="#">[6]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP> We
			even discussed doing the entire book as a footnote to save the
			pagecount, but footnotes on footnotes started to get a bit crazy.</P>
			<P>Once you've read the book all the way through without reading
			the footnotes, you'll probably want to look back at some sections
			for reference. At that point, or if you become unbearably curious
			along the way, go ahead and read the notes. A lot of them are just
			computer jokes anyway. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-1.3"></A>1.1.3 What About the
			Exercises and Their Answers?</H4>
			<P><A NAME="IXT-1-335766"></A>The exercises are at the end of each
			chapter because, between the two of us, we've presented this same
			course material to several thousand students.<A HREF="#">[7]</A>
			We have carefully crafted these exercises to give you the chance
			to make mistakes as well. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP> Not
			all at once.</P>
			<P>It's not that we want you to make mistakes, but you need to
			have the chance. That's because you are going to make most of
			these mistakes during your Perl programming career, and it may as
			well be now. Any mistake that you make while reading this book you
			won't make again when you're writing a program on a deadline. And
			we're always here to help you out if something goes wrong, in the
			form of <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A#lperl3-APP-A">Appendix
			A</A>, which has our answer for each exercise and a little text to
			go with it, explaining the mistakes you made and a few you didn't.
			Check out the answers when you're done with the exercises. 
			</P>
			<P>Try not to peek at the answer until you've given the problem a
			good try, though. You'll learn better if you figure it out rather
			than if you read about it. 
			</P>
			<P>Even if you never make any mistakes, you should look at the
			answers when you're done; the accompanying text will point out
			some details of the program that might not be obvious at first. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-1.4"></A>1.1.4 What Do Those
			Numbers Mean at the Start of the Exercise?</H4>
			<P>Each exercise has a number in square brackets in front of the
			exercise text, looking something like this: 
			</P>
			<OL>
				<LI><P STYLE="font-weight: medium">[2] What does the number 2
				inside square brackets mean, when it appears at the start of an
				exercise's text? 
				</P>
			</OL>
			<P>That number is our (very rough) estimate of how many minutes
			you can expect to spend on that particular exercise. It's rough,
			so don't be too surprised if you're all done (with writing,
			testing, and debugging) in half that time, or not done in twice
			that long. On the other hand, if you're really stuck, we won't
			tell anyone that you peeked at <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A#lperl3-APP-A">Appendix
			A</A> to see what our answer looked like. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-1.5"></A>1.1.5 What If I'm a Perl
			Course Instructor?</H4>
			<P>If you're a Perl instructor who has decided to use this as your
			textbook (as many have over the years), you should know that we've
			tried to make each set of exercises short enough that most
			students could do the whole set in 45 minutes to an hour, with a
			little time left over for a break. Some chapters' exercises should
			be quicker, and some may take longer. That's because, once we had
			written all of those little numbers in square brackets, we
			discovered that we don't know how to add. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-1-SECT-2"></A>1.2 What Does &quot;Perl&quot;
			Stand For?</H3>
			<P><A NAME="lperl3-IDXTERM-10"></A><A NAME="lperl3-IDXTERM-11"></A><A NAME="lperl3-IDXTERM-12"></A><A NAME="lperl3-IDXTERM-13"></A>
			Perl is short for &quot; Practical Extraction and Report
			Language,&quot; although it has also been called a &quot;Pathologically
			Eclectic Rubbish Lister,&quot; among other expansions.<A HREF="#">[8]</A>
			There's no point in arguing which expansion is correct, because
			both of those are endorsed by Larry Wall, Perl's creator and chief
			architect, implementor, and maintainer. He created Perl in the
			mid-1980s when he was trying to produce some reports from a
			Usenet-news-like hierarchy of files for a bug-reporting system,
			and <I>awk</I> ran out of steam. Larry, being the lazy programmer
			that he is,<A HREF="#">[9]</A> decided to overkill the problem
			with a general-purpose tool that he could use in at least one
			other place. The result was Perl version zero. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> It's
			actually a retronym, not an acronym. That is, Larry came up with
			the name first, and the expansion later. That's why &quot;Perl&quot;
			isn't in all caps.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP>
			We're not insulting Larry by saying he's lazy; laziness is a
			virtue. The wheelbarrow was invented by someone who was too lazy
			to carry things; writing was invented by someone who was too lazy
			to memorize; Perl was invented by someone who was too lazy to get
			the job done without inventing a whole new computer language.</P>
			<H4><A NAME="lperl3-CHP-1-SECT-2.1"></A>1.2.1 Why Didn't Larry
			Just Use Some Other Language?</H4>
			<P>There's no shortage of computer languages, is there? But, at
			the time, Larry didn't see anything that really met his needs. If
			one of the other languages of today had been available back then,
			perhaps Larry would have used one of those. He needed something
			with the quickness of coding available in shell or <I>awk</I>
			programming, and with some of the power of more advanced tools
			like <I>grep</I>, <I>cut</I>, <I>sort</I>, and <I>sed</I>,<A HREF="#">[10]</A>
			without having to resort to a language like C. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[10]</SUP>
			Don't worry if you don't know what these are. All that matters is
			that they were the programs Larry had in his Unix toolbox, but
			they weren't up to the tasks at hand.</P>
			<P><A NAME="IXT-1-335767"></A><A NAME="IXT-1-335768"></A><A NAME="IXT-1-335769"></A>
			Perl tries to fill the gap between low-level programming (such as
			in C or C++ or assembly) and high-level programming (such as
			&quot;shell&quot; programming). Low-level programming is usually
			hard to write and ugly, but fast and unlimited; it's hard to beat
			the speed of a well-written low-level program on a given machine.
			And there's not much you can't do there. High-level programming,
			at the other extreme, tends to be slow, hard, ugly, and limited;
			there are many things you can't do at all with the shell, if
			there's no command on your system that provides the needed
			functionality. Perl is easy, nearly unlimited, mostly fast, and
			kind of ugly. 
			</P>
			<P>Let's take another look at those four claims we just made about
			Perl: 
			</P>
			<P>First, Perl is easy. As you'll see, though, this means it's
			easy to use. It's not especially easy to learn. If you drive a
			car, you spent many weeks or months learning that, and now it's
			easy to drive. When you've been programming Perl for about as many
			hours as it took you to learn to drive, Perl will be easy for
			you.<A HREF="#">[11]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP> But
			we hope you'll crash less often with the car.</P>
			<P>Perl is nearly unlimited. There are very few things you can't
			do with Perl. You wouldn't want to write a
			interrupt-microkernel-level device driver in Perl (even though
			that's been done), but most things that ordinary folks need most
			of the time are good tasks for Perl, from quick little one-off
			programs to major industrial-strength applications. 
			</P>
			<P>Perl is mostly fast. That's because nobody is developing Perl
			who doesn't also use it&iuml;&frac34;—so we all want it to be
			fast. If someone wants to add a feature that would be really cool,
			but which would slow down other programs, Larry is almost certain
			to refuse the new feature until we find a way to make it quick
			enough. 
			</P>
			<P><A NAME="IXT-1-335770"></A><A NAME="IXT-1-335771"></A><A NAME="IXT-1-335772"></A>
			Perl is kind of ugly. This is true. The symbol of Perl has become
			the camel, from the cover of the venerable Camel book (also known
			as Programming Perl ), a sister to this one. Camels are kind of
			ugly, too. But they work hard, even in tough conditions. Camels
			are there to get the job done despite all difficulties, even when
			they look bad and smell worse and sometimes spit at you. Perl is a
			little like that. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-2.2"></A>1.2.2 Is Perl Easy or
			Hard?</H4>
			<P>It's easy to use, but sometimes hard to learn. This is a
			generalization, of course. But in designing Perl, Larry has had to
			make many trade-offs. When he's had the chance to make something
			easier for the programmer at the expense of being more difficult
			for the student, he's decided in the programmer's favor nearly
			every time. That's because you'll learn Perl only once, but you'll
			use it again and again.<A HREF="#">[12]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP> If
			you're going to use a programming language for only a few minutes
			each week or month, you'd prefer one that is easier to learn,
			since you'll have forgotten nearly all of it from one use to the
			next. Perl is for people who are programmers for at least twenty
			minutes per day, and probably most of that in Perl.</P>
			<P><A NAME="IXT-1-335773"></A><A NAME="IXT-1-335774"></A>Perl has
			any number of conveniences that let the programmer save time. For
			example, most functions will have a default; frequently, the
			default is the way that you'll want to use the function. So you'll
			see lines of Perl code like these:<A HREF="#">[13]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP> We
			won't explain it all here, but this example pulls some data from
			an input file or files in one format and writes some of it out in
			another format. All of its features are covered in this book.</P>
			<PRE><FONT COLOR="#cc0000">while (&lt;&gt;) {</FONT>
<FONT COLOR="#cc0000">  chomp;</FONT>
<FONT COLOR="#cc0000">  print join(&quot;\t&quot;, (split /:/)[0, 2, 1, 5] ), &quot;\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-1-335775"></A>Written out in full, without using
			Perl's defaults and shortcuts, that snippet would be roughly ten
			or twelve times longer, so it would take much longer to read and
			write. It would be harder to maintain and debug, too, with more
			variables. If you already know some Perl, and you don't see the
			variables in that code, that's part of the point. They're all
			being used by default. But to have this ease at the programmer's
			tasks means paying the price when you're learning; you have to
			learn those defaults and shortcuts. 
			</P>
			<P><A NAME="IXT-1-335776"></A><A NAME="IXT-1-335777"></A>Once you
			become familiar with Perl, you may find yourself spending less
			time trying to get shell quoting (or C declarations) right, and
			more time surfing the Web, because Perl is a great tool for
			leverage. Perl's concise constructs allow you to create (with
			minimal fuss) some very cool one-up solutions or general tools.
			Also, you can drag those tools along to your next job, because
			Perl is highly portable and readily available, so you'll have even
			more time to surf. 
			</P>
			<P><A NAME="IXT-1-335778"></A>Perl is a very high-level language.
			That means that the code is quite dense; a Perl program may be
			around 30% to 70% as long as the corresponding program in C. This
			makes Perl faster to write, faster to read, faster to debug, and
			faster to maintain. It doesn't take much programming before you
			realize that, when the entire subroutine is small enough to fit
			onscreen all at once, you don't have to keep scrolling back and
			forth to see what's going on. Also, since the number of bugs in a
			program is roughly proportional to the length of the source
			code<A HREF="#">[14]</A> (rather than being proportional to the
			program's functionality), the shorter source in Perl will mean
			fewer bugs on average. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP>
			With a sharp jump when any one section of the program exceeds the
			size of your screen.</P>
			<P>Like any language, Perl can be &quot;write-only&quot;&iuml;&frac34;—it's
			possible to write programs that are impossible to read. But with
			proper care, you can avoid this common accusation. Yes, sometimes
			Perl looks like line-noise to the uninitiated, but to the seasoned
			Perl programmer, it looks like checksummed line-noise with a
			mission in life. If you follow the guidelines of this book, your
			programs should be easy to read and easy to maintain, and they
			probably won't win The Obfuscated Perl Contest.<A HREF="#">[15]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP> An
			actual annual event sponsored by the Perl Journal (at
			<A HREF="http://www.tpj.com/" TARGET="_blank">http://www.tpj.com/</A>
			).</P>
			<H4><A NAME="lperl3-CHP-1-SECT-2.3"></A>1.2.3 How Did Perl Get to
			Be So Popular?</H4>
			<P>After playing with Perl a bit, adding stuff here and there,
			Larry released it to the community of Usenet readers, commonly
			known as &quot;the Net.&quot; The users on this ragtag fugitive
			fleet of systems around the world (tens of thousands of them) gave
			him feedback, asking for ways to do this, that, or the other
			thing, many of which Larry had never envisioned his little Perl
			handling. 
			</P>
			<P>But as a result, Perl grew, and grew, and grew. It grew in
			features. It grew in portability. What was once a little language
			available on only a couple of Unix systems has now grown to have
			thousands of pages of free online documentation, dozens of books,
			several mainstream Usenet newsgroups (and a dozen newsgroups and
			mailing lists outside the mainstream) with an uncountable number
			of readers, and implementations on nearly every system in use
			today&iuml;&frac34;—and don't forget this Llama book as well. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-2.4"></A>1.2.4 What's Happening
			with Perl Now?</H4>
			<P><A NAME="IXT-1-335779"></A>Larry is still in charge of Perl,
			although the Perl development team is now made up of approximately
			thirty key people and a few hundred others from around the world.
			And Perl is still growing. 
			</P>
			<P>These days, Perl is still free for you to use. In fact, Larry
			promises that it will always be free. (He's a really nice guy;
			you'd like him.) So go ahead and write code in Perl today, without
			worrying that there will be a licensing fee on your program
			tomorrow. 
			</P>
			<P>So, if Perl is free, who pays Larry and the other Perl
			developers? Well, the majority of us contribute to Perl as a labor
			of love; Perl helps us, and we help Perl. (If you ever see some
			way in which you could improve Perl, we encourage you to send in
			your contributions, too.) In some cases, though, a person or firm
			has paid someone to do some development work. This may be because
			they needed some new functionality badly enough to pay for it, or
			because they wanted to make the world a better place. 
			</P>
			<P>Larry doesn't write all of the code these days, but he still
			guides the development and makes the big decisions. One of the
			most important rules he's given us is this one: &quot;Common
			things should be easy; advanced things should at least be
			possible.&quot; 
			</P>
			<P><A NAME="IXTR3-4"></A>Because of that rule, you can be sure
			that anything that you need to do frequently will have a shortcut
			in Perl. In fact, by the end of this book, you'll probably be
			using at least ten shortcuts in a typical ten-line program. That
			is the sort of thing that makes Perl easier to use, at the price
			of being harder to learn. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-2.5"></A>1.2.5 What's Perl Really
			Good For?</H4>
			<P><A NAME="IXT-1-335780"></A>Perl is good for quick-and-dirty
			programs that you whip up in three minutes. Perl is also good for
			long-and-extensive programs that will take a dozen programmers
			three years to finish. Of course, you'll probably find yourself
			writing many programs that take you less than an hour to complete,
			from the initial plan to the fully tested code. 
			</P>
			<P>Perl is optimized for problems which are about 90% working with
			text and about 10% everything else. That description seems to fit
			most programming tasks that pop up these days. In a perfect world,
			every programmer could know every language; you'd always be able
			to choose the best language for each project. Most of the time,
			you'd choose Perl.<A HREF="#">[16]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP>
			Don't just take our word for it, though. If you want to know
			whether Perl is better than language X, learn them both and try
			them both, then see which one you use most often. That's the one
			that's best for you. In the end, you'll understand Perl better
			because of your study of language X, and vice versa, so it will be
			time well spent.</P>
			<P>Although the Web wasn't even a twinkle in Tim Berners-Lee's eye
			when Larry created Perl, it was a marriage made on the Net. Some
			claim that the deployment of Perl in the early 1990s permitted
			lots of content to be moved into HTML format very rapidly, and the
			Web couldn't exist without content. Of course, Perl is the darling
			language for small CGI scripting (programs run by a web server) as
			well&iuml;&frac34;—so much so that many of the uninformed still
			make statements like &quot;Isn't CGI just Perl?&quot; or &quot;Why
			would you use Perl other than for CGI?&quot; We find those
			statements amusing. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-2.6"></A>1.2.6 What Is Perl Not
			Good For?</H4>
			<P>So, if it's good for so many things, what is Perl not good for?
			Well, you shouldn't choose Perl if you're trying to make an <I>opaque
			binary</I>. That's a program that you could give away or sell to
			someone who then can't see your secret algorithms in the source,
			and thus can't help you to maintain or debug your code either.
			When you give someone your Perl program, you'll normally be giving
			them the source, not an opaque binary. 
			</P>
			<P>If you're wishing for an opaque binary, though, we have to tell
			you that they don't exist. If someone can install and run your
			program, they can turn it back into source code. Granted, this
			won't necessarily be the same source that you started with, but it
			will be some kind of source code. The real way to keep your secret
			algorithm a secret is, alas, to apply the proper number of
			attorneys; they can write a license that says &quot;you can do
			this with the code, but you can't do that. And if you break our
			rules, we've got the proper number of attorneys to ensure that
			you'll regret it.&quot; 
			</P>
			<P>If you think you really want to compile your Perl code to make
			a binary, though, see <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-1-SECT-4#lperl3-CHP-1-SECT-4.3">Section
			1.4.3</A> later in this chapter. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic1" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-1-SECT-3"></A>1.3 How Can I Get Perl?</H3>
			<P><A NAME="IXT-1-335781"></A>You probably already have it. At
			least, we find Perl wherever we go. It ships with many systems,
			and system administrators often install it on every machine at
			their site.<A HREF="#">[17]</A> But if you can't find it already
			on your system, you can still get it for free. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP>
			Well, each machine that is made for programming, at least.</P>
			<P><A NAME="IXT-1-335782"></A><A NAME="IXT-1-335783"></A>Perl is
			distributed under two different licenses. For most people, since
			you'll merely be using it, either license is as good as the other.
			If you'll be modifying Perl, however, you'll want to read the
			licenses more closely, because they put some small restrictions on
			distributing the modified code. For people who won't modify Perl,
			the licenses essentially say &quot;it's free&iuml;&frac34;—have
			fun with it.&quot; 
			</P>
			<P>In fact, it's not only free, but it runs rather nicely on
			nearly everything that calls itself Unix and has a C compiler. You
			download it, type a command or two, and it starts configuring and
			building itself. Or, better yet, you get your system administrator
			to type those two commands and install it for you.<A HREF="#">[18]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP> If
			system administrators can't install software, what good are they?
			If you have trouble convincing your admin to install Perl, offer
			to buy a pizza. We've never met a sys admin who could say no to a
			free pizza, or at least counter-offer with something just as easy
			to get.</P>
			<P>Besides Unix and Unix-like systems, people have also been
			addicted enough to Perl to port it to other systems, like the
			Macintosh,<A HREF="#">[19]</A> VMS, OS/2, even MS/DOS and every
			modern species of Windows&iuml;&frac34;—and probably even more
			by the time you read this.<A HREF="#">[20]</A> Many of these <I>ports</I>
			of Perl come with an installation program that's even easier to
			use than the process for installing Perl on Unix. Check for links
			in the &quot;ports&quot; section on CPAN. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[19]</SUP>
			MacPerl runs under the &quot;classic&quot; Mac OS. If you have Mac
			OS X, which is a Unix-based system, you have mainstream Perl.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[20]</SUP> And
			no, as we write this, it won't fit in your Palm handheld&iuml;&frac34;—it's
			just too darn big, even stripped down.</P>
			<H4><A NAME="lperl3-CHP-1-SECT-3.1"></A>1.3.1 What Is CPAN?</H4>
			<P><A NAME="IXT-1-335784"></A><A NAME="IXT-1-335785"></A><I>CPAN</I>
			is the Comprehensive Perl Archive Network, your one-stop shopping
			for Perl. It has the source code for Perl itself, ready-to-install
			ports of Perl to all sorts of non-Unix systems,<A HREF="#">[21]</A>
			examples, documentation, extensions to Perl, and archives of
			messages about Perl. In short, CPAN is comprehensive. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[21]</SUP>
			It's nearly always better to compile Perl from the source on Unix
			systems. Other systems may not have a C compiler and other tools
			needed for compilation, so CPAN has binaries for these.</P>
			<P><A NAME="IXT-1-335786"></A>CPAN is replicated on hundreds of
			mirror machines around the world; start at <A HREF="http://www.cpan.org/" TARGET="_blank">http://www.cpan.org/</A>
			to find one near you. Most of the time, you can also simply visit
			http://<TT><FONT COLOR="#cc0000">COUNTRYCODE</FONT></TT>.cpan.org/
			where <TT><FONT COLOR="#cc0000">COUNTRYCODE</FONT></TT> is your
			two-letter official country code (like on the end of your national
			domain names). Or, if you don't have access to the Net, you might
			find a CD-ROM or DVD-ROM with all of the useful parts of CPAN on
			it; check with your local technical bookstore. Look for a recently
			minted archive, though; since CPAN changes daily, an archive from
			two years ago is an antique. (Better yet, get a kind friend with
			Net access to burn you one with today's CPAN.) 
			</P>
			<P><A NAME="IXT-1-335787"></A>CPAN is pretty-well organized; most
			of the time, you should find what you want with just a few clicks
			of the mouse. But there's also a couple of nice search interfaces
			on the Web at <A HREF="http://search.cpan.org/" TARGET="_blank">http://search.cpan.org/</A>
			and <A HREF="http://kobesearch.cpan.org/" TARGET="_blank">http://kobesearch.cpan.org/</A>,which
			are especially helpful when you're looking for an extension to
			Perl. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-3.2"></A>1.3.2 How Can I Get
			Support for Perl?</H4>
			<P><A NAME="lperl3-IDXTERM-36"></A><A NAME="lperl3-IDXTERM-37"></A><A NAME="IXT-1-335788"></A><A NAME="IXT-1-335789"></A>
			Well, you get the complete source&iuml;&frac34;—so you get to
			fix the bugs yourself! 
			</P>
			<P>That doesn't sound so good, does it? But it really is a good
			thing. Since there's no &quot;source code escrow&quot; on Perl,
			anyone can fix a bug&iuml;&frac34;—in fact, by the time you've
			found and verified a bug, someone else has probably already got a
			fix for it. There are thousands of people around the world who
			help to maintain Perl. 
			</P>
			<P>Now, we're not saying that Perl has a lot of bugs. But it's a
			program, and every program has at least one bug.<A HREF="#">[22]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[22]</SUP>
			Programmers also know that every program has at least one line of
			unnecessary source code. By combining these two rules and using
			logical induction, it's a simple matter to prove that any program
			could be reduced to a single line of code with a bug.</P>
			<P>To see why it's so useful to have the source to Perl, imagine
			that instead of using Perl, you licensed a programming language
			called Forehead from a giant, powerful corporation owned by a
			zillionaire with a bad haircut. (This is all hypothetical.
			Everyone knows there's no such programming language as Forehead.)
			Now think of what you can do when you find a bug in Forehead.
			First, you can report it; second, you can hope&iuml;&frac34;—hope
			that they fix the bug, hope that they fix it soon, hope that they
			won't charge too much for the new version. You can hope that the
			new version doesn't add new features with new bugs, and hope that
			the giant company doesn't get broken up in an anti-trust lawsuit. 
			</P>
			<P>But with Perl, you've got the source. In the rare and unlikely
			event that you can't get a bug fixed any other way, you can hire a
			programmer or ten and get to work. For that matter, if you buy a
			new machine that Perl doesn't yet run on, you can port it
			yourself. Or if you need a feature that doesn't yet exist, well,
			you know what to do. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-3.3"></A>1.3.3 Are There Any Other
			Kinds of Support?</H4>
			<P>Sure; one of our favorites is the Perl Mongers. This is a
			worldwide association of Perl users' groups; see
			<A HREF="http://www.pm.org/" TARGET="_blank">http://www.pm.org/</A>
			for more information. There's probably a group near you with an
			expert or someone who knows an expert. If there's no group, you
			can easily start one. 
			</P>
			<P><A NAME="IXT-1-335790"></A><A NAME="IXT-1-335791"></A><A NAME="IXT-1-335792"></A>
			Of course, for the first line of support, you shouldn't neglect
			the documentation. Besides the manpages<A HREF="#">[23]</A>
			themselves, Perl's documentation includes the voluminous FAQ
			(Frequently Asked Questions) and many tutorials. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[23]</SUP> The
			term <I>manpages </I>is a Unix-ism meaning documentation. If
			you're not on a Unix system, the manpages for Perl should be
			available via your system's native documentation system. If you
			can't find them anywhere else, the manpages are available directly
			on CPAN.</P>
			<P><A NAME="IXT-1-335793"></A><A NAME="IXT-1-335794"></A><A NAME="IXT-1-335795"></A><A NAME="IXT-1-335796"></A><A NAME="IXT-1-335797"></A>
			Another authoritative source is the book Programming Perl,
			commonly known as &quot;the Camel book&quot; because of its cover
			animal (just as this book has come to be known as &quot;the Llama
			book&quot;). The Camel book contains the complete reference
			information, some tutorial stuff, and a bunch of miscellaneous
			information about Perl. There's also a separate pocket-sized quick
			reference to Perl (by Johan Vromans) that's handy to keep at hand
			(or in your pocket). 
			</P>
			<P><A NAME="IXT-1-335798"></A><A NAME="IXT-1-335799"></A><A NAME="IXT-1-335800"></A>
			If you need to ask a question of someone, there are newsgroups on
			Usenet and any number of mailing lists.<A HREF="#">[24]</A> At any
			hour of the day or night, there's a Perl expert awake in some
			timezone answering questions on Usenet's Perl newsgroups&iuml;&frac34;—the
			sun never sets on the Perl empire. This means that if you ask a
			question, you'll often get an answer within minutes. If you didn't
			check the documentation and FAQ first, you'll get flamed within
			minutes. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[24]</SUP>
			Many mailing lists are listed at <A HREF="http://lists.perl.org/" TARGET="_blank">http://lists.perl.org</A>.</P>
			<P><A NAME="IXT-1-335801"></A>We generally recommend the newsgroup
			comp.lang.perl.moderated, where (as the name implies) a moderator
			will check over your question before posting it. If there's
			something wrong with your question, you'll still get flamed of
			course, but it's a small, private flame in email rather than a big
			public one in a newsgroup.<A HREF="#">[25]</A> But for most
			questions, you'll get an answer back within the hour. Just try
			getting that level of support from your favorite software vendor
			for free! 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[25]</SUP> Of
			course, we're joking here. Unless you've done something amazingly
			boneheaded, the moderators are all kind, polite, helpful folks,
			who will gently point you in the direction of the information you
			need, with just enough flame to remind you to be more careful next
			time. Don't be afraid to ask.</P>
			<P>The official Perl newsgroups on Usenet are located in the
			comp.lang.perl.* part of the hierarchy. As of this writing, there
			are five of them, but they change from time to time. You (or
			whoever is in charge of Perl at your site) should generally
			subscribe to comp.lang.perl.announce, which is a low-volume
			newsgroup just for important announcements about Perl, including
			especially any security-related announcements. Ask your local
			expert if you need help with Usenet. 
			</P>
			<P><A NAME="IXT-1-335802"></A><A NAME="IXT-1-335803"></A>Also, a
			few web communities have sprung up around Perl discussions. One
			very popular one, known as The Perl Monastery
			(<A HREF="http://www.perlmonks.org/" TARGET="_blank">http://www.perlmonks.org</A>)
			has seen quite a bit of participation from many Perl book and
			column authors, including at least one of the authors of this
			book. 
			</P>
			<P><A NAME="IXTR3-5"></A><A NAME="IXTR3-6"></A>If you find
			yourself needing a support contract for Perl, there are a number
			of firms who are willing to charge as much as you'd like. In most
			cases, these other support avenues will take care of you for free.
						</P>
			<H4><A NAME="lperl3-CHP-1-SECT-3.4"></A>1.3.4 What If I Find a Bug
			in Perl?</H4>
			<P>The first thing to do when you find a bug is to check the
			documentation<A HREF="#">[26]</A> again.<A HREF="#">[27]</A> Perl
			has so many special features and exceptions to rules that you may
			have discovered a feature, not a bug. Also, check that you don't
			have an older version of Perl; maybe you found something that's
			been fixed in a more recent version. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[26]</SUP>
			Even Larry admits to consulting the documentation from time to
			time.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[27]</SUP>
			Maybe even twice or three times. Many times, we've gone into the
			documentation looking to explain a particular unexpected behavior
			and found some new little nuance that ends up on a slide or in a
			column.</P>
			<P>Once you're 99% certain that you've found a real bug, ask
			around. Ask someone at work, at your local Perl Mongers' meeting,
			or at a Perl conference. Chances are, it's still a feature, not a
			bug. 
			</P>
			<P><A NAME="IXT-1-335804"></A><A NAME="IXT-1-335805"></A><A NAME="IXT-1-335806"></A><A NAME="IXT-1-335807"></A><A NAME="IXT-1-335808"></A>
			Once you're 100% certain that you've found a real bug, cook up a
			test case (if you haven't done so already). The ideal test case is
			a tiny self-contained program that any Perl user could run to see
			the same (mis-)behavior as you've found. Once you've got a test
			case that clearly shows the bug, use the <I>perlbug</I> utility
			(which comes with Perl) to report the bug. That will normally send
			email from you to the Perl developers, so don't use <I>perlbug</I>
			until you've got your test case ready. 
			</P>
			<P>Once you've sent off your bug report, if you've done everything
			right, it's not unusual to get a response within minutes.
			Typically, you can apply a simple patch and get right back to
			work. Of course, you may (at worst) get no response at all; the
			Perl developers are under no obligation to even read your bug
			reports. But all of us love Perl, so nobody likes to let a bug
			escape our notice. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-1-SECT-4"></A>1.4 How Do I Make a Perl
			Program?</H3>
			<P><A NAME="lperl3-IDXTERM-61"></A>It's about time you asked (even
			if you didn't). Perl programs are text files; you can create and
			edit them with your favorite text editor. (You don't need any
			special development environment, although there are some
			commercial ones available from various vendors. We've never used
			any of these enough to recommend them.) 
			</P>
			<P><A NAME="IXT-1-335809"></A><A NAME="IXT-1-335810"></A><A NAME="IXT-1-335811"></A><A NAME="IXT-1-335812"></A>
			You should generally use a programmers' text editor, rather than
			an ordinary editor. What's the difference? Well, a programmers'
			text editor will let you do things that programmers need, like to
			indent or unindent a block of code, or to find the matching
			closing curly brace for a given opening curly brace. On Unix
			systems, the two most popular programmers' editors are <I>emacs</I>
			and <I>vi</I> (and their variants and clones). Both of these have
			been ported to several non-Unix systems, and many systems today
			offer a graphical editor (which uses a pointing device like a
			mouse). In fact, there are even versions of <I>vi</I> and <I>emacs</I>
			that offer a graphical interface. Ask your local expert about text
			editors on your system. 
			</P>
			<P>For the simple programs you'll be writing for the exercises in
			this book, none of which will need to be more than about twenty or
			thirty lines of code, any text editor will be fine. 
			</P>
			<P><A NAME="IXT-1-335813"></A>A few beginners try to use a word
			processor instead of a text editor. We recommend against
			this&iuml;&frac34;—it's inconvenient at best and impossible at
			worst. But we won't try to stop you. Be sure to tell the word
			processor to save your file as &quot;text only&quot;; the word
			processor's own format will almost certainly be unusable. 
			</P>
			<P><A NAME="IXT-1-335814"></A><A NAME="IXT-1-335815"></A><A NAME="IXT-1-335816"></A>
			In some cases, you may need to compose the program on one machine,
			then transfer it to another to be run. If you do this, be sure
			that the transfer uses &quot;text&quot; or &quot;ASCII&quot; mode,
			and not &quot;binary&quot; mode. This step is needed because of
			the different text formats on different machines. Without that,
			you may get inconsistent results&iuml;&frac34;—some versions of
			Perl actually abort when they detect a mismatch in the line
			endings. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-4.1"></A>1.4.1 A Simple Program</H4>
			<P><A NAME="IXT-1-335817"></A>According to the oldest rule in the
			book, any book about a computer language that has Unix-like roots
			has to start with showing the &quot;Hello, world&quot; program.
			So, here it is in Perl: 
			</P>
			<PRE><FONT COLOR="#cc0000">#!/usr/bin/perl</FONT>
<FONT COLOR="#cc0000">print &quot;Hello, world!\n&quot;;</FONT></PRE><P>
			<A NAME="IXT-1-335818"></A><A NAME="IXT-1-335819"></A><A NAME="IXT-1-335820"></A>
			Let's imagine that you've typed that into your text editor. (Don't
			worry yet about what the parts mean and how it works. We'll see
			about those in a moment.) You can generally save that program
			under any name you wish. Perl doesn't require any special kind of
			filename or extension, and it's better to use no extension at
			all.<A HREF="#">[28]</A> But some non-Unix systems may require an
			extension like .plx (meaning PerL eXecutable); see your system's
			release notes for more information. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[28]</SUP> Why
			is it better to have no extension? Imagine that you've written a
			program to calculate bowling scores and you've told all of your
			friends that it's called <I>bowling.plx</I>. One day you decide to
			rewrite it in C. Do you still call it by the same name, implying
			that it's still written in Perl? Or do you tell everyone that it
			has a new name? (And don't call it <I>bowling.c</I>, please!) The
			answer is that it's none of their business what language it's
			written in, if they're merely using it. So it should have simply
			been called <I>bowling</I> in the first place.</P>
			<P><A NAME="IXT-1-335821"></A>You will also need to do something
			so that your system knows that it's an executable program (that
			is, a command). What you'll do depends upon your system; maybe you
			won't have to do anything more than to save the program in a
			certain place. (Your current directory will generally be fine.) On
			Unix systems, you mark a program as being executable by using the
			<I>chmod</I> command, perhaps like this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$ <B>chmod a+x my_program</B></FONT></PRE><P>
			The dollar sign (and space) at the start of the line represents
			the shell prompt, which will probably look different on your
			system. If you're used to using <I>chmod</I> with a number like
			<TT><FONT COLOR="#cc0000">755</FONT></TT> instead of a symbolic
			parameter like <TT><FONT COLOR="#cc0000">a+x</FONT></TT>, that's
			fine too, of course. Either way, it tells the system that this
			file is now a program. 
			</P>
			<P>Now you're ready to run it:</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$ <B>./my_program</B></FONT></PRE><P>
			<A NAME="IXT-1-335822"></A><A NAME="IXT-1-335823"></A><A NAME="IXT-1-335824"></A>
			The dot and slash at the start of this command mean to find the
			program in the current working directory. That's not needed in all
			cases, but you should use it at the start of each command
			invocation until you fully understand what it's doing.<A HREF="#">[29]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[29]</SUP> In
			short, it's preventing your shell from running another program (or
			shell builtin) of the same name. A common mistake among beginners
			is to name their first program <TT><FONT COLOR="#cc0000">test</FONT></TT>.
			Many systems already have a program (or shell builtin) with that
			name; that's what the beginners run instead of their program.</P>
			<P>If everything worked, it's a miracle. More often, you'll find
			that your program has a bug. Edit and try again&iuml;&frac34;—but
			you don't need to use <I>chmod</I> each time, since that should
			&quot;stick&quot; to the file. (Of course, if the bug is that you
			didn't use <I>chmod</I> correctly, you'll probably get a
			&quot;permission denied&quot; message from your shell.) 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-4.2"></A>1.4.2 What's Inside That
			Program?</H4>
			<P><A NAME="IXT-1-335825"></A><A NAME="IXT-1-335826"></A><A NAME="IXT-1-335827"></A><A NAME="IXT-1-335828"></A><A NAME="IXT-1-335829"></A>
			Like other &quot;free-form&quot; languages, Perl generally lets
			you use insignificant whitespace (like spaces, tabs, and newlines)
			at will to make your program easier to read. Most Perl programs
			use a fairly standard format, though, much like most of what we
			show here. We strongly encourage you to properly indent your
			programs, since that makes your program easier to read; a good
			text editor will do most of the work for you. Good comments also
			make a program easier to read. In Perl, comments run from a pound
			sign (<TT><FONT COLOR="#cc0000">#</FONT></TT>) to the end of the
			line. (There are no &quot;block comments&quot; in Perl.<A HREF="#">[30]</A>)
			We don't use many comments in the programs in this book, because
			the surrounding text explains their workings, but you should use
			comments as needed in your own programs. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[30]</SUP> But
			there are a number of ways to fake them. See the FAQ (accessible
			with perldocperlfaq on most installations).</P>
			<P>So another way (a very strange way, it must be said) to write
			that same &quot;Hello, world&quot; program might be like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">#!/usr/bin/perl</FONT>
<FONT COLOR="#cc0000">    print    # This is a comment</FONT>
<FONT COLOR="#cc0000">&quot;Hello, world!\n&quot;</FONT>
<FONT COLOR="#cc0000">  ;    # Don't write your Perl code like this!</FONT></PRE><P>
			<A NAME="IXT-1-335830"></A>That first line is actually a very
			special comment. On Unix systems,<A HREF="#">[31]</A> if the very
			first two characters on the first line of a text file are &quot;<TT><FONT COLOR="#cc0000">#!</FONT></TT>&quot;,
			then what follows is the name of the program that actually
			executes the rest of the file. In this case, the program is stored
			in the file <I>/usr/bin/perl</I>. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[31]</SUP>
			Most modern ones, anyway. The &quot;sh-bang&quot; mechanism was
			introduced somewhere in the mid-1980s, and that's pretty ancient,
			even on the extensively long Unix timeline.</P>
			<P><A NAME="IXT-1-335831"></A><A NAME="IXT-1-335832"></A>This <TT><FONT COLOR="#cc0000">#!</FONT></TT>
			line is actually the least portable part of a Perl program,
			because you'll need to find out what goes there for each machine.
			Fortunately, it's almost always either <I>/usr/bin/perl</I> or
			<I>/usr/local/bin/perl</I>. If you find that it's not, you can
			cast a magic spell on your system administrator to fix things.
			Just say &quot;You know, I read in a book that both <I>/usr/bin/perl</I>
			and <I>/usr/local/bin/perl</I> should be symbolic links to the
			true Perl binary,&quot; and under the influence of your spell the
			admin will make everything work. All of the example programs
			you're likely to find on the Net and elsewhere will begin with one
			of those two forms. 
			</P>
			<P><A NAME="IXT-1-335833"></A>On non-Unix systems, it's
			traditional (and even useful) to make the first line say <TT><FONT COLOR="#cc0000">#!perl</FONT></TT>.
			If nothing else, it tells your maintenance programmer as soon as
			he or she gets ready to fix it that it's a Perl program. 
			</P>
			<P>If that <TT><FONT COLOR="#cc0000">#!</FONT></TT> line is wrong,
			you'll generally get an error from your shell. This may be
			something unexpected, like &quot;file not found.&quot; It's not
			your program that's not found, though; it's <I>/usr/bin/perl</I>
			that wasn't where it should have been. We'd make the message
			clearer, but it's not coming from Perl; it's the shell that's
			complaining. (By the way, you should be careful to spell it <I>usr</I>
			and not <I>user</I>&iuml;&frac34;—the folks who invented Unix
			were lazy typists, so they omitted a lot of letters.) 
			</P>
			<P><A NAME="IXT-1-335834"></A>Another problem you could have is if
			your system doesn't support the <TT><FONT COLOR="#cc0000">#!</FONT></TT>
			line at all. In that case, your shell (or whatever your system
			uses) will probably try to run your program all by itself, with
			results that may disappoint or astonish you. If you can't figure
			out what some strange error message is telling you, search for it
			in the perldiag manpage. 
			</P>
			<P><A NAME="IXT-1-335835"></A>The &quot;main&quot; program
			consists of all of the ordinary Perl statements (not including
			anything in subroutines, which we'll see later). There's no &quot;main&quot;
			routine, as there is in languages like C or Java. In fact, many
			programs don't even have routines (in the form of subroutines). 
			</P>
			<P><A NAME="IXT-1-335836"></A>There's also no required variable
			declaration section, as there is in some other languages. If
			you've always had to declare your variables, you may be startled
			or unsettled by this at first. But it allows us to write
			&quot;quick-and-dirty&quot; Perl programs. If your program is only
			two lines long, you don't want to have to use one of those lines
			just to declare your variables. If you really want to declare your
			variables, that's a good thing; we'll see how to do that in
			<A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-4#lperl3-CHP-4">Chapter
			4</A>. 
			</P>
			<P><A NAME="IXT-1-335837"></A><A NAME="IXT-1-335838"></A>Most
			statements are an expression followed by a semicolon. Here's the
			one we've seen a few times so far: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">print &quot;Hello, world!\n&quot;;</FONT></PRE><P>
			<A NAME="IXT-1-335839"></A><A NAME="IXT-1-335840"></A>As you may
			have guessed by now, this line prints the message <TT><FONT COLOR="#cc0000">Hello,</FONT></TT>
			<TT><FONT COLOR="#cc0000">world!</FONT></TT> At the end of that
			message is the shortcut <TT><FONT COLOR="#cc0000">\n</FONT></TT>,
			which is probably familiar to you if you've used another language
			like C, C++, or Java; it means a newline character. When that's
			printed after the message, the print position drops down to the
			start of the next line, allowing the following shell prompt to
			appear on a line of its own, rather than being attached to the
			message. Every line of output should end with a newline character.
			We'll see more about the newline shortcut and other so-called
			backslash escapes in the next chapter. 
			</P>
			<H4><A NAME="lperl3-CHP-1-SECT-4.3"></A>1.4.3 But How Do I Compile
			Perl?</H4>
			<P><A NAME="IXT-1-335841"></A><A NAME="IXT-1-335842"></A><A NAME="IXT-1-335843"></A>
			You may be surprised to learn that all you have to do to compile
			Perl is to run it. When you run your program, Perl's internal
			compiler first runs through your entire source, turning it into
			internal <I>bytecodes</I> (an internal data structure representing
			the program); then Perl's bytecode engine actually runs them.<A HREF="#">[32]</A>
						</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[32]</SUP> As
			usual, there's more to the story than what we say here. But this
			should be close enough for all but the technically advanced folks,
			and they already know about this.</P>
			<P>So, if there's a syntax error on line 200, you'll get that
			error message before you start running line two.<A HREF="#">[33]</A>
			If you have a loop that runs 5000 times, it's compiled just once;
			the actual loop can then run at top speed. And there's no runtime
			penalty for using as many comments and as much whitespace as you
			need to make your program easy to understand. You can even use
			calculations involving only constants, and the result is a
			constant computed once as the program is beginning&iuml;&frac34;—not
			each time through a loop. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[33]</SUP>
			Unless line two happens to be a compile-time operation, like a
			<TT><FONT COLOR="#cc0000">BEGIN</FONT></TT> block or a <TT><FONT COLOR="#cc0000">use</FONT></TT>
			invocation.</P>
			<P><A NAME="IXT-1-335844"></A>To be sure, this compilation does
			take time&iuml;&frac34;—it's inefficient to have a voluminous
			Perl program that does one small quick task (out of many potential
			tasks, say) and then exits, because the runtime for the program
			will be dwarfed by the compile time. But the compiler is very
			fast; normally the compilation will be a tiny percentage of the
			runtime. 
			</P>
			<P><A NAME="IXT-1-335845"></A><A NAME="IXT-1-335846"></A><A NAME="IXT-1-335847"></A>
			An exception might be if you were writing a program to be run over
			the Web, where it may be called hundreds or thousands of times
			every minute. (This is a very high usage rate. If it were called a
			few hundreds or thousands of times per day, like most programs on
			the Web, we probably wouldn't worry too much about it.) Many of
			these programs have very short runtimes, so the issue of
			recompilation may become significant. If this is an issue for you,
			you'll want to find a way to keep your program resident in memory
			between invocations (whether it's written in Perl or not); see the
			documentation for your web server and ask your local expert for
			help with this.<A HREF="#">[34]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[34]</SUP>
			Point your local expert to <A HREF="http://perl.apache.org/" TARGET="_blank">http://perl.apache.org</A>for
			one possible solution.</P>
			<P><A NAME="IXTR3-7"></A>What if you could save the compiled
			bytecodes to avoid the overhead of compilation? Or, even better,
			what if you could turn the bytecodes into another language, like
			C, and then compile that? Well, both of these things are possible
			(although beyond the scope of this book), although they won't make
			most programs any easier to use, maintain, debug, or install, and
			they may (for somewhat technical reasons) make your program even
			slower.<A HREF="#">[35]</A> We don't know anyone who has ever
			needed to compile a Perl program (except for experimental
			purposes), and we doubt you ever will ever meet one, either. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[35]</SUP> On
			many (perhaps most) systems where you might want to compile a Perl
			program, the perl binary (the program that executes your Perl
			programs) is always in use by some process, so it's always
			resident in memory. A &quot;compiled Perl&quot; program will take
			time to load into memory. If it's a small program, it would
			probably compile at least as fast as it takes to load a compiled
			executable. If it's a large one, compilation is probably an
			insignificant part of its runtime anyway.</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-1-SECT-5"></A>1.5 A Whirlwind Tour of Perl</H3>
			<P><A NAME="IXT-1-335848"></A>So, you want to see a real Perl
			program with some meat? (If you don't, just play along for now.)
			Here you are: 
			</P>
			<PRE><FONT COLOR="#990000">#!/usr/bin/perl</FONT>
<FONT COLOR="#990000">@lines = `perldoc -u -f atan2`;</FONT>
<FONT COLOR="#990000">foreach (@lines) {</FONT>
<FONT COLOR="#990000">  s/\w&lt;([^&gt;]+)&gt;/\U$1/g;</FONT>
<FONT COLOR="#990000">  print;</FONT>
<FONT COLOR="#990000">}</FONT></PRE><P>
			Now, the first time you see Perl code like this, it can seem
			pretty strange. (In fact, every time you see Perl code like this,
			it can seem pretty strange.) But let's take it line by line, and
			see what this example does. (These explanations are very brief;
			this is a whirlwind tour, after all. We'll see all of this
			program's features in more detail during the rest of this book.
			You're not really supposed to understand the whole thing until
			later.) 
			</P>
			<P><A NAME="IXT-1-335849"></A>The first line is the <TT><FONT COLOR="#990000">#!</FONT></TT>
			line, as we saw before. You might need to change that line for
			your system, as we discussed earlier. 
			</P>
			<P><A NAME="IXT-1-335850"></A><A NAME="IXT-1-335851"></A><A NAME="IXT-1-335852"></A>
			The second line runs an external command, named within backquotes
			(&quot;<TT><FONT COLOR="#990000">` `</FONT></TT>&quot;). (The
			backquote key is often found next to the number 1 on full-sized
			American keyboards. Be sure not to confuse the backquote with the
			single quote, &quot;<TT><FONT COLOR="#990000">'</FONT></TT>&quot;.)
			The command we're using is <I>perldoc -u -f atan2</I>; try typing
			that at your command line to see what its output looks like. The
			<I>perldoc</I> command is used on most systems to read and display
			the documentation for Perl and its associated extensions and
			utilities, so it should normally be available.<A HREF="#">[36]</A>
			This command tells you something about the trigonometric function
			<TT><FONT COLOR="#990000">atan2</FONT></TT>; we're using it here
			just as an example of an external command whose output we wish to
			process. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[36]</SUP> If
			<I>perldoc </I>is not available, that probably means that your
			system doesn't have a command-line interface, and your Perl can't
			run commands (like <I>perldoc</I>) in backticks or via the
			piped-open, which we'll see in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-14#lperl3-CHP-14">Chapter
			14</A>. In that case, you should simply skip the exercises that
			use <I>perldoc</I>.</P>
			<P><A NAME="IXT-1-335853"></A>The output of that command in the
			backticks is saved in an array variable called <TT><FONT COLOR="#990000">@lines</FONT></TT>.
			The next line of code starts a loop that will process each one of
			those lines. Inside the loop, the statements are indented.
			Although Perl doesn't require this, good programmers do. 
			</P>
			<P><A NAME="IXT-1-335854"></A><A NAME="IXT-1-335855"></A>The first
			line inside the loop body is the scariest one; it says
			<TT><FONT COLOR="#990000">s/\w&lt;([^&gt;]+)&gt;/\U$1/g;</FONT></TT>.
			Without going into too much detail, we'll just say that this can
			change any line that has a special marker made with angle brackets
			(<TT><FONT COLOR="#990000">&lt; &gt;</FONT></TT>), and there
			should be at least one of those in the output of the <I>perldoc</I>
			command. 
			</P>
			<P>The next line, in a surprise move, prints out each (possibly
			modified) line. The resulting output should be similar to what
			<I>perldoc -u -f atan2</I> would do on its own, but there will be
			a change where any of those markers appears. 
			</P>
			<P><A NAME="IXTR3-8"></A>Thus, in the span of a few lines, we've
			run another program, saved its output in memory, updated the
			memory items, and printed them out. This kind of program is a
			fairly common use of Perl, where one type of data is converted to
			another. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic2" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-1-SECT-6"></A>1.6 Exercises</H3>
			<P>Normally, each chapter will end with some exercises, with the
			answers in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A#lperl3-APP-A">Appendix
			A</A>. But in this chapter, the answers were already provided. 
			</P>
			<P>If you can't get these exercises to work on your machine,
			double-check your work and then consult your local expert.
			Remember that you may need to change each program a little, as
			described in the text. 
			</P>
			<OL>
				<LI><P>[7] Type in the &quot;Hello, world&quot; program and get
				it to work! (You may name it anything you wish, but a good name
				might be <TT><FONT COLOR="#990000">ex1-1</FONT></TT>, for
				simplicity, since it's exercise 1 in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-1#lperl3-CHP-1">Chapter
				1</A>.) 
				</P>
				<LI><P STYLE="font-weight: medium">[5] Type the command <I>perldoc
				-u -f atan2</I> at a command prompt and note its output. If you
				can't get that to work, then find out from a local administrator
				or the documentation for your version of Perl about how to invoke
				<I>perldoc</I> or its equivalent. (You'll need this for the next
				exercise anyway.) 
				</P>
				<LI><P STYLE="font-weight: medium">[6] Type in the second example
				program (from the previous section) and see what it prints.
				(Hint: Be careful to type those punctuation marks exactly as
				shown!) Do you see how it changed the output of the command? 
				</P>
			</OL>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic3" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-1"></A>2.1 What Is Scalar Data?</H3>
			<P><A NAME="lperl3-IDXTERM-111"></A>In English, as in many other
			spoken languages, we're used to distinguishing between singular
			and plural. As a computer language designed by a human linguist,
			Perl is similar. As a general rule, when Perl has just one of
			something, that's a scalar.<A HREF="#">[1]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP> This
			has little to do with the similar term from mathematics or physics
			in that a scalar is a single thing; there are no &quot;vectors&quot;
			in Perl. 
			</P>
			<P>A scalar is the simplest kind of data that Perl manipulates.
			Most scalars are either a number (like 255 or 3.25e20) or a string
			of characters (like <TT><FONT COLOR="#990000">hello</FONT></TT><A HREF="#">[2]</A>
			or the Gettysburg Address). Although you may think of numbers and
			strings as very different things, Perl uses them nearly
			interchangeably. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> If
			you have been using other programming languages, you may think of
			<TT><FONT COLOR="#990000">hello</FONT></TT> as a collection of
			five characters, rather than as a single thing. But in Perl, a
			string is a single scalar value. Of course, we can access the
			individual characters when we need to; we'll see how to do that in
			later chapters.</P>
			<P>A scalar value can be acted upon with operators (like addition
			or concatenate), generally yielding a scalar result. A scalar
			value can be stored into a scalar variable. Scalars can be read
			from files and devices, and can be written out as well. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic4" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-2"></A>2.2 Numbers</H3>
			<P><A NAME="lperl3-IDXTERM-112"></A><A NAME="lperl3-IDXTERM-113"></A>
			Although a scalar is most often either a number or a string, it's
			useful to look at numbers and strings separately for the moment.
			We'll cover numbers first, and then move on to strings. 
			</P>
			<H4><A NAME="lperl3-CHP-2-SECT-2.1"></A>2.2.1 All Numbers Are the
			Same Format Internally</H4>
			<P><A NAME="IXT-2-335856"></A><A NAME="IXT-2-335857"></A><A NAME="IXT-2-335858"></A>
			As you'll see in the next few paragraphs, you can specify both
			integers (whole numbers, like 255 or 2001) and floating-point
			numbers (real numbers with decimal points, like 3.14159, or 1.35 x
			1025). But internally, Perl computes with double-precision
			floating-point values.<A HREF="#">[3]</A> This means that there
			are no integer values internal to Perl&iuml;&frac34;—an integer
			constant in the program is treated as the equivalent
			floating-point value.<A HREF="#">[4]</A> You probably won't notice
			the conversion (or care much), but you should stop looking for
			distinct integer operations (as opposed to floating-point
			operations), because there aren't any.<A HREF="#">[5]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP> A
			double-precision floating-point value is whatever the C compiler
			that compiled Perl used for a <TT><FONT COLOR="#990000">double</FONT></TT>
			declaration. While the size may vary from machine to machine, most
			modern systems use IEEE floating-point formats, which suggest 15
			digits of precision and a range of at least <TT><FONT COLOR="#990000">1e-100</FONT></TT>
			to <TT><FONT COLOR="#990000">1e100</FONT></TT>.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP>
			Well, Perl will sometimes use internal integers in ways that are
			not visible to the programmer. That is, the only difference you
			should generally be able to see is that your program runs faster.
			And who could complain about that?</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-2-335859"></A><A NAME="IXT-2-335860"></A>
			<SUP>[5]</SUP> Okay, there is the <TT><FONT COLOR="#990000">integer</FONT></TT>
			pragma. But using that is beyond the scope of this book. And yes,
			some operations force an integer to be computed from a given
			floating-point number, as we'll see later. But that's not what
			we're talking about here.</P>
			<H4><A NAME="lperl3-CHP-2-SECT-2.2"></A>2.2.2 Floating-Point
			Literals</H4>
			<P><A NAME="IXT-2-335861"></A>A literal is the way a value is
			represented in the source code of the Perl program. A literal is
			not the result of a calculation or an I/O operation; it's data
			written directly into the source code. 
			</P>
			<P><A NAME="IXT-2-335862"></A>Perl's floating-point literals
			should look familiar to you. Numbers with and without decimal
			points are allowed (including an optional plus or minus prefix),
			as well as tacking on a power-of-10 indicator (exponential
			notation) with E notation. For example: 
			</P>
			<PRE><FONT COLOR="#990000">1.25</FONT>
<FONT COLOR="#990000">255.000</FONT>
<FONT COLOR="#990000">255.0</FONT>
<FONT COLOR="#990000">7.25e45  # 7.25 times 10 to the 45th power (a big number)</FONT>
<FONT COLOR="#990000">-6.5e24  # negative 6.5 times 10 to the 24th</FONT>
<FONT COLOR="#990000">         # (a big negative number)</FONT>
<FONT COLOR="#990000">-12e-24  # negative 12 times 10 to the -24th</FONT>
<FONT COLOR="#990000">         # (a very small negative number)</FONT>
<FONT COLOR="#990000">-1.2E-23 # another way to say that - the E may be uppercase</FONT></PRE><H4>
			<A NAME="lperl3-CHP-2-SECT-2.3"></A>2.2.3 Integer Literals</H4>
			<P><A NAME="IXT-2-335863"></A>Integer literals are also
			straightforward, as in: 
			</P>
			<PRE><FONT COLOR="#990000">0</FONT>
<FONT COLOR="#990000">2001</FONT>
<FONT COLOR="#990000">-40</FONT>
<FONT COLOR="#990000">255</FONT>
<FONT COLOR="#990000">61298040283768</FONT></PRE><P>
			<A NAME="IXT-2-335864"></A><A NAME="IXT-2-335865"></A>That last
			one is a little hard to read. Perl allows underscores for clarity
			within integer literals, so we can also write that number like
			this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">61_298_040_283_768</FONT></PRE><P>
			It's the same value; it merely looks different to us human beings.
			You might have thought that commas should be used for this
			purpose, but commas are already used for a more-important purpose
			in Perl (as we'll see in the next chapter). 
			</P>
			<H4><A NAME="lperl3-CHP-2-SECT-2.4"></A>2.2.4 Nondecimal Integer
			Literals</H4>
			<P><A NAME="IXT-2-335866"></A><A NAME="IXT-2-335867"></A><A NAME="IXT-2-335868"></A><A NAME="IXT-2-335869"></A>
			Like many other programming languages, Perl allows you to specify
			numbers in other than base 10 (decimal). Octal (base 8) literals
			start with a leading <TT><FONT COLOR="#990000">0</FONT></TT>,
			hexadecimal (base 16) literals start with a leading <TT><FONT COLOR="#990000">0x</FONT></TT>,
			and binary (base 2) literals start with a leading <TT><FONT COLOR="#990000">0b</FONT></TT>.<A HREF="#">[6]</A>
			The hex digits <TT><FONT COLOR="#990000">A</FONT></TT> through <TT><FONT COLOR="#990000">F</FONT></TT>
			(or <TT><FONT COLOR="#990000">a</FONT></TT> through <TT><FONT COLOR="#990000">f</FONT></TT>)
			represent the conventional digit values of ten through fifteen.
			For example: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP> The
			&quot;leading zero&quot; indicator works only for literals&iuml;&frac34;—not
			for automatic string-to-number conversion, which we'll see later
			in this chapter. You can convert a data string that looks like an
			octal or hex value into a number with <TT><FONT COLOR="#990000">oct(
			)</FONT></TT>or <TT><FONT COLOR="#990000">hex( )</FONT></TT>.
			Although there's no &quot;<TT><FONT COLOR="#990000">bin</FONT></TT>&quot;
			function for converting binary values, <TT><FONT COLOR="#990000">oct(
			)</FONT></TT>can do that for strings beginning with <TT><FONT COLOR="#990000">0b</FONT></TT>.</P>
			<PRE><FONT COLOR="#990000">0377       # 377 octal, same as 255 decimal</FONT>
<FONT COLOR="#990000">0xff       # FF hex, also 255 decimal</FONT>
<FONT COLOR="#990000">0b11111111 # also 255 decimal (available in version 5.6 and later)</FONT></PRE><P>
			Although these values look different to us humans, they're all
			three the same number to Perl. It makes no difference to Perl
			whether you write <TT><FONT COLOR="#990000">0xFF</FONT></TT> or
			<TT><FONT COLOR="#990000">255.000</FONT></TT>, so choose the
			representation that makes the most sense to you and your
			maintenance programmer (by which we mean the poor chap who gets
			stuck trying to figure out what you meant when you wrote your
			code. Most often, this poor chap is you, and you can't recall whay
			you did what you did three months ago). 
			</P>
			<P>When a non-decimal literal is more than about four characters
			long, it may be hard to read. For this reason, starting in version
			5.6, Perl allows underscores for clarity within these literals: 
			</P>
			<PRE><FONT COLOR="#990000">0x1377_0b77</FONT>
<FONT COLOR="#990000">0x50_65_72_7C</FONT></PRE><H4>
			<A NAME="lperl3-CHP-2-SECT-2.5"></A>2.2.5 Numeric Operators</H4>
			<P><A NAME="IXT-2-335870"></A><A NAME="IXT-2-335871"></A><A NAME="IXT-2-335872"></A><A NAME="IXT-2-335873"></A><A NAME="IXT-2-335874"></A><A NAME="IXT-2-335875"></A><A NAME="IXT-2-335876"></A><A NAME="IXT-2-335877"></A><A NAME="IXT-2-335878"></A><A NAME="IXT-2-335879"></A>
			Perl provides the typical ordinary addition, subtraction,
			multiplication, and division operators, and so on. For example: 
			</P>
			<PRE><FONT COLOR="#990000">2 + 3      # 2 plus 3, or 5</FONT>
<FONT COLOR="#990000">5.1 - 2.4  # 5.1 minus 2.4, or 2.7</FONT>
<FONT COLOR="#990000">3 * 12     # 3 times 12 = 36</FONT>
<FONT COLOR="#990000">14 / 2     # 14 divided by 2, or 7</FONT>
<FONT COLOR="#990000">10.2 / 0.3 # 10.2 divided by 0.3, or 34</FONT>
<FONT COLOR="#990000">10 / 3     # always floating-point divide, so 3.3333333...</FONT></PRE><P>
			<A NAME="IXT-2-335880"></A><A NAME="IXT-2-335881"></A>Perl also
			supports a modulus operator (<TT><FONT COLOR="#990000">%</FONT></TT>).
			The value of the expression <TT><FONT COLOR="#990000">10 % 3</FONT></TT>
			is the remainder when ten is divided by three, which is one. Both
			values are first reduced to their integer values, so <TT><FONT COLOR="#990000">10.5
			% 3.2</FONT></TT> is computed as <TT><FONT COLOR="#990000">10 %
			3</FONT></TT>.<A HREF="#">[7]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP> The
			result of a modulus operator when a negative number (or two) is
			involved can vary between Perl implementations. Beware.</P>
			<P><A NAME="IXT-2-335882"></A><A NAME="IXT-2-335883"></A>Additionally,
			Perl provides the FORTRAN-like exponentiation operator, which many
			have yearned for in Pascal and C. The operator is represented by
			the double asterisk, such as <TT><FONT COLOR="#990000">2**3</FONT></TT>,
			which is two to the third power, or eight.<A HREF="#">[8]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> You
			can't normally raise a negative number to a noninteger exponent.
			Math geeks know that the result would be a complex number. To make
			that possible, you'll need the help of the <TT><FONT COLOR="#990000">Math::Complex</FONT></TT>
			module.</P>
			<P><A NAME="IXTR3-9"></A>In addition, there are other numeric
			operators, which we'll introduce as we need them. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic5" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=0 FRAME=VOID RULES=COLS>
	<COL WIDTH=41*>
	<COL WIDTH=215*>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=100% VALIGN=TOP>
				<H3><A NAME="lperl3-CHP-2-SECT-3"></A>2.3 Strings</H3>
				<P><A NAME="lperl3-IDXTERM-143"></A><A NAME="lperl3-IDXTERM-144"></A><A NAME="IXT-2-335884"></A>
				Strings are sequences of characters (like <TT><FONT COLOR="#990000">hello</FONT></TT>).
				Strings may contain any combination of any characters.<A HREF="#">[9]</A>
				
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-2-335885"></A>
				<SUP>[9]</SUP> Unlike C or C++, there's nothing special about the
				NUL character in Perl, because Perl uses length counting, not a
				null byte, to determine the end of the string.</P>
				<P>The shortest possible string has no characters. The longest
				string fills all of your available memory (although you wouldn't
				be able to do much with that). This is in accordance with the
				principle of &quot;no built-in limits&quot; that Perl follows at
				every opportunity. Typical strings are printable sequences of
				letters and digits and punctuation in the ASCII 32 to ASCII 126
				range. However, the ability to have any character in a string
				means you can create, scan, and manipulate raw binary data as
				strings&iuml;&frac34;—something with which many other utilities
				would have great difficulty. For example, you could update a
				graphical image or compiled program by reading it into a Perl
				string, making the change, and writing the result back out. 
				</P>
				<P><A NAME="IXT-2-335886"></A><A NAME="IXT-2-335887"></A>Like
				numbers, strings have a literal representation, which is the way
				you represent the string in a Perl program. Literal strings come
				in two different flavors: single-quoted string literals and
				double-quoted string literals. 
				</P>
				<H4><A NAME="lperl3-CHP-2-SECT-3.1"></A>2.3.1 Single-Quoted
				String Literals</H4>
				<P><A NAME="IXT-2-335888"></A><A NAME="IXT-2-335889"></A><A NAME="IXT-2-335890"></A><A NAME="IXT-2-335891"></A><A NAME="IXT-2-335892"></A>
				A single-quoted string literal is a sequence of characters
				enclosed in single quotes. The single quotes are not part of the
				string itself&iuml;&frac34;—they're just there to let Perl
				identify the beginning and the ending of the string. Any
				character other than a single quote or a backslash between the
				quote marks (including newline characters, if the string
				continues onto successive lines) stands for itself inside a
				string. To get a backslash, put two backslashes in a row, and to
				get a single quote, put a backslash followed by a single quote.
				In other words: 
				</P>
				<PRE><FONT COLOR="#990000">'fred'    # those four characters: f, r, e, and d</FONT>
<FONT COLOR="#990000">'barney'  # those six characters</FONT>
<FONT COLOR="#990000">''        # the null string (no characters)</FONT>
<FONT COLOR="#990000">'Don\'t let an apostrophe end this string prematurely!'</FONT>
<FONT COLOR="#990000">'the last character of this string is a backslash: \\'</FONT>
<FONT COLOR="#990000">'hello\n' # hello followed by backslash followed by n</FONT>
<FONT COLOR="#990000">'hello</FONT>
<FONT COLOR="#990000">there'    # hello, newline, there (11 characters total)</FONT>
<FONT COLOR="#990000">'\'\\'    # single quote followed by backslash</FONT></PRE><P>
				<A NAME="IXT-2-335893"></A>Note that the <TT><FONT COLOR="#990000">\n</FONT></TT>
				within a single-quoted string is not interpreted as a newline,
				but as the two characters backslash and <TT><FONT COLOR="#990000">n</FONT></TT>.
				Only when the backslash is followed by another backslash or a
				single quote does it have special meaning. 
				</P>
				<H4><A NAME="lperl3-CHP-2-SECT-3.2"></A>2.3.2 Double-Quoted
				String Literals</H4>
				<P><A NAME="IXT-2-335894"></A><A NAME="IXT-2-335895"></A><A NAME="IXT-2-335896"></A>
				A double-quoted string literal is similar to the strings you may
				have seen in other languages. Once again, it's a sequence of
				characters, although this time enclosed in double quotes. But now
				the backslash takes on its full power to specify certain control
				characters, or even any character at all through octal and hex
				representations. Here are some double-quoted strings: 
				</P>
				<PRE><FONT COLOR="#990000">&quot;barney&quot;        # just the same as 'barney'</FONT>
<FONT COLOR="#990000">&quot;hello world\n&quot; # hello world, and a newline</FONT>
<FONT COLOR="#990000">&quot;The last character of this string is a quote mark: \&quot;&quot;</FONT>
<FONT COLOR="#990000">&quot;coke\tsprite&quot;  # coke, a tab, and sprite</FONT></PRE><P>
				Note that the double-quoted literal string <TT><FONT COLOR="#990000">&quot;barney&quot;</FONT></TT>
				means the same six-character string to Perl as does the
				single-quoted literal string <TT><FONT COLOR="#990000">'barney'</FONT></TT>.
				It's like what we saw with numeric literals, where we saw that
				<TT><FONT COLOR="#990000">0377</FONT></TT> was another way to
				write <TT><FONT COLOR="#990000">255.0</FONT></TT>. Perl lets you
				write the literal in the way that makes more sense to you. Of
				course, if you wish to use a backslash escape (like <TT><FONT COLOR="#990000">\n</FONT></TT>
				to mean a newline character), you'll need to use the double
				quotes. 
				</P>
				<P><A NAME="IXT-2-335897"></A><A NAME="IXT-2-335898"></A>The
				backslash can precede many different characters to mean different
				things (generally called a backslash escape). The nearly
				complete<A HREF="#">[11]</A> list of double-quoted string escapes
				is given in <A HREF="#lperl3-CHP-2-TABLE-1">Table 2-1</A>. 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="lperl3-CHP-2-TABLE-1"></A>
				<SUP>[11]</SUP> Recent versions of Perl have introduced &quot;Unicode&quot;
				escapes, which we aren't going to be talking about here.</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=2 WIDTH=100% VALIGN=TOP>
				<H5 ALIGN=CENTER>Table 2-1. Double-quoted string backslash
				escapes 
				</H5>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TH WIDTH=16%>
				<P>Construct</P>
			</TH>
			<TH WIDTH=84%>
				<P>Meaning</P>
			</TH>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\n</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Newline</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\r</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Return</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\t</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Tab</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\f</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Formfeed</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\b</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Backspace</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\a</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Bell</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\e</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Escape (ASCII escape character)</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\007</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Any octal ASCII value (here, <TT><FONT COLOR="#990000">007</FONT></TT>
				= bell) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\x7f</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Any hex ASCII value (here, <TT><FONT COLOR="#990000">7f</FONT></TT>
				= delete) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\cC</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>A &quot;control&quot; character (here, Ctrl-C)</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\\</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Backslash</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\&quot;</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Double quote</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\l</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Lowercase next letter</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\L</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Lowercase all following letters until <TT><FONT COLOR="#990000">\E</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\u</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Uppercase next letter</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\U</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Uppercase all following letters until <TT><FONT COLOR="#990000">\E</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\Q</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Quote non-word characters by adding a backslash until <TT><FONT COLOR="#990000">\E</FONT></TT>
				
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=16%>
				<PRE><FONT COLOR="#990000">\E</FONT></PRE>
			</TD>
			<TD WIDTH=84%>
				<P>Terminate <TT><FONT COLOR="#990000">\L</FONT></TT>, <TT><FONT COLOR="#990000">\U</FONT></TT>,
				or <TT><FONT COLOR="#990000">\Q</FONT></TT> 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=100% VALIGN=TOP>
				<P><A NAME="IXT-2-335899"></A><A NAME="IXT-2-335900"></A><A NAME="IXT-2-335901"></A>
				Another feature of double-quoted strings is that they are
				variable interpolated, meaning that some variable names within
				the string are replaced with their current values when the
				strings are used. We haven't formally been introduced to what a
				variable looks like yet, so we'll get back to this later in this
				chapter. 
				</P>
				<H4><A NAME="lperl3-CHP-2-SECT-3.3"></A>2.3.3 String Operators</H4>
				<P><A NAME="IXT-2-335902"></A><A NAME="IXT-2-335903"></A>String
				values can be concatenated with the <TT><FONT COLOR="#990000">.</FONT></TT>
				operator. (Yes, that's a single period.) This does not alter
				either string, any more than <TT><FONT COLOR="#990000">2+3</FONT></TT>
				alters either <TT><FONT COLOR="#990000">2</FONT></TT> or <TT><FONT COLOR="#990000">3</FONT></TT>.
				The resulting (longer) string is then available for further
				computation or to be stored into a variable. For example: 
				</P>
				<PRE><FONT COLOR="#990000">&quot;hello&quot; . &quot;world&quot;       # same as &quot;helloworld&quot;</FONT>
<FONT COLOR="#990000">&quot;hello&quot; . ' ' . &quot;world&quot; # same as 'hello world'</FONT>
<FONT COLOR="#990000">'hello world' . &quot;\n&quot;    # same as &quot;hello world\n&quot;</FONT></PRE><P>
				Note that the concatenation must be explicitly requested with the
				<TT><FONT COLOR="#990000">.</FONT></TT> operator, unlike in some
				other languages where you merely have to stick the two values
				next to each other. 
				</P>
				<P><A NAME="IXT-2-335904"></A><A NAME="IXT-2-335905"></A>A
				special string operator is the string repetition operator,
				consisting of the single lowercase letter <TT><FONT COLOR="#990000">x</FONT></TT>.
				This operator takes its left operand (a string) and makes as many
				concatenated copies of that string as indicated by its right
				operand (a number). For example: 
				</P>
				<PRE><FONT COLOR="#990000">&quot;fred&quot; x 3       # is &quot;fredfredfred&quot;</FONT>
<FONT COLOR="#990000">&quot;barney&quot; x (4+1) # is &quot;barney&quot; x 5, or &quot;barneybarneybarneybarneybarney&quot;</FONT>
<FONT COLOR="#990000">5 x 4            # is really &quot;5&quot; x 4, which is &quot;5555&quot;</FONT></PRE><P>
				That last example is worth spelling out slowly. The string
				repetition operator wants a string for a left operand, so the
				number <TT><FONT COLOR="#990000">5</FONT></TT> is converted to
				the string <TT><FONT COLOR="#990000">&quot;5&quot;</FONT></TT>
				(using rules described in detail later), giving a one-character
				string. This new string is then copied four times, yielding the
				four-character string <TT><FONT COLOR="#990000">5555</FONT></TT>.
				Note that if we had reversed the order of the operands, as <TT><FONT COLOR="#990000">4
				x 5</FONT></TT>, we would have made five copies of the string <TT><FONT COLOR="#990000">4</FONT></TT>,
				yielding <TT><FONT COLOR="#990000">44444</FONT></TT>. This shows
				that string repetition is not commutative. 
				</P>
				<P>The copy count (the right operand) is first truncated to an
				integer value (4.8 becomes 4) before being used. A copy count of
				less than one results in an empty (zero-length) string. 
				</P>
				<H4><A NAME="lperl3-CHP-2-SECT-3.4"></A>2.3.4 Automatic
				Conversion Between Numbers and Strings</H4>
				<P><A NAME="IXT-2-335906"></A><A NAME="IXT-2-335907"></A>For the
				most part, Perl automatically converts between numbers to strings
				as needed. How does it know whether a number or a string is
				needed? It all depends upon the operator being used on the scalar
				value. If an operator expects a number (like <TT><FONT COLOR="#990000">+</FONT></TT>
				does), Perl will see the value as a number. If an operator
				expects a string (like <TT><FONT COLOR="#990000">.</FONT></TT>
				does), Perl will see the value as a string. So you don't need to
				worry about the difference between numbers and strings; just use
				the proper operators, and Perl will make it all work. 
				</P>
				<P>When a string value is used where an operator needs a number
				(say, for multiplication), Perl automatically converts the string
				to its equivalent numeric value, as if it had been entered as a
				decimal floating-point value.<A HREF="#">[12]</A> So <TT><FONT COLOR="#990000">&quot;12&quot;
				* &quot;3&quot;</FONT></TT> gives the value <TT><FONT COLOR="#990000">36</FONT></TT>.
				Trailing nonnumber stuff and leading whitespace are discarded, so
				<TT><FONT COLOR="#990000">&quot;12fred34&quot; * &quot; 3&quot;</FONT></TT>
				will also give <TT><FONT COLOR="#990000">36</FONT></TT> without
				any complaints.<A HREF="#">[13]</A> At the extreme end of this,
				something that isn't a number at all converts to zero. This would
				happen if you used the string <TT><FONT COLOR="#990000">&quot;fred&quot;</FONT></TT>
				as a number. 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP>
				The trick of using a leading zero to mean a nondecimal value
				works for literals, but never for automatic conversion. Use <TT><FONT COLOR="#990000">hex(
				)</FONT></TT>or <TT><FONT COLOR="#990000">oct( )</FONT></TT>to
				convert those kinds of strings.</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP>
				Unless you request warnings, which we'll discuss in a moment.</P>
				<P>Likewise, if a numeric value is given when a string value is
				needed (say, for string concatenation), the numeric value is
				expanded into whatever string would have been printed for that
				number. For example, if you want to concatenate the string <TT><FONT COLOR="#990000">Z</FONT></TT>
				followed by the result of 5 multiplied by 7,<A HREF="#">[14]</A>
				you can say this simply as: 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP>
				We'll see about precedence and parentheses shortly.</P>
				<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">&quot;Z&quot; . 5 * 7 # same as &quot;Z&quot; . 35, or &quot;Z35&quot;</FONT></PRE><P>
				<A NAME="IXTR3-10"></A>In other words, you don't really have to
				worry about whether you have a number or a string (most of the
				time). Perl performs all the conversions for you.<A HREF="#">[15]</A>
				And if you're worried about efficiency, don't be. Perl generally
				remembers the result of a conversion so that it's done only once.
				
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP>
				It's usually not an issue, but these conversions can cause small
				round-off errors. That is, if you start with a number, convert it
				to a string, then convert that string back to a number, the
				result may not be the same number as you started with. It's not
				just Perl that does this; it's a consequence of the conversion
				process, so it happens to any powerful programming language.</P>
				<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic6" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-4"></A>2.4 Perl's Built-in Warnings</H3>
			<P><A NAME="IXT-2-335908"></A><A NAME="IXT-2-335909"></A><A NAME="IXT-2-335910"></A>
			Perl can be told to warn you when it sees something suspicious
			going on in your program. To run your program with warnings turned
			on, use the <TT><FONT COLOR="#990000">-w</FONT></TT> option on the
			command line: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">$ <B>perl -w  </B><I>my_program </I></FONT></PRE><P>
			Or, if you always want warnings, you may request them on the <TT><FONT COLOR="#990000">#!</FONT></TT>
			line: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">#!/usr/bin/perl -w</FONT></PRE><P>
			That works even on non-Unix systems, where it's traditional to
			write something like this, since the path to Perl doesn't
			generally matter: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">#!perl -w</FONT></PRE><P>
			Now, Perl will warn you if you use <TT><FONT COLOR="#990000">'12fred34'</FONT></TT>
			as if it were a number: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">Argument &quot;12fred34&quot; isn't numeric</FONT></PRE><P>
			<A NAME="IXT-2-335911"></A>Of course, warnings are generally meant
			for programmers, not for end-users. If the warning won't be seen
			by a programmer, it probably won't do any good. And warnings won't
			change the behavior of your program, except that now it will emit
			gripes once in a while. If you get a warning message you don't
			understand, look for its explanation in the perldiag manpage. 
			</P>
			<P><A NAME="IXT-2-335912"></A><A NAME="IXT-2-335913"></A>Warnings
			change from one version of Perl to the next. This may mean that
			your well-tuned program runs silently when warnings are on today,
			but not when it's used with a newer (or older) version of Perl. To
			help with this situation, version 5.6 of Perl introduces lexical
			warnings. These are warnings that may be turned on or off in
			different sections of code, providing more detailed control than
			the single <TT><FONT COLOR="#990000">-w</FONT></TT> switch could.
			See the perllexwarn manpage for more information on these
			warnings. 
			</P>
			<P>As we run across situations in which Perl will usually be able
			to warn you about a mistake in your code, we'll point them out.
			But you shouldn't count on the text or behavior of any warning
			staying exactly the same in future Perl releases. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-5"></A>2.5 Scalar Variables</H3>
			<P><A NAME="IXT-2-335914"></A>A variable is a name for a container
			that holds one or more values.<A HREF="#">[16]</A> The name of the
			variable stays the same throughout the program, but the value or
			values contained in that variable typically change over and over
			again throughout the execution of the program. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP> As
			we'll see, a scalar variable can hold only one value. But other
			types of variables, such as arrays and hashes, may hold many
			values.</P>
			<P><A NAME="IXT-2-335915"></A><A NAME="IXT-2-335916"></A>A scalar
			variable holds a single scalar value, as you'd expect. Scalar
			variable names begin with a dollar sign followed by what we'll
			call a Perl identifier: a letter or underscore, and then possibly
			more letters, or digits, or underscores. Another way to think of
			it is that it's made up of alphanumerics and underscores, but
			can't start with a digit. Uppercase and lowercase letters are
			distinct: the variable <TT><FONT COLOR="#990000">$Fred</FONT></TT>
			is a different variable from <TT><FONT COLOR="#990000">$fred</FONT></TT>.
			And all of the letters, digits, and underscores are significant,
			so: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">$a_very_long_variable_that_ends_in_1</FONT></PRE><P>
			is different from:</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">$a_very_long_variable_that_ends_in_2</FONT></PRE><P>
			Scalar variables in Perl are always referenced with the leading <TT><FONT COLOR="#990000">$</FONT></TT>.
			In the shell, you use <TT><FONT COLOR="#990000">$</FONT></TT> to
			get the value, but leave the <TT><FONT COLOR="#990000">$</FONT></TT>
			off to assign a new value. In awk or C, you leave the <TT><FONT COLOR="#990000">$</FONT></TT>
			off entirely. If you bounce back and forth a lot, you'll find
			yourself typing the wrong things occasionally. This is expected.
			(Most Perl programmers would recommend that you stop writing
			shell, awk, and C programs, but that may not work for you.) 
			</P>
			<H4><A NAME="lperl3-CHP-2-SECT-5.1"></A>2.5.1 Choosing Good
			Variable Names</H4>
			<P><A NAME="IXT-2-335917"></A>You should generally select variable
			names that mean something regarding the purpose of the variable.
			For example, <TT><FONT COLOR="#990000">$r</FONT></TT> is probably
			not very descriptive but <TT><FONT COLOR="#990000">$line_length</FONT></TT>
			is. A variable used for only two or three lines close together may
			be called something simple, like <TT><FONT COLOR="#990000">$n</FONT></TT>,
			but a variable used throughout a program should probably have a
			more descriptive name. 
			</P>
			<P>Similarly, properly placed underscores can make a name easier
			to read and understand, especially if your maintenance programmer
			has a different spoken language background than you have. For
			example, <TT><FONT COLOR="#990000">$super_bowl</FONT></TT> is a
			better name than <TT><FONT COLOR="#990000">$superbowl</FONT></TT>,
			since that last one might look like <TT><FONT COLOR="#990000">$superb_owl</FONT></TT>.
			Does <TT><FONT COLOR="#990000">$stopid</FONT></TT> mean <TT><FONT COLOR="#990000">$sto_pid</FONT></TT>
			(storing a process-ID of some kind?) or <TT><FONT COLOR="#990000">$s_to_pid</FONT></TT>
			(converting something to a process-ID?) or <TT><FONT COLOR="#990000">$stop_id</FONT></TT>
			(the ID for some kind of &quot;stop&quot; object?) or is it just a
			stopid mispelling? 
			</P>
			<P><A NAME="IXT-2-335918"></A><A NAME="IXT-2-335919"></A><A NAME="IXT-2-335920"></A>
			Most variable names in our Perl programs are all lowercase, like
			most of the ones we'll see in this book. In a few special cases,
			capitalization is used. Using all-caps (like <TT><FONT COLOR="#990000">$ARGV</FONT></TT>)
			generally indicates that there's something special about that
			variable. (But you can get into an all-out brawl if you choose
			sides on the <TT><FONT COLOR="#990000">$underscores_are_cool</FONT></TT>
			versus the <TT><FONT COLOR="#990000">$giveMeInitialCaps</FONT></TT>
			argument. So be careful.) 
			</P>
			<P>Of course, choosing good or poor names makes no difference to
			Perl. You could name your program's three most-important variables
			<TT><FONT COLOR="#990000">$OOO000OOO</FONT></TT>, <TT><FONT COLOR="#990000">$OO00OO00</FONT></TT>,
			and <TT><FONT COLOR="#990000">$O0O0O0O0O</FONT></TT> and Perl
			wouldn't be bothered&iuml;&frac34;—but in that case, please,
			don't ask us to maintain your code. 
			</P>
			<H4><A NAME="lperl3-CHP-2-SECT-5.2"></A>2.5.2 Scalar Assignment</H4>
			<P><A NAME="IXT-2-335921"></A><A NAME="IXT-2-335922"></A><A NAME="IXT-2-335923"></A><A NAME="IXT-2-335924"></A><A NAME="IXT-2-335925"></A><A NAME="IXT-2-335926"></A>
			The most common operation on a scalar variable is assignment,
			which is the way to give a value to a variable. The Perl
			assignment operator is the equals sign (much like other
			languages), which takes a variable name on the left side, and
			gives it the value of the expression on the right. For example: 
			</P>
			<PRE><FONT COLOR="#990000">$fred = 17;            # give $fred the value of 17</FONT>
<FONT COLOR="#990000">$barney = 'hello';     # give $barney the five-character string 'hello'</FONT>
<FONT COLOR="#990000">$barney = $fred + 3;   # give $barney the current value of $fred plus 3 (20)</FONT>
<FONT COLOR="#990000">$barney = $barney * 2; # $barney is now $barney multiplied by 2 (40)</FONT></PRE><P>
			Notice that last line uses the <TT><FONT COLOR="#990000">$barney</FONT></TT>
			variable twice: once to get its value (on the right side of the
			equals sign), and once to define where to put the computed
			expression (on the left side of the equals sign). This is legal,
			safe, and in fact, rather common. In fact, it's so common that we
			can write it using a convenient shorthand, as we'll see in the
			next section. 
			</P>
			<H4><A NAME="lperl3-CHP-2-SECT-5.3"></A>2.5.3 Binary Assignment
			Operators</H4>
			<P><A NAME="IXT-2-335927"></A><A NAME="IXT-2-335928"></A>Expressions
			like <TT><FONT COLOR="#990000">$fred = $fred + 5</FONT></TT>
			(where the same variable appears on both sides of an assignment)
			occur frequently enough that Perl (like C and Java) has a
			shorthand for the operation of altering a variable&iuml;&frac34;—the
			binary assignment operator. Nearly all binary operators that
			compute a value have a corresponding binary assignment form with
			an appended equals sign. For example, the following two lines are
			equivalent: 
			</P>
			<PRE><FONT COLOR="#990000">$fred = $fred + 5; # without the binary assignment operator</FONT>
<FONT COLOR="#990000">$fred += 5;        # with the binary assignment operator</FONT></PRE><P>
			These are also equivalent:</P>
			<PRE><FONT COLOR="#990000">$barney = $barney * 3;</FONT>
<FONT COLOR="#990000">$barney *= 3;</FONT></PRE><P>
			In each case, the operator causes the existing value of the
			variable to be altered in some way, rather than simply overwriting
			the value with the result of some new expression. 
			</P>
			<P><A NAME="IXT-2-335929"></A><A NAME="IXT-2-335930"></A><A NAME="IXT-2-335931"></A><A NAME="IXT-2-335932"></A>
			Another common assignment operator is the string concatenate
			operator ( <TT><FONT COLOR="#990000">.</FONT></TT> ); this gives
			us an append operator ( <TT><FONT COLOR="#990000">.=</FONT></TT>
			): 
			</P>
			<PRE><FONT COLOR="#990000">$str = $str . &quot; &quot;; # append a space to $str</FONT>
<FONT COLOR="#990000">$str .= &quot; &quot;;       # same thing with assignment operator</FONT></PRE><P>
			<A NAME="IXT-2-335933"></A><A NAME="IXT-2-335934"></A>Nearly all
			binary operators are valid this way. For example, a raise to the
			power of operator is written as <TT><FONT COLOR="#990000">**=</FONT></TT>.
			So, <TT><FONT COLOR="#990000">$fred **= 3</FONT></TT> means &quot;raise
			the number in <TT><FONT COLOR="#990000">$fred</FONT></TT> to the
			third power, placing the result back in <TT><FONT COLOR="#990000">$fred</FONT></TT>&quot;.
			
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic7" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=2 CELLSPACING=0 FRAME=VOID RULES=COLS>
	<COL WIDTH=58*>
	<COL WIDTH=91*>
	<COL WIDTH=61*>
	<COL WIDTH=47*>
	<TBODY>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<H3><A NAME="lperl3-CHP-2-SECT-6"></A>2.6 Output with print 
				</H3>
				<P><A NAME="IXT-2-335935"></A>It's generally a good idea to have
				your program produce some output; otherwise, someone may think it
				didn't do anything. The <TT><FONT COLOR="#990000">print( )</FONT></TT>
				operator makes this possible. It takes a scalar argument and puts
				it out without any embellishment onto standard output. Unless
				you've done something odd, this will be your terminal display.
				For example: 
				</P>
				<PRE><FONT COLOR="#990000">print &quot;hello world\n&quot;; # say hello world, followed by a newline</FONT>

<FONT COLOR="#990000">print &quot;The answer is &quot;;</FONT>
<FONT COLOR="#990000">print 6 * 7;</FONT>
<FONT COLOR="#990000">print &quot;.\n&quot;;</FONT></PRE><P>
				You can actually give <TT><FONT COLOR="#990000">print</FONT></TT>
				a series of values, separated by commas. 
				</P>
				<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">print &quot;The answer is &quot;, 6 * 7, &quot;.\n&quot;;</FONT></PRE><P>
				This is actually a list, but we haven't talked about lists yet,
				so we'll put that off for later. 
				</P>
				<H4><A NAME="lperl3-CHP-2-SECT-6.1"></A>2.6.1 Interpolation of
				Scalar Variables into Strings</H4>
				<P><A NAME="IXT-2-335936"></A><A NAME="IXT-2-335937"></A><A NAME="IXT-2-335938"></A>
				When a string literal is double-quoted, it is subject to variable
				interpolation<A HREF="#">[18]</A> (besides being checked for
				backslash escapes). This means that any scalar variable<A HREF="#">[19]</A>
				name in the string is replaced with its current value. For
				example: 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP>
				This has nothing to do with mathematical or statistical
				interpolation.</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[19]</SUP>
				And some other variable types, but we won't see those until
				later.</P>
				<PRE><FONT COLOR="#990000">$meal = &quot;brontosaurus steak&quot;;</FONT>
<FONT COLOR="#990000">$barney = &quot;fred ate a $meal&quot;;    # $barney is now &quot;fred ate a brontosaurus steak&quot;</FONT>
<FONT COLOR="#990000">$barney = 'fred ate a ' . $meal; # another way to write that</FONT></PRE><P>
				As you see on the last line above, you can get the same results
				without the double quotes. But the double-quoted string is often
				the more convenient way to write it. 
				</P>
				<P>If the scalar variable has never been given a value,<A HREF="#">[20]</A>
				the empty string is used instead: 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[20]</SUP>
				This is actually the special undefined value, <TT><FONT COLOR="#990000">undef</FONT></TT>,
				which we'll see a little later in this chapter. If warnings are
				turned on, Perl will complain about interpolating the undefined
				value.</P>
				<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#990000">$barney = &quot;fred ate a $meat&quot;; # $barney is now &quot;fred ate a &quot;</FONT></PRE><P>
				Don't bother with interpolating if you have just the one lone
				variable: 
				</P>
				<PRE><FONT COLOR="#990000">print &quot;$fred&quot;; # unneeded quote marks</FONT>
<FONT COLOR="#990000">print $fred;   # better style</FONT></PRE><P>
				There's nothing really wrong with putting quote marks around a
				lone variable, but the other programmers will laugh at you behind
				your back.<A HREF="#">[21]</A> 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[21]</SUP>
				Well, it may force a value to be interpreted as a string, rather
				than a number. In a few rare cases that may be needed, but nearly
				always it's just a waste of typing.</P>
				<P><A NAME="IXT-2-335939"></A>Variable interpolation is also
				known as double-quote interpolation, because it happens when
				double-quote marks (but not single quotes) are used. It happens
				for some other strings in Perl, which we'll mention as we get to
				them. 
				</P>
				<P><A NAME="IXT-2-335940"></A><A NAME="IXT-2-335941"></A><A NAME="IXT-2-335942"></A>
				To put a real dollar sign into a double-quoted string, precede
				the dollar sign with a backslash, which turns off the dollar
				sign's special significance: 
				</P>
				<PRE><FONT COLOR="#990000">$fred = 'hello';</FONT>
<FONT COLOR="#990000">print &quot;The name is \$fred.\n&quot;;    # prints a dollar sign</FONT>
<FONT COLOR="#990000">print 'The name is $fred' . &quot;\n&quot;; # so does this</FONT></PRE><P>
				<A NAME="IXT-2-335943"></A><A NAME="IXT-2-335944"></A><A NAME="IXT-2-335945"></A><A NAME="IXT-2-335946"></A>
				The variable name will be the longest possible variable name that
				makes sense at that part of the string. This can be a problem if
				you want to follow the replaced value immediately with some
				constant text that begins with a letter, digit, or
				underscore.<A HREF="#">[22]</A> As Perl scans for variable names,
				it would consider those characters to be additional name
				characters, which is not what you want. Perl provides a delimiter
				for the variable name in a manner similar to the shell. Simply
				enclose the name of the variable in a pair of curly braces. Or,
				you can end that part of the string and start another part of the
				string with a concatenation operator: 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[22]</SUP>
				There are some other characters that may be a problem as well. If
				you need a left square bracket or a left curly brace just after a
				scalar variable's name, precede it with a backslash. You may also
				do that if the variable's name is followed by an apostrophe or a
				pair of colons, or you could use the curly-brace method described
				in the main text</P>
				<PRE><FONT COLOR="#990000">$what = &quot;brontosaurus steak&quot;;</FONT>
<FONT COLOR="#990000">$n = 3;</FONT>
<FONT COLOR="#990000">print &quot;fred ate $n $whats.\n&quot;;          # not the steaks, but the value of $whats</FONT>
<FONT COLOR="#990000">print &quot;fred ate $n ${what}s.\n&quot;;        # now uses $what</FONT>
<FONT COLOR="#990000">print &quot;fred ate $n $what&quot; . &quot;s.\n&quot;;     # another way to do it</FONT>
<FONT COLOR="#990000">print 'fred ate ' . $n . ' ' . $what . &quot;s.\n&quot;; # an especially difficult way</FONT></PRE><H4>
				<A NAME="lperl3-CHP-2-SECT-6.2"></A>2.6.2 Operator Precedence and
				Associativity</H4>
				<P><A NAME="lperl3-IDXTERM-209"></A><A NAME="lperl3-IDXTERM-210"></A><A NAME="lperl3-IDXTERM-211"></A><A NAME="lperl3-IDXTERM-212"></A><A NAME="lperl3-IDXTERM-213"></A>
				Operator precedence determines which operations in a complex
				group of operations happen first. For example, in the expression
				<TT><FONT COLOR="#990000">2+3*4</FONT></TT>, do we perform the
				addition first or the multiplication first? If we did the
				addition first, we'd get <TT><FONT COLOR="#990000">5*4</FONT></TT>,
				or <TT><FONT COLOR="#990000">20</FONT></TT>. But if we did the
				multiplication first (as we were taught in math class), we'd get
				<TT><FONT COLOR="#990000">2+12</FONT></TT>, or <TT><FONT COLOR="#990000">14</FONT></TT>.
				Fortunately, Perl chooses the common mathematical definition,
				performing the multiplication first. Because of this, we say
				multiplication has a higher precedence than addition. 
				</P>
				<P><A NAME="IXT-2-335947"></A><A NAME="IXT-2-335948"></A>You can
				override the default precedence order by using parentheses.
				Anything in parentheses is completely computed before the
				operator outside of the parentheses is applied (just like you
				learned in math class). So if I really want the addition before
				the multiplication, I can say <TT><FONT COLOR="#990000">(2+3)*4</FONT></TT>,
				yielding <TT><FONT COLOR="#990000">20</FONT></TT>. Also, if I
				wanted to demonstrate that multiplication is performed before
				addition, I could add a decorative but unnecessary set of
				parentheses, as in <TT><FONT COLOR="#990000">2+(3*4)</FONT></TT>.
				
				</P>
				<P>While precedence is simple for addition and multiplication, we
				start running into problems when faced with, say, string
				concatenation compared with exponentiation. The proper way to
				resolve this is to consult the official, accept-no-substitutes
				Perl operator precedence chart, shown in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-2-SECT-3#lperl3-CHP-2-TABLE-1">Table
				2-1</A>.<A HREF="#">[23]</A> (Note that some of the operators
				have not yet been described, and in fact, may not even appear
				anywhere in this book, but don't let that scare you from reading
				about them in the perlop manpage.) 
				</P>
				<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="lperl3-CHP-2-TABLE-2"></A>
				<SUP>[23]</SUP> C programmers: Rejoice! The operators that are
				available in both Perl and C have the same precedence and
				associativity in both.</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<H5 ALIGN=CENTER>Table 2-2. Associativity and precedence of
				operators (highest to lowest) 
				</H5>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TH WIDTH=23%>
				<P>Associativity</P>
			</TH>
			<TH COLSPAN=3 WIDTH=77%>
				<P>Operators</P>
			</TH>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P><A NAME="IXT-2-335949"></A>left 
				</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P>parentheses and arguments to list operators</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P><A NAME="IXT-2-335950"></A>left 
				</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">-&gt;</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>&nbsp;</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">++</FONT></TT> <TT><FONT COLOR="#990000">--</FONT></TT>
				(autoincrement and autodecrement) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>right</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">**</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>right</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">\</FONT></TT> <TT><FONT COLOR="#990000">!</FONT></TT>
				<TT><FONT COLOR="#990000">~</FONT></TT> <TT><FONT COLOR="#990000">+</FONT></TT>
				<TT><FONT COLOR="#990000">-</FONT></TT> (unary operators) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">=~</FONT></TT> <TT><FONT COLOR="#990000">!~</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">*</FONT></TT> <TT><FONT COLOR="#990000">/</FONT></TT>
				<TT><FONT COLOR="#990000">%</FONT></TT> <TT><FONT COLOR="#990000">x</FONT></TT>
				
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">+</FONT></TT> <TT><FONT COLOR="#990000">-</FONT></TT>
				<TT><FONT COLOR="#990000">.</FONT></TT> (binary operators) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">&lt;&lt;</FONT></TT> <TT><FONT COLOR="#990000">&gt;&gt;</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>&nbsp;</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P>named unary operators (<TT><FONT COLOR="#990000">-X</FONT></TT>
				filetests, <TT><FONT COLOR="#990000">rand</FONT></TT>) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>&nbsp;</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">&lt;</FONT></TT> <TT><FONT COLOR="#990000">&lt;=</FONT></TT>
				<TT><FONT COLOR="#990000">&gt;</FONT></TT> <TT><FONT COLOR="#990000">&gt;=</FONT></TT>
				<TT><FONT COLOR="#990000">lt</FONT></TT> <TT><FONT COLOR="#990000">le</FONT></TT>
				<TT><FONT COLOR="#990000">gt</FONT></TT> <TT><FONT COLOR="#990000">ge</FONT></TT>
				(the &quot;unequal&quot; ones) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>&nbsp;</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">==</FONT></TT> <TT><FONT COLOR="#990000">!=</FONT></TT>
				<TT><FONT COLOR="#990000">&lt;=&gt;</FONT></TT> <TT><FONT COLOR="#990000">eq</FONT></TT>
				<TT><FONT COLOR="#990000">ne</FONT></TT> <TT><FONT COLOR="#990000">cmp</FONT></TT>
				(the &quot;equal&quot; ones) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">&amp;</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">|</FONT></TT> <TT><FONT COLOR="#990000">^</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">&amp;&amp;</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">||</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>&nbsp;</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">..</FONT></TT> <TT><FONT COLOR="#990000">...</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>right</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">?:</FONT></TT> (ternary)</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>right</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">=</FONT></TT> <TT><FONT COLOR="#990000">+=</FONT></TT>
				<TT><FONT COLOR="#990000">-=</FONT></TT> <TT><FONT COLOR="#990000">.=</FONT></TT>
				(and similar assignment operators) 
				</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">,</FONT></TT> <TT><FONT COLOR="#990000">=&gt;</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>&nbsp;</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P>list operators (rightward)</P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>right</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">not</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">and</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD WIDTH=23%>
				<P>left</P>
			</TD>
			<TD COLSPAN=3 WIDTH=77%>
				<P><TT><FONT COLOR="#990000">or</FONT></TT> <TT><FONT COLOR="#990000">xor</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<P>In the chart, any given operator has higher precedence than
				all of the operators listed below it, and lower precedence than
				all of the operators listed above it. Operators at the same
				precedence level resolve according to rules of associativity
				instead. 
				</P>
				<P>Just like precedence, associativity resolves the order of
				operations when two operators of the same precedence compete for
				three operands: 
				</P>
				<PRE><FONT COLOR="#990000">4 ** 3 ** 2 # 4 ** (3 ** 2), or 4 ** 9 (right associative)</FONT>
<FONT COLOR="#990000">72 / 12 / 3 # (72 / 12) / 3, or 6/3, or 2 (left associative)</FONT>
<FONT COLOR="#990000">36 / 6 * 3  # (36/6)*3, or 18</FONT></PRE><P>
				In the first case, the <TT><FONT COLOR="#990000">**</FONT></TT>
				operator has right associativity, so the parentheses are implied
				on the right. Comparatively, the <TT><FONT COLOR="#990000">*</FONT></TT>
				and <TT><FONT COLOR="#990000">/</FONT></TT> operators have left
				associativity, yielding a set of implied parentheses on the left.
				
				</P>
				<P><A NAME="IXT-2-335951"></A><A NAME="IXTR3-11"></A><A NAME="IXTR3-12"></A><A NAME="IXTR3-13"></A><A NAME="IXTR3-14"></A>
				So should you just memorize the precedence chart? No! Nobody
				actually does that. Instead, just use parentheses when you don't
				remember the order of operations, or when you're too busy to look
				in the chart. After all, if you can't remember it without the
				parentheses, your maintenance programmer is going to have the
				same trouble. So be nice to your maintenance programmer. 
				</P>
				<H4><A NAME="lperl3-CHP-2-SECT-6.3"></A>2.6.3 Comparison
				Operators</H4>
				<P><A NAME="IXT-2-335952"></A><A NAME="IXT-2-335953"></A><A NAME="IXT-2-335954"></A><A NAME="IXT-2-335955"></A>
				For comparing numbers, Perl has the logical comparison operators
				that remind you of algebra: <TT><FONT COLOR="#990000">&lt; &lt;=
				== &gt;= &gt; !=</FONT></TT>. Each of these returns a true or
				false value. We'll find out more about those return values in the
				next section. Some of these may be different than you'd use in
				other languages. For example, <TT><FONT COLOR="#990000">==</FONT></TT>
				is used for equality, not a single <TT><FONT COLOR="#990000">=</FONT></TT>
				sign, because that's used for another purpose in Perl. And <TT><FONT COLOR="#990000">!=</FONT></TT>
				is used for inequality testing, because <TT><FONT COLOR="#990000">&lt;&gt;</FONT></TT>
				is used for another purpose in Perl. And you'll need <TT><FONT COLOR="#990000">&gt;=</FONT></TT>
				and not <TT><FONT COLOR="#990000">=&gt;</FONT></TT> for &quot;greater
				than or equal to&quot;, because the latter is used for another
				purpose in Perl. In fact, nearly every sequence of punctuation is
				used for something in Perl. 
				</P>
				<P><A NAME="IXT-2-335956"></A><A NAME="IXT-2-335957"></A>For
				comparing strings, Perl has an equivalent set of string
				comparison operators which look like funny little words: <TT><FONT COLOR="#990000">lt</FONT></TT>
				<TT><FONT COLOR="#990000">le</FONT></TT> <TT><FONT COLOR="#990000">eq</FONT></TT>
				<TT><FONT COLOR="#990000">ge</FONT></TT> <TT><FONT COLOR="#990000">gt</FONT></TT>
				<TT><FONT COLOR="#990000">ne</FONT></TT>. These compare two
				strings character by character to see whether they're the same,
				or whether one comes first in standard string sorting order. (In
				ASCII, the capital letters come before the lowercase letters, so
				beware.) 
				</P>
				<P><A NAME="lperl3-CHP-2-TABLE-3"></A>The comparison operators
				(for both numbers and strings) are given in <A HREF="#lperl3-CHP-2-TABLE-3">Table
				2-3</A>. 
				</P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<H5 ALIGN=CENTER>Table 2-3. Numeric and string comparison
				operators 
				</H5>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TH COLSPAN=2 WIDTH=58%>
				<P>Comparison</P>
			</TH>
			<TH WIDTH=24%>
				<P>Numeric</P>
			</TH>
			<TH WIDTH=18%>
				<P>String</P>
			</TH>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=58%>
				<P>Equal</P>
			</TD>
			<TD WIDTH=24%>
				<P><TT><FONT COLOR="#990000">==</FONT></TT></P>
			</TD>
			<TD WIDTH=18%>
				<P><TT><FONT COLOR="#990000">eq</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=58%>
				<P>Not equal</P>
			</TD>
			<TD WIDTH=24%>
				<P><TT><FONT COLOR="#990000">!=</FONT></TT></P>
			</TD>
			<TD WIDTH=18%>
				<P><TT><FONT COLOR="#990000">ne</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=58%>
				<P>Less than</P>
			</TD>
			<TD WIDTH=24%>
				<P><TT><FONT COLOR="#990000">&lt;</FONT></TT></P>
			</TD>
			<TD WIDTH=18%>
				<P><TT><FONT COLOR="#990000">lt</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=58%>
				<P>Greater than</P>
			</TD>
			<TD WIDTH=24%>
				<P><TT><FONT COLOR="#990000">&gt;</FONT></TT></P>
			</TD>
			<TD WIDTH=18%>
				<P><TT><FONT COLOR="#990000">gt</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=58%>
				<P>Less than or equal to</P>
			</TD>
			<TD WIDTH=24%>
				<P><TT><FONT COLOR="#990000">&lt;=</FONT></TT></P>
			</TD>
			<TD WIDTH=18%>
				<P><TT><FONT COLOR="#990000">le</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=2 WIDTH=58%>
				<P>Greater than or equal to</P>
			</TD>
			<TD WIDTH=24%>
				<P><TT><FONT COLOR="#990000">&gt;=</FONT></TT></P>
			</TD>
			<TD WIDTH=18%>
				<P><TT><FONT COLOR="#990000">ge</FONT></TT></P>
			</TD>
		</TR>
	</TBODY>
	<TBODY>
		<TR>
			<TD COLSPAN=4 WIDTH=100% VALIGN=TOP>
				<P>Here are some example expressions using these comparison
				operators:</P>
				<PRE><FONT COLOR="#990000">35 != 30 + 5         # false</FONT>
<FONT COLOR="#990000">35 == 35.0           # true</FONT>
<FONT COLOR="#990000">'35' eq '35.0'       # false (comparing as strings)</FONT>
<FONT COLOR="#990000">'fred' lt 'barney'   # false</FONT>
<FONT COLOR="#990000">'fred' lt 'free'     # true</FONT>
<FONT COLOR="#990000">'fred' eq &quot;fred&quot;     # true</FONT>
<FONT COLOR="#990000">'fred' eq 'Fred'     # false</FONT>
<FONT COLOR="#990000">' ' gt ''            # true</FONT></PRE><P>
				<A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic8" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-7"></A>2.7 The if Control Structure</H3>
			<P><A NAME="IXT-2-335958"></A>Once you can compare two values,
			you'll probably want your program to make decisions based upon
			that comparison. Like all similar languages, Perl has an <TT><FONT COLOR="#cc0000">if</FONT></TT>
			control structure: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ($name gt 'fred') {</FONT>
<FONT COLOR="#cc0000">  print &quot;'$name' comes after 'fred' in sorted order.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-2-335959"></A>If you need an alternative choice, the
			<TT><FONT COLOR="#cc0000">else</FONT></TT> keyword provides that
			as well: 
			</P>
			<PRE><FONT COLOR="#cc0000">if ($name gt 'fred') {</FONT>
<FONT COLOR="#cc0000">  print &quot;'$name' comes after 'fred' in sorted order.\n&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;'$name' does not come after 'fred'.\n&quot;;</FONT>
<FONT COLOR="#cc0000">  print &quot;Maybe it's the same string, in fact.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-2-335960"></A><A NAME="IXT-2-335961"></A><A NAME="IXT-2-335962"></A>
			Unlike in C, those block curly braces are required around the
			conditional code. It's a good idea to indent the contents of the
			blocks of code as we show here; that makes it easier to see what's
			going on. If you're using a programmers' text editor (as discussed
			in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-1#lperl3-CHP-1">Chapter
			1</A>), it'll do most of the work for you. 
			</P>
			<H4><A NAME="lperl3-CHP-2-SECT-7.1"></A>2.7.1 Boolean Values</H4>
			<P>You may actually use any scalar value as the conditional of the
			<TT><FONT COLOR="#cc0000">if</FONT></TT> control structure. That's
			handy if you want to store a true or false value into a variable,
			like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">$is_bigger = $name gt 'fred';</FONT>
<FONT COLOR="#cc0000">if ($is_bigger) { ... }</FONT></PRE><P>
			<A NAME="IXT-2-335963"></A>But how does Perl decide whether a
			given value is true or false? Perl doesn't have a separate Boolean
			data type, like some languages have. Instead, it uses a few simple
			rules: 
			</P>
			<OL>
				<LI><P>The special value <TT><FONT COLOR="#cc0000">undef</FONT></TT>
				is false. (We'll see this a little later in this section.) 
				</P>
				<LI><P STYLE="font-weight: medium">Zero is false; all other
				numbers are true.</P>
				<LI><P>The empty string (<TT><FONT COLOR="#cc0000">''</FONT></TT>)
				is false; all other strings are normally true. 
				</P>
				<LI><P>The one exception: since numbers and strings are
				equivalent, the string form of zero, <TT><FONT COLOR="#cc0000">'0'</FONT></TT>,
				has the same value as its numeric form: false. 
				</P>
			</OL>
			<P>So, if your scalar value is<SPAN STYLE="background: #94bd5e">
			</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">undef</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">0</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">''</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			or </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">'0'</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			it's false.</SPAN> All other scalars are true&iuml;&frac34;—including
			all of the types of scalars that we haven't told you about yet. 
			</P>
			<P><A NAME="IXT-2-335964"></A><A NAME="IXT-2-335965"></A><A NAME="IXT-2-335966"></A>
			If you need to get the opposite of any Boolean value, use the
			unary not operator, <TT><FONT COLOR="#cc0000">!</FONT></TT>. If
			what follows it is a true value, it returns false; if what follows
			is false, it returns true: 
			</P>
			<PRE><FONT COLOR="#cc0000">if (! $is_bigger) {</FONT>
<FONT COLOR="#cc0000">  # Do something when $is_bigger is not true</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-8"></A>2.8 Getting User Input</H3>
			<P><A NAME="IXT-2-335967"></A><A NAME="IXT-2-335968"></A><A NAME="IXT-2-335969"></A><A NAME="IXT-2-335970"></A>
			At this point, you're probably wondering how to get a value from
			the keyboard into a Perl program. Here's the simplest way: use the
			line-input operator, <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>
			.<A HREF="#">[24]</A> Each time you use <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>
			in a place where a scalar value is expected, Perl reads the next
			complete text line from standard input (up to the first newline),
			and uses that string as the value of <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>.
			Standard input can mean many things, but unless you do something
			uncommon, it means the keyboard of the user who invoked your
			program (probably you). If there's nothing waiting to be read
			(typically the case, unless you type ahead a complete line), the
			Perl program will stop and wait for you to enter some characters
			followed by a newline (return).<A HREF="#">[25]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[24]</SUP>
			This is actually a line-input operator working on the filehandle
			<TT><FONT COLOR="#cc0000">STDIN</FONT></TT>, but we can't tell you
			about that until we get to filehandles (in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-11#lperl3-CHP-11">Chapter
			11</A>).</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[25]</SUP> To
			be honest, it's normally your system that waits for the input;
			Perl waits for your system. Although the details depend upon your
			system and its configuration, you can generally correct your
			mistyping with a backspace key before you press return&iuml;&frac34;—your
			system handles that, not Perl itself. If you need more control
			over the input, get the <TT><FONT COLOR="#cc0000">Term::ReadLine</FONT></TT>
			module from CPAN.</P>
			<P>The string value of <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>
			typically has a newline character on the end of it.<A HREF="#">[26]</A>
			So you could do something like this: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[26]</SUP> The
			exception is if the standard input stream somehow runs out in the
			middle of a line. But that's not a proper text file, of course!</P>
			<PRE><FONT COLOR="#cc0000">$line = &lt;STDIN&gt;;</FONT>
<FONT COLOR="#cc0000">if ($line eq &quot;\n&quot;) {</FONT>
<FONT COLOR="#cc0000">  print &quot;That was just a blank line!\n&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;That line of input was: $line&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			But in practice, you don't often want to keep the newline, so you
			need the <TT><FONT COLOR="#cc0000">chomp</FONT></TT> operator. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-9"></A>2.9 The chomp Operator</H3>
			<P><A NAME="IXT-2-335971"></A><A NAME="IXT-2-335972"></A>The first
			time you read about the <TT><FONT COLOR="#cc0000">chomp</FONT></TT>
			operator, it seems terribly overspecialized. It works on a
			variable. The variable has to hold a string. And if the string
			ends in a newline character, <TT><FONT COLOR="#cc0000">chomp</FONT></TT>
			can get rid of the newline. That's (nearly) all it does. For
			example: 
			</P>
			<PRE><FONT COLOR="#cc0000">$text = &quot;a line of text\n&quot;; # Or the same thing from &lt;STDIN&gt;</FONT>
<FONT COLOR="#cc0000">chomp($text);               # Gets rid of the newline character</FONT></PRE><P>
			But it turns out to be so useful, you'll put it into nearly every
			program you write. As you see, it's the best way to remove a
			trailing newline from a string in a variable. In fact, there's an
			easier way to use <TT><FONT COLOR="#cc0000">chomp</FONT></TT>,
			because of a simple rule: any time that you need a variable in
			Perl, you can use an assignment instead. First, Perl does the
			assignment. Then it uses the variable in whatever way you
			requested. So the most common use of <TT><FONT COLOR="#cc0000">chomp</FONT></TT>
			looks like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">chomp($text = &lt;STDIN&gt;); # Read the text, without the newline character</FONT>

<FONT COLOR="#cc0000">$text = &lt;STDIN&gt;;        # Do the same thing...</FONT>
<FONT COLOR="#cc0000">chomp($text);           # ...but in two steps</FONT></PRE><P>
			At first glance, the combined <TT><FONT COLOR="#cc0000">chomp</FONT></TT>
			may not seem to be the easy way, especially if it seems more
			complex! If you think of it as two operations&iuml;&frac34;—read
			a line, then <TT><FONT COLOR="#cc0000">chomp</FONT></TT> it&iuml;&frac34;—then
			it's more natural to write it as two statements. But if you think
			of it as one operation&iuml;&frac34;—read just the text, not the
			newline&iuml;&frac34;—it's more natural to write the one
			statement. And since most other Perl programmers are going to
			write it that way, you may as well get used to it now. 
			</P>
			<P><TT><FONT COLOR="#cc0000">chomp</FONT></TT> is actually a
			function. As a function, it has a return value, which is the
			number of characters removed. This number is hardly ever useful: 
			</P>
			<PRE><FONT COLOR="#cc0000">$food = &lt;STDIN&gt;;</FONT>
<FONT COLOR="#cc0000">$betty = chomp $food; # gets the value 1 - but we knew that!</FONT></PRE><P>
			As you see, you may write <TT><FONT COLOR="#cc0000">chomp</FONT></TT>
			with or without the parentheses. This is another general rule in
			Perl: except in cases where it changes the meaning to remove them,
			parentheses are always optional. 
			</P>
			<P>If a line ends with two or more newlines,<A HREF="#">[27]</A>
			<TT><FONT COLOR="#cc0000">chomp</FONT></TT> removes only one. If
			there's no newline, it does nothing, and returns zero. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[27]</SUP>
			This situation can't arise if we're reading a line at a time, but
			it certainly can when we have set the input separator (<TT><FONT COLOR="#cc0000">$/</FONT></TT>)
			to something other than newline, or use the <TT><FONT COLOR="#cc0000">read</FONT></TT>
			function, or perhaps have glued some strings together ourselves.</P>
			<P>If you work with older Perl programs, you may run across the
			<TT><FONT COLOR="#cc0000">chop</FONT></TT> operator. It's similar,
			but removes any trailing character, not just a trailing newline.
			Since that could accidentally turn <TT><FONT COLOR="#cc0000">pebbles</FONT></TT>
			into <TT><FONT COLOR="#cc0000">pebble</FONT></TT>, it's usually
			not what you want. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-10"></A>BookMark030126 2.10 The
			while Control Structure</H3>
			<P><A NAME="IXT-2-335976"></A><A NAME="IXT-2-335977"></A><A NAME="IXT-2-335978"></A>
			Like most algorithmic programming languages, Perl has a number of
			looping structures.<A HREF="#">[28]</A> The <TT><FONT COLOR="#cc0000">while</FONT></TT>
			loop repeats a block of code as long as a condition is true: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-2-335973"></A><A NAME="IXT-2-335974"></A><A NAME="IXT-2-335975"></A>
			<SUP>[28]</SUP> Every programmer eventually creates an infinite
			loop by accident. If your program keeps running and running,
			though, you can generally stop it in the same way you'd stop any
			other program on your system. Often, typing Control-C will stop a
			runaway program; check with your system's documentation to be
			sure.</P>
			<PRE><FONT COLOR="#cc0000">$count = 0;</FONT>
<FONT COLOR="#cc0000">while ($count &lt; 10) {</FONT>
<FONT COLOR="#cc0000">  $count += 1;</FONT>
<FONT COLOR="#cc0000">  print &quot;count is now $count\n&quot;; # Gives values from 1 to 10</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-2-335979"></A><A NAME="IXT-2-335980"></A>As always in
			Perl, the truth value here works like the truth value in the <TT><FONT COLOR="#cc0000">if</FONT></TT>
			test. Also like the <TT><FONT COLOR="#cc0000">if</FONT></TT>
			control structure, the block curly braces are required. The
			conditional expression is evaluated before the first iteration, so
			the loop may be skipped completely, if the condition is initially
			false. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-11"></A>2.11 The undef Value</H3>
			<P><A NAME="IXT-2-335981"></A><A NAME="IXT-2-335982"></A>What
			happens if you use a scalar variable before you give it a value?
			Nothing serious, and definitely nothing fatal. <SPAN STYLE="background: #94bd5e">Variables
			have the special </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">undef</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			value before they are first assigned,</SPAN> which is just Perl's
			way of saying &quot;nothing here to look at&iuml;&frac34;—move
			along, move along.&quot;<SPAN STYLE="background: #7da647"> If you
			try to use this &quot;nothing&quot; as a &quot;numeric something,&quot;
			it acts like 0.</SPAN> If you try to use it as a &quot;string
			something,&quot; it <SPAN STYLE="background: #7da647">acts like
			the empty string</SPAN>. But <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			is neither a number nor a string; <SPAN STYLE="background: #94bd5e">it's
			an entirely separate kind of scalar value.</SPAN> 
			</P>
			<P>Because <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			automatically acts like zero when used as a number, it's easy to
			make an numeric accumulator that starts out empty: 
			</P>
			<PRE><FONT COLOR="#cc0000"># Add up some odd numbers</FONT>
<FONT COLOR="#cc0000">$n = 1;</FONT>
<FONT COLOR="#cc0000">while ($n &lt; 10) {</FONT>
<FONT COLOR="#cc0000">  $sum += $n;</FONT>
<FONT COLOR="#cc0000">  $n += 2; # On to the next odd number</FONT>
<FONT COLOR="#cc0000">}</FONT>
<FONT COLOR="#cc0000">print &quot;The total was $sum.\n&quot;;</FONT></PRE><P>
			This works properly when <TT><FONT COLOR="#cc0000">$sum</FONT></TT>
			was <TT><FONT COLOR="#cc0000">undef</FONT></TT> before the loop
			started. The first time through the loop, <TT><FONT COLOR="#cc0000">$n</FONT></TT>
			is one, so the first line inside the loop adds one to <TT><FONT COLOR="#cc0000">$sum</FONT></TT>.
			That's like adding one to a variable that already holds zero
			(because we're using <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			as if it were a number). So now it has the value <TT><FONT COLOR="#cc0000">1</FONT></TT>.
			After that, since it's been initialized, adding works in the
			traditional way. 
			</P>
			<P><A NAME="IXT-2-335983"></A>Similarly, you could have a string
			accumulator that starts out empty: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$string .= &quot;more text\n&quot;;</FONT></PRE><P>
			If <TT><FONT COLOR="#cc0000">$string</FONT></TT> is <TT><FONT COLOR="#cc0000">undef</FONT></TT>,
			this will act as if it already held the empty string, putting
			<TT><FONT COLOR="#cc0000">&quot;more text\n&quot;</FONT></TT> into
			that variable. But if it already holds a string, the new text is
			simply appended. 
			</P>
			<P>Perl programmers frequently use a new variable in this way,
			letting it act as either zero or the empty string as needed. 
			</P>
			<P>Many operators return <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			when the arguments are out of range or don't make sense. If you
			don't do anything special, you'll get a zero or a null string
			without major consequences. In practice, this is hardly a problem.
			In fact, most programmers will rely upon this behavior. But you
			should know that when warnings are turned on, Perl will typically
			warn about unusual uses of the undefined value, since that may
			indicate a bug. For example, simply copying <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			from one variable into another isn't a problem, but trying to
			<TT><FONT COLOR="#cc0000">print</FONT></TT> it would generally
			cause a warning. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-12"></A>2.12 The defined Function</H3>
			<P><A NAME="IXT-2-335984"></A><A NAME="IXT-2-335985"></A>One
			operator that can return <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			is the line-input operator, <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>.
			Normally, it will return a line of text. <SPAN STYLE="background: #94bd5e">But
			if there is no more input, such as at end-of-file, it returns
			</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">undef</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			to signal this</SPAN>.<A HREF="#">[29]</A> To tell whether a value
			is <TT><FONT COLOR="#cc0000">undef</FONT></TT> and not the empty
			string, use the <TT><FONT COLOR="#cc0000">defined</FONT></TT>
			function, which returns false for <TT><FONT COLOR="#cc0000">undef</FONT></TT>,
			and true for everything else: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[29]</SUP>
			Normally, there's no &quot;end-of-file&quot; when the input comes
			from the keyboard, but input may have been redirected to come from
			a file. Or the user may have pressed the key that the system
			recognizes to indicate end-of-file. 
			</P>
			<PRE><FONT COLOR="#cc0000">$madonna = &lt;STDIN&gt;;</FONT>
<FONT COLOR="#cc0000">if ( defined($madonna) ) {</FONT>
<FONT COLOR="#cc0000">  print &quot;The input was $madonna&quot;;</FONT>
<FONT COLOR="#cc0000">} else {</FONT>
<FONT COLOR="#cc0000">  print &quot;No input available!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-2-335986"></A>If you'd like to make your own <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			values, you can use the obscurely named <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			operator: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$madonna = undef; # As if it had never been touched</FONT></PRE><P>
			<A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic9" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-2-SECT-13"></A>2.13 Exercises</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-1#lperl3-APP-A-SECT-1">Section
			A.1</A> for answers to the following exercises: 
			</P>
			<OL>
				<LI><P STYLE="font-weight: medium">[5] Write a program that
				computes the circumference of a circle with a radius of 12.5.
				Circumference is 2<IMG SRC="U03C0.gif" NAME="Graphic10" ALT="U03C0.gif" ALIGN=BOTTOM WIDTH=18 HEIGHT=15 BORDER=0>
				times the radius (approximately 2 times 3.141592654). The answer
				you get should be about 78.5. 
				</P>
				<LI><P STYLE="font-weight: medium">[4] Modify the program from
				the previous exercise to prompt for and accept a radius from the
				person running the program. So, if the user enters 12.5 for the
				radius, she should get the same number as in the previous
				exercise. 
				</P>
				<LI><P STYLE="font-weight: medium">[4] Modify the program from
				the previous exercise so that, if the user enters a number less
				than zero, the reported circumference will be zero, rather than
				negative. 
				</P>
				<LI><P STYLE="font-weight: medium">[8] Write a program that
				prompts for and reads two numbers (on separate lines of input)
				and prints out the product of the two numbers multiplied
				together. 
				</P>
				<LI><P STYLE="font-weight: medium"><A NAME="IXTR3-15"></A>[8]
				Write a program that prompts for and reads a string and a number
				(on separate lines of input) and prints out the string the number
				of times indicated by the number on separate lines. (Hint: Use
				the &quot;x&quot; operator.) If the user enters &quot;fred&quot;
				and &quot;3,&quot; the output should be three lines, each saying
				&quot;fred&quot;. If the user enters &quot;fred&quot; and
				&quot;299792,&quot; there may be a lot of output. 
				</P>
			</OL>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic11" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H2><A NAME="lperl3-CHP-3"></A>Chapter 3. Lists and Arrays 
			</H2>
			<P><A NAME="lperl3-IDXTERM-259"></A><A NAME="lperl3-IDXTERM-260"></A>
			If a scalar was the &quot;singular&quot; in Perl, as we described
			them at the beginning of <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-2#lperl3-CHP-2">Chapter
			2</A>, the &quot;plural&quot; in Perl is represented by lists and
			arrays. 
			</P>
			<P>A<SPAN STYLE="background: #94bd5e"> list is an ordered
			collection of scalars.</SPAN> <SPAN STYLE="background: #94bd5e">An
			array is a variable that contains a list. </SPAN>In Perl, the two
			terms are often used as if they're interchangeable. But, to be
			accurate, the list is the data, and the array is the variable. You
			can have a list value that isn't in an array, but every array
			variable holds a list (although that list may be empty). <A HREF="#lperl3-CHP-3-FIG-1">Figure
			3-1</A> represents a list, whether it's stored in an array or not.
			
			</P>
			<H5 ALIGN=CENTER><A NAME="lperl3-CHP-3-FIG-1"></A>Figure 3-1. A
			list with five elements</H5>
			<P ALIGN=CENTER><IMG SRC="lrnp_0301.gif" NAME="Graphic12" ALT="lrnp_0301.gif" ALIGN=BOTTOM WIDTH=180 HEIGHT=156 BORDER=0></P>
			<P><A NAME="IXT-3-335987"></A><A NAME="IXT-3-335988"></A>Each
			element of an array or list is a separate scalar variable with an
			independent scalar value. These values are ordered&iuml;&frac34;—that
			is, they have a particular sequence from the first to the last
			element. The elements of an array or list are indexed by small
			integers starting at zero<A HREF="#">[1]</A> and counting by ones,
			so the first element of any array or list is always element zero. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP>
			Array and list indices always start at zero in Perl, unlike in
			some other languages. In early Perl, it was possible to change the
			starting number of array and list indexing (not for just one array
			or list, but for all of them at once!). Larry later realized that
			this was a misfeature, and its (ab)use is now strongly
			discouraged. But, if you're terminally curious, look up the
			<TT><FONT COLOR="#cc0000">$[</FONT></TT>variable in the
			perlvarmanpage.</P>
			<P>Since each element is an independent scalar value, a <SPAN STYLE="background: #94bd5e">list
			or array</SPAN> may hold numbers, strings, <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			values, or <SPAN STYLE="background: #94bd5e">any mixture of
			different scalar values. </SPAN>Nevertheless, it's most common to
			have all elements of the same type, such as a list of book titles
			(all strings) or a list of cosines (all numbers). 
			</P>
			<P>Arrays and lists can have any number of elements. The smallest
			one has no elements, while the largest can fill all of available
			memory. Once again, this is in keeping with Perl's philosophy of
			&quot;no unnecessary limits.&quot; 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-1"></A>3.1 Accessing Elements of an
			Array</H3>
			<P><A NAME="IXT-3-335989"></A>If you've used arrays in another
			language, you won't be surprised to find that Perl provides a way
			to subscript an array in order to refer to an element by a numeric
			index. 
			</P>
			<P><A NAME="IXT-3-335990"></A><A NAME="IXT-3-335991"></A>The array
			elements are numbered using sequential integers, beginning at zero
			and increasing by one for each element, like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">$fred[0] = &quot;yabba&quot;;</FONT>
<FONT COLOR="#cc0000">$fred[1] = &quot;dabba&quot;;</FONT>
<FONT COLOR="#cc0000">$fred[2] = &quot;doo&quot;;</FONT></PRE><P>
			The array name itself (in this case, <TT><FONT COLOR="#cc0000">&quot;fred&quot;</FONT></TT>)
			is from a completely separate namespace than scalars use; <SPAN STYLE="background: #7da647">you
			could have a scalar variable named </SPAN><TT><SPAN STYLE="background: #7da647"><FONT COLOR="#cc0000">$fred</FONT></SPAN></TT><SPAN STYLE="background: #7da647">
			in the same program, and Perl will treat them as different things,</SPAN>
			and wouldn't be confused.<A HREF="#">[2]</A> (Your maintenance
			programmer might be confused, though, so don't capriciously make
			all of your variable names the same!) 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> The
			syntax is always unambiguous&iuml;&frac34;—tricky perhaps, but
			unambiguous.</P>
			<P>You can use an array element like <TT><FONT COLOR="#cc0000">$fred[2]</FONT></TT>
			in every place<A HREF="#">[3]</A> where you could use any other
			scalar variable like <TT><FONT COLOR="#cc0000">$fred</FONT></TT>.
			For example, you can get the value from an array element or change
			that value by the same sorts of expressions we used in the
			previous chapter: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP>
			Well, almost. The most notable exception is that the control
			variable of a <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop,
			which we'll see later in this chapter, must be a simple scalar.
			And there are others, like the &quot;indirect object slot&quot;
			and &quot;indirect filehandle slot&quot; for <TT><FONT COLOR="#cc0000">print
			</FONT></TT>and <TT><FONT COLOR="#cc0000">printf</FONT></TT>.</P>
			<PRE><FONT COLOR="#cc0000">print $fred[0];</FONT>
<FONT COLOR="#cc0000">$fred[2] = &quot;diddley&quot;;</FONT>
<FONT COLOR="#cc0000">$fred[1] .= &quot;whatsis&quot;;</FONT></PRE><P>
			Of course, the <SPAN STYLE="background: #94bd5e">subscript</SPAN>
			may be any expression that gives a numeric value. If it's not an
			integer already, it'll <SPAN STYLE="background: #94bd5e">automatically
			be truncated to the next lower integer: </SPAN>
			</P>
			<PRE><FONT COLOR="#cc0000">$number = 2.71828;</FONT>
<FONT COLOR="#cc0000">print $fred[$number - 1]; # Same as printing $fred[1]</FONT></PRE><P>
			If the subscript indicates an element that would be beyond the end
			of the array, the corresponding value will be <TT><FONT COLOR="#cc0000">undef</FONT></TT>.
			This is just as with ordinary scalars; if you've never stored a
			value into the variable, it's <TT><FONT COLOR="#cc0000">undef</FONT></TT>.
			
			</P>
			<PRE><FONT COLOR="#cc0000">$blank = $fred[ 142_857 ]; # unused array element gives undef</FONT>
<FONT COLOR="#cc0000">$blank = $mel;             # unused scalar $mel also gives undef</FONT></PRE><P>
			<A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic13" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-2"></A>3.2 Special Array Indices</H3>
			<P><A NAME="IXT-3-335992"></A>If you store into an array element
			that is beyond the end of the array, the<SPAN STYLE="background: #94bd5e">
			array is automatically extended</SPAN> as needed&iuml;&frac34;—there's
			no limit on its length, as long as there's available memory for
			Perl to use. If <SPAN STYLE="background: #94bd5e">intervening
			elements need to be created,</SPAN> they'll be created as <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			values. 
			</P>
			<PRE><FONT COLOR="#cc0000">$rocks[0] = 'bedrock';      # One element...</FONT>
<FONT COLOR="#cc0000">$rocks[1] = 'slate';        # another...</FONT>
<FONT COLOR="#cc0000">$rocks[2] = 'lava';         # and another...</FONT>
<FONT COLOR="#cc0000">$rocks[3] = 'crushed rock'; # and another...</FONT>
<FONT COLOR="#cc0000">$rocks[99] = 'schist';      # now there are 95 undef elements</FONT></PRE><P>
			Sometimes, you need to find out the last element index in an
			array. For the array of <TT><FONT COLOR="#cc0000">rocks</FONT></TT>
			that we've just been using, the <SPAN STYLE="background: #eb613d">last
			element index is </SPAN><TT><SPAN STYLE="background: #eb613d"><FONT COLOR="#cc0000">$#rocks</FONT></SPAN></TT><SPAN STYLE="background: #eb613d">.</SPAN><A HREF="#"><SPAN STYLE="background: #eb613d">[4]</SPAN></A><SPAN STYLE="background: #eb613d">
			</SPAN>That's not the same as the number of elements, though,
			because there's an element number zero. As seen in the code
			snippet below, it's actually possible to assign to this value to
			change the size of the array, although this is rare in
			practice.<A HREF="#">[5]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP>
			Blame this ugly syntax on the C shell. Fortunately, we don't have
			to look at this very often in the real world.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[5]</SUP> This
			is very infrequently done to &quot;pre-size&quot; an array, so
			that Perl won't need to allocate memory in many small chunks as an
			array grows. See the Perl documentation for more information, in
			the unlikely case that you need this.</P>
			<PRE><FONT COLOR="#cc0000">$end = $#rocks;                  # 99, which is the last element's index</FONT>
<FONT COLOR="#cc0000">$number_of_rocks = $end + 1;     # okay, but we'll see a better way later</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">$#rocks = 2;                     # Forget all rocks after 'lava'</SPAN></FONT>
<FONT COLOR="#cc0000">$#rocks = 99;                    # add 97 undef elements (the forgotten rocks are</FONT>
<FONT COLOR="#cc0000">                                 # gone forever)</FONT>
<FONT COLOR="#cc0000">$rocks[ $#rocks ] = 'hard rock'; # the last rock</FONT></PRE><P>
			<A NAME="IXT-3-335993"></A>Using the <TT><FONT COLOR="#cc0000">$#name</FONT></TT>
			value as an index, like that last example, happens often enough
			that Larry has provided a shortcut: <SPAN STYLE="background: #94bd5e">negative
			array indices count from the end of the array.</SPAN> But don't
			get the idea that these indices &quot;wrap around.&quot; If you've
			got three elements in the array, the valid negative indices are <TT><FONT COLOR="#cc0000">-1</FONT></TT>
			(the last element), <TT><FONT COLOR="#cc0000">-2</FONT></TT> (the
			middle element), and <TT><FONT COLOR="#cc0000">-3</FONT></TT> (the
			first element). In the real world, nobody seems to use any of
			these except <TT><FONT COLOR="#cc0000">-1</FONT></TT>, though. 
			</P>
			<PRE><FONT COLOR="#cc0000">$rocks[ -1 ] = 'hard rock'; # easier way to do that last example above</FONT>
<FONT COLOR="#cc0000">$dead_rock = $rocks[-100];  # gets 'bedrock'</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #eb613d">$rocks[ -200 ] = 'crystal'; # fatal error!</SPAN></FONT></PRE><P>
			<A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic14" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-3"></A>3.3 List Literals</H3>
			<P><A NAME="IXT-3-335994"></A>A list literal (the way you
			represent a list value within your program) is a list of
			comma-separated values enclosed in parentheses. These values form
			the elements of the list. For example: 
			</P>
			<PRE><FONT COLOR="#cc0000">(1, 2, 3)      # list of three values 1, 2, and 3</FONT>
<FONT COLOR="#cc0000">(1, 2, 3,)     # the same three values (the trailing comma is ignored)</FONT>
<FONT COLOR="#cc0000">(&quot;fred&quot;, 4.5)  # two values, &quot;fred&quot; and 4.5</FONT>
<FONT COLOR="#cc0000">( )             # empty list - zero elements</FONT>
<FONT COLOR="#cc0000">(1..100)       # list of 100 integers</FONT></PRE><P>
			<A NAME="IXT-3-335995"></A><A NAME="IXT-3-335996"></A>That last
			one uses the<SPAN STYLE="background: #94bd5e"> .. range operator</SPAN>,
			which is seen here for the first time. That operator creates a
			list of values by counting from the left scalar up to the right
			scalar by ones. For example: 
			</P>
			<PRE><FONT COLOR="#cc0000">(1..5)            # same as (1, 2, 3, 4, 5)</FONT>
<FONT COLOR="#cc0000">(1.7..5.7)        # same thing - both values are truncated</FONT>
<FONT COLOR="#cc0000">(5..1)            # empty list - .. only counts &quot;uphill&quot;</FONT>
<FONT COLOR="#cc0000">(0, 2..6, 10, 12) # same as (0, 2, 3, 4, 5, 6, 10, 12)</FONT>
<FONT COLOR="#cc0000">($a..$b)          # range determined by current values of $a and $b</FONT>
<FONT COLOR="#cc0000">(0..$#rocks)      # the indices of the rocks array from the previous section</FONT></PRE><P>
			As you can see from those last two items, the elements of an array
			are not necessarily constants&iuml;&frac34;—they can be
			expressions that will be newly evaluated each time the literal is
			used. For example: 
			</P>
			<PRE><FONT COLOR="#cc0000">($a, 17)       # two values: the current value of $a, and 17</FONT>
<FONT COLOR="#cc0000">($b+$c, $d+$e) # two values</FONT></PRE><P>
			Of course, a list may have any scalar values, like this typical
			list of strings: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">(&quot;fred&quot;, &quot;barney&quot;, &quot;betty&quot;, &quot;wilma&quot;, &quot;dino&quot;)</FONT></PRE><H4>
			<A NAME="lperl3-CHP-3-SECT-3.1"></A>3.3.1 The <SPAN STYLE="background: #94bd5e">qw
			Shortcut</SPAN></H4>
			<P><A NAME="IXT-3-335997"></A><A NAME="IXT-3-335998"></A>It turns
			out that lists of simple words (like the previous example) are
			frequently needed in Perl programs. The <TT><FONT COLOR="#cc0000">qw</FONT></TT>
			shortcut makes it easy to generate them <SPAN STYLE="background: #94bd5e">without
			typing a lot of extra quote marks: </SPAN>
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">qw/ fred barney betty wilma dino /</SPAN> # same as above, but less typing</FONT></PRE><P>
			<A NAME="IXT-3-335999"></A><TT><FONT COLOR="#cc0000">qw</FONT></TT>
			stands for &quot;quoted words&quot; or &quot;quoted by
			whitespace,&quot; depending upon whom you ask. Either way, Perl
			treats it like a single-quoted string (so, you can't use <TT><FONT COLOR="#cc0000">\n</FONT></TT>
			or <TT><FONT COLOR="#cc0000">$fred</FONT></TT> inside a <TT><FONT COLOR="#cc0000">qw</FONT></TT>
			list as you would in a double-quoted string). The whitespace
			(characters like spaces, tabs, and newlines) will be discarded,
			and whatever is left becomes the list of items. Since whitespace
			is discarded, here's another (but unusual) way to write that same
			list: 
			</P>
			<PRE><FONT COLOR="#cc0000">qw/fred</FONT>
<FONT COLOR="#cc0000">  barney     betty</FONT>
<FONT COLOR="#cc0000">wilma dino/   # same as above, but pretty strange whitespace</FONT></PRE><P>
			<A NAME="IXT-3-336000"></A>Since <TT><FONT COLOR="#cc0000">qw</FONT></TT>
			is a form of quoting, though, you can't put comments inside a <TT><FONT COLOR="#cc0000">qw</FONT></TT>
			list. 
			</P>
			<P><A NAME="IXT-3-336001"></A>The previous two examples have used
			forward slashes as the delimiter, but Perl actually lets you
			choose any punctuation character as the delimiter. Here are some
			of the common ones: 
			</P>
			<PRE><FONT COLOR="#cc0000">qw! fred barney betty wilma dino !</FONT>
<FONT COLOR="#cc0000">qw# fred barney betty wilma dino #   # like in a comment!</FONT>
<FONT COLOR="#cc0000">qw( fred barney betty wilma dino )</FONT>
<FONT COLOR="#cc0000">qw{ fred barney betty wilma dino }</FONT>
<FONT COLOR="#cc0000">qw[ fred barney betty wilma dino ]</FONT>
<FONT COLOR="#cc0000">qw&lt; fred barney betty wilma dino &gt;</FONT></PRE><P>
			As those last four show, sometimes the two delimiters can be
			different. If the opening delimiter is one of those &quot;left&quot;
			characters, the corresponding &quot;right&quot; character is the
			proper closing delimiter. Other delimiters use the same character
			for start and finish. 
			</P>
			<P>If you need to include the closing delimiter within the string
			as one of the characters, you probably picked the wrong delimiter.
			But even if you can't or don't want to change the delimiter, you
			can still include the character using the backslash: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">qw! yahoo\! google excite lycos ! # include yahoo! as an element</FONT></PRE><P>
			As in single-quoted strings, two consecutive backslashes
			contribute one single backslash to the item. 
			</P>
			<P>Now, although the Perl motto is &quot;There's More Than One Way
			To Do It,&quot; you may well wonder why anyone would need all of
			those different ways! Well, we'll see later that there are other
			kinds of quoting where Perl uses this same rule, and it can come
			in handy in many of those. But even here, it could be useful if
			you were to need a list of Unix filenames: 
			</P>
			<PRE><FONT COLOR="#cc0000">qw{</FONT>
<FONT COLOR="#cc0000">  /usr/dict/words</FONT>
<FONT COLOR="#cc0000">  /home/rootbeer/.ispell_english</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			That list would be quite inconvenient to read, write, and maintain
			if the slash were the only delimiter available. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic15" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-4"></A>3.4 List Assignment</H3>
			<P><A NAME="lperl3-IDXTERM-276"></A><A NAME="lperl3-IDXTERM-277"></A><A NAME="lperl3-IDXTERM-278"></A>
			In much the same way as scalar values may be assigned to
			variables, list values may also be assigned to variables: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">($fred, $barney, $dino) = (&quot;flintstone&quot;, &quot;rubble&quot;, undef);</FONT></PRE><P>
			All three variables in the list on the left get new values, just
			as if we did three separate assignments. Since the list is built
			up before the assignment starts, this makes it easy to swap two
			variables' values in Perl:<A HREF="#">[6]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP> As
			opposed to in languages like C, which has no easy way to do this
			in general. C programmers usually resort to some kind of macro to
			do this, or use a variable to temporarily hold the value.</P>
			<PRE><FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">($fred, $barney) = ($barney, $fred); # swap those values</SPAN></FONT>
<FONT COLOR="#cc0000">($betty[0], $betty[1]) = ($betty[1], $betty[0]);</FONT></PRE><P>
			But what happens if the number of variables (on the left side of
			the equals sign) isn't the same as the number of values (from the
			right side)? In a <SPAN STYLE="background: #94bd5e">list</SPAN>
			assignment, <SPAN STYLE="background: #94bd5e">extra values are
			silently ignored</SPAN>&iuml;&frac34;—Perl figures that if you
			wanted those values stored somewhere, you would have told it where
			to store them. Alternatively, if you have too many <SPAN STYLE="background: #94bd5e">variables,
			the extras get the value </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">undef</FONT></SPAN></TT><SPAN STYLE="background: transparent">.</SPAN><A HREF="#"><SPAN STYLE="background: transparent">[7]</SPAN></A><SPAN STYLE="background: transparent">
			</SPAN>
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP>
			Well, that's true for scalar variables. Array variables get an
			empty list, as we'll see in a moment.</P>
			<PRE><FONT COLOR="#cc0000">($fred, $barney) = qw&lt; flintstone rubble slate granite &gt;; # two ignored items</FONT>
<FONT COLOR="#cc0000">($wilma, $dino) = qw[flintstone];                         # $dino gets undef</FONT></PRE><P>
			Now that we can assign lists, you could build up an array of
			strings with a line of code like this:<A HREF="#">[8]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP>
			We're cheating by assuming that the <TT><FONT COLOR="#cc0000">rocks</FONT></TT>
			array is empty before this statement. If there were a value in
			<TT><FONT COLOR="#cc0000">$rocks[7]</FONT></TT>, say, this
			assignment wouldn't affect that element. 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">($rocks[0], $rocks[1], $rocks[2], $rocks[3]) = qw/talc mica feldspar quartz/;</FONT></PRE><P>
			<A NAME="IXT-3-336002"></A><A NAME="IXT-3-336003"></A>But when you
			wish to r<SPAN STYLE="background: #94bd5e">efer to an entire
			array</SPAN>, Perl has a simpler notation. Just use the at-sign
			(<TT><FONT COLOR="#cc0000">@</FONT></TT>) before the name of the
			array (and no index brackets after it) to refer to the entire
			array at once. You can read this as &quot;all of the,&quot; so
			<TT><FONT COLOR="#cc0000">@rocks</FONT></TT> is &quot;all of the
			rocks.&quot;<A HREF="#">[9]</A> This works on either side of the
			assignment operator: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[9]</SUP>
			Larry claims that he chose the dollar and at-sign because they can
			be read as <TT><FONT COLOR="#cc0000">$calar</FONT></TT> (scalar)
			and <TT><FONT COLOR="#cc0000">@rray</FONT></TT> (array). If you
			don't get that, or remember it that way, no big deal.</P>
			<PRE><FONT COLOR="#cc0000">@rocks = qw/ bedrock slate lava /;</FONT>
<FONT COLOR="#cc0000">@tiny = ( );                       # the empty list</FONT>
<FONT COLOR="#cc0000">@giant = 1..1e5;                  # a list with 100,000 elements</FONT>
<FONT COLOR="#cc0000">@stuff = (@giant, undef, @giant); # a list with 200,001 elements</FONT>
<FONT COLOR="#cc0000">$dino = &quot;granite&quot;;</FONT>
<FONT COLOR="#cc0000">@quarry = (@rocks, &quot;crushed rock&quot;, @tiny, $dino);</FONT></PRE><P>
			That last assignment gives <TT><FONT COLOR="#cc0000">@quarry</FONT></TT>
			the five-element list <TT><FONT COLOR="#cc0000">(bedrock, slate,
			lava, crushed rock, granite)</FONT></TT>, <SPAN STYLE="background: #94bd5e">since
			</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">@tiny</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			contributes zero elements to the list. </SPAN>(In particular, it
			doesn't put an <TT><FONT COLOR="#cc0000">undef</FONT></TT> item
			into the list&iuml;&frac34;—but we could do that explicitly, as
			we did with <TT><FONT COLOR="#cc0000">@stuff</FONT></TT> earlier.)
			It's also worth noting that an <SPAN STYLE="background: #94bd5e">array
			name is replaced by the list it contains</SPAN>. An <SPAN STYLE="background: #94bd5e">array
			doesn't become an element in the list,</SPAN> because these arrays
			can contain only scalars, not other arrays.<A HREF="#">[10]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-3-336004"></A>
			<SUP>[10]</SUP> But when you get into more advanced Perl, you'll
			learn about a special kind of scalar called a reference. That lets
			us make what are informally called &quot;lists of lists&quot;,
			among other interesting and useful structures. But in that case,
			you're still not really storing a list into a list; you're storing
			a reference to an array.</P>
			<P>The value of an array variable that has not yet been assigned
			is <TT><FONT COLOR="#cc0000">( )</FONT></TT>, the empty list. Just
			as new, empty scalars start out with <TT><FONT COLOR="#cc0000">undef</FONT></TT>,
			new, empty arrays start out with the empty list. 
			</P>
			<P>It's worth noting that when an array is copied to another
			array, it's still a list assignment. The lists are simply stored
			in arrays. For example: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">@copy = @quarry; # copy a list from one array to another</FONT></PRE><H4>
			<A NAME="lperl3-CHP-3-SECT-4.1"></A>3.4.1 The pop and push
			Operators</H4>
			<P>You could add new items to the end of an array by simply
			storing them into elements with new, larger indices. <SPAN STYLE="background: #eb613d">But
			real Perl programmers don't use indices.</SPAN><A HREF="#">[11]</A>
			So in the next few sections, we'll present some ways to work with
			an array without using indices. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP> Of
			course, we're joking. But there's a kernel of truth in this joke.
			Indexing into arrays is not using Perl's strengths. If you use the
			<TT><FONT COLOR="#cc0000">pop</FONT></TT>, <TT><FONT COLOR="#cc0000">push</FONT></TT>,
			and similar operators that avoid using indexing, your code will
			generally be faster than if you use many indices, as well as being
			more likely to avoid &quot;off-by-one&quot; errors, often called
			&quot;fencepost&quot; errors. Occasionally, a beginning Perl
			programmer (wanting to see how Perl's speed compares to C's) will
			take, say, a sorting algorithm optimized for C (with many array
			index operations), rewrite it straightforward in Perl (again, with
			many index operations) and wonder why it's so slow. The answer is
			that using a Stradivarius violin to pound nails should not be
			considered a sound construction technique.</P>
			<P>One common use of an array is as a stack of information, where
			new values are added to and removed from the right-hand side of
			the list. (This is the end with the &quot;last&quot; items in the
			array, the end with the highest index values.) These operations
			occur often enough to have their own special functions. 
			</P>
			<P><A NAME="IXT-3-336005"></A><A NAME="IXT-3-336006"></A>The <TT><FONT COLOR="#cc0000">pop</FONT></TT>
			operator takes the last element off of an array, and returns it: 
			</P>
			<PRE><FONT COLOR="#cc0000">@array = 5..9;</FONT>
<FONT COLOR="#cc0000">$fred = pop(@array);  # $fred gets 9, @array now has (5, 6, 7, 8)</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">$barney = pop @array; # $barney gets 8, @array now has (5, 6, 7)</SPAN></FONT>
<FONT COLOR="#cc0000">pop @array;           # @array now has (5, 6). (The 7 is discarded.)</FONT></PRE><P>
			That last example uses <TT><FONT COLOR="#cc0000">pop</FONT></TT>
			&quot;in a void context,&quot; which is merely a fancy way of
			saying the return value isn't going anywhere. There's nothing
			wrong with using <TT><FONT COLOR="#cc0000">pop</FONT></TT> in this
			way, if that's what you want. 
			</P>
			<P>If the array is empty, <TT><FONT COLOR="#cc0000">pop</FONT></TT>
			will leave it alone (since there is no element to remove), and it
			will return <TT><FONT COLOR="#cc0000">undef</FONT></TT>. 
			</P>
			<P><A NAME="IXT-3-336007"></A>You may have noticed that <TT><FONT COLOR="#cc0000">pop</FONT></TT>
			may be used with or without parentheses. This is a general rule in
			Perl: as long as the meaning isn't changed by removing the
			parentheses, they're optional.<A HREF="#">[12]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP> A
			reader from the educated class will recognize that this is a
			tautology. 
			</P>
			<P><A NAME="IXT-3-336008"></A>The converse operation is <TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">push</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			which adds an element (or a list of elements) to the end of an
			array: </SPAN>
			</P>
			<PRE><FONT COLOR="#cc0000">push(@array, 0);      # @array now has (5, 6, 0)</FONT>
<FONT COLOR="#cc0000">push @array, 8;       # @array now has (5, 6, 0, 8)</FONT>
<FONT COLOR="#cc0000">push @array, 1..10;   # @array now has those ten new elements</FONT>
<FONT COLOR="#cc0000">@others = qw/ 9 0 2 1 0 /;</FONT>
<FONT COLOR="#cc0000">push @array, @others; # @array now has those five new elements (19 total)</FONT></PRE><P>
			Note that the first argument to <TT><FONT COLOR="#cc0000">push</FONT></TT>
			or the only argument for <TT><FONT COLOR="#cc0000">pop</FONT></TT>
			must be an array variable&iuml;&frac34;—pushing and popping
			would not make sense on a literal list. 
			</P>
			<H4><A NAME="lperl3-CHP-3-SECT-4.2"></A>3.4.2 The shift and
			unshift Operators</H4>
			<P><A NAME="IXT-3-336009"></A><A NAME="IXT-3-336010"></A>The <TT><FONT COLOR="#cc0000">push</FONT></TT>
			and <TT><FONT COLOR="#cc0000">pop</FONT></TT> operators do things
			to the end of an array (or the right side of an array, or the
			portion with the highest subscripts, depending upon how you like
			to think of it). Similarly, the <TT><FONT COLOR="#cc0000">unshift</FONT></TT>
			and <TT><FONT COLOR="#cc0000">shift</FONT></TT> operators perform
			the corresponding actions on the &quot;start&quot; of the array
			(or the &quot;left&quot; side of an array, or the portion with the
			lowest subscripts). Here are a few examples: 
			</P>
			<PRE><FONT COLOR="#cc0000">@array = qw# dino fred barney #;</FONT>
<FONT COLOR="#cc0000">$a = shift(@array);      # $a gets &quot;dino&quot;, @array now has (&quot;fred&quot;, &quot;barney&quot;)</FONT>
<FONT COLOR="#cc0000">$b = shift @array;       # $b gets &quot;fred&quot;, @array now has (&quot;barney&quot;)</FONT>
<FONT COLOR="#cc0000">shift @array;            # @array is now empty</FONT>
<FONT COLOR="#cc0000">$c = shift @array;       # $c gets undef, @array is still empty</FONT>
<FONT COLOR="#cc0000">unshift(@array, 5);      # @array now has the one-element list (5)</FONT>
<FONT COLOR="#cc0000">unshift @array, 4;       # @array now has (4, 5);</FONT>
<FONT COLOR="#cc0000">@others = 1..3;</FONT>
<FONT COLOR="#cc0000">unshift @array, @others; # @array now has (1, 2, 3, 4, 5)</FONT></PRE><P>
			<A NAME="IXTR3-16"></A><A NAME="IXTR3-17"></A><A NAME="IXTR3-18"></A>
			Analogous to <TT><FONT COLOR="#cc0000">pop</FONT></TT>, <TT><FONT COLOR="#cc0000">shift</FONT></TT>
			returns <TT><FONT COLOR="#cc0000">undef</FONT></TT> if given an
			empty array variable. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-5"></A>3.5 Interpolating Arrays
			into Strings</H3>
			<P><A NAME="IXT-3-336011"></A>Like scalars, array values may be
			interpolated into a double-quoted string. Elements of an array are
			automatically separated by spaces<A HREF="#">[13]</A> upon
			interpolation: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-3-336012"></A>
			<SUP>[13]</SUP> Actually, the separator is the value of the
			special <TT><FONT COLOR="#cc0000">$&quot;</FONT></TT>variable,
			which is a space by default.</P>
			<PRE><FONT COLOR="#cc0000">@rocks = qw{ flintstone slate rubble };</FONT>
<FONT COLOR="#cc0000">print &quot;quartz @rocks limestone\n&quot;;  # prints five rocks separated by spaces</FONT></PRE><P>
			There are no extra spaces added before or after an interpolated
			array; if you want those, you'll have to put them in yourself: 
			</P>
			<PRE><FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">print &quot;Three rocks are: @rocks.\n&quot;;</SPAN></FONT>
<FONT COLOR="#cc0000">print &quot;There's nothing in the parens (@empty) here.\n&quot;;</FONT></PRE><P>
			<A NAME="IXT-3-336013"></A>If you forget that arrays interpolate
			like this, <SPAN STYLE="background: #eb613d">you'll be surprised
			when you put an email address into a double-quoted string.</SPAN>
			For historical reasons,<A HREF="#">[14]</A> this is a fatal error
			at compile time: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP>
			Since you asked: Before version 5, Perl would silently leave
			uninterpolated an unused array's name in a double-quoted string.
			So, <TT><FONT COLOR="#cc0000">&quot;fred@bedrock.edu&quot;</FONT></TT>
			might be a string containing an email address. This attempt to Do
			What I Mean will backfire when someone adds a variable named
			<TT><FONT COLOR="#cc0000">@bedrock</FONT></TT>to the program&iuml;&frac34;—now
			the string becomes <TT><FONT COLOR="#cc0000">&quot;fred.edu&quot;</FONT></TT>
			or worse.</P>
			<PRE><FONT COLOR="#cc0000">$email = &quot;fred@bedrock.edu&quot;;  # WRONG! Tries to interpolate @bedrock</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">$email = &quot;fred\@bedrock.edu&quot;; # Correct</SPAN></FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">$email = 'fred@bedrock.edu';  # Another way to do that</SPAN></FONT></PRE><P>
			A single element of an array will be replaced by its value, just
			as you'd expect: 
			</P>
			<PRE><FONT COLOR="#cc0000">@fred = qw(hello dolly);</FONT>
<FONT COLOR="#cc0000">$y = 2;</FONT>
<FONT COLOR="#cc0000">$x = &quot;This is $fred[1]'s place&quot;;    # &quot;This is dolly's place&quot;</FONT>
<FONT COLOR="#cc0000">$x = &quot;This is $fred[$y-1]'s place&quot;; # same thing</FONT></PRE><P>
			Note that the index expression is evaluated as an ordinary
			expression, as if it were outside a string. It is not
			variable-interpolated first. In other words, if <TT><FONT COLOR="#cc0000">$y</FONT></TT>
			contains<SPAN STYLE="background: #5c8526"> the string </SPAN><TT><SPAN STYLE="background: #5c8526"><FONT COLOR="#cc0000">&quot;2*4&quot;</FONT></SPAN></TT><SPAN STYLE="background: #5c8526">,</SPAN>
			we're still talking about element 1, not element 7, because <TT><FONT COLOR="#cc0000">&quot;2*4&quot;</FONT></TT>
			as a number (the value of <TT><FONT COLOR="#cc0000">$y</FONT></TT>
			used in a numeric expression) is just plain 2 (like “2gets45”
			is only 2).<A HREF="#">[15]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP> Of
			course, if you've got warnings turned on, Perl is likely to remind
			you that <TT><FONT COLOR="#cc0000">&quot;2*4&quot;</FONT></TT>is a
			pretty funny-looking number.</P>
			<P><SPAN STYLE="background: #5c8526">If you want to follow a
			simple scalar variable with a left square bracket</SPAN>, you need
			to delimit the square bracket so that it isn't considered part of
			an array reference, as follows: 
			</P>
			<PRE><FONT COLOR="#cc0000">@fred = qw(eating rocks is wrong);</FONT>
<FONT COLOR="#cc0000">$fred = &quot;right&quot;;               # we are trying to say &quot;this is right[3]&quot;</FONT>
<FONT COLOR="#cc0000">print &quot;this is $fred[3]\n&quot;;    # prints &quot;wrong&quot; using $fred[3]</FONT>
<FONT COLOR="#cc0000">print &quot;this is ${fred}[3]\n&quot;;  # prints &quot;right&quot; (protected by braces)</FONT>
<FONT COLOR="#cc0000">print &quot;this is $fred&quot;.&quot;[3]\n&quot;; # right again (different string)</FONT>
<FONT COLOR="#cc0000">print &quot;this is $fred\[3]\n&quot;;   # right again (backslash hides it)</FONT></PRE>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-6"></A>3.6 The foreach Control
			Structure</H3>
			<P><A NAME="IXT-3-336014"></A>It's handy to be able to process an
			entire array or list, so Perl provides a control structure to do
			just that. The <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop
			steps through a list of values, executing one iteration (time
			through the loop) for each value: 
			</P>
			<PRE><FONT COLOR="#cc0000">foreach <SPAN STYLE="background: #eb613d">$rock </SPAN>(qw/ bedrock slate lava /) {</FONT>
<FONT COLOR="#cc0000">  print &quot;One rock is $rock.\n&quot;;  # Prints names of three rocks</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The control variable (<TT><FONT COLOR="#cc0000">$rock</FONT></TT>
			in that example) takes on a new value from the list for each
			iteration. The first time through the loop, it's <TT><FONT COLOR="#cc0000">&quot;bedrock&quot;</FONT></TT>;
			the third time, it's <TT><FONT COLOR="#cc0000">&quot;lava&quot;</FONT></TT>.
			
			</P>
			<P>The control variable is not a copy of the list element&iuml;&frac34;—it
			actually is the list element. That is, <SPAN STYLE="background: #eb613d">if
			you modify the control variable inside the loop, you'll be
			modifying the element itself,</SPAN> as shown in the following
			code snippet. This is useful, and supported, but it would surprise
			you if you weren't expecting it. 
			</P>
			<PRE><FONT COLOR="#cc0000">@rocks = qw/ bedrock slate lava /;</FONT>
<FONT COLOR="#cc0000">foreach $rock (@rocks) {</FONT>
<FONT COLOR="#cc0000">  <SPAN STYLE="background: #94bd5e">$rock</SPAN> = &quot;\t$rock&quot;;              # put a tab in front of each element of @rocks</FONT>
<FONT COLOR="#cc0000">  $rock .= &quot;\n&quot;;                  # put a newline on the end of each</FONT>
<FONT COLOR="#cc0000">}</FONT>
<FONT COLOR="#cc0000">print &quot;The rocks are:\n&quot;, @rocks; # Each one is indented, on its own line</FONT></PRE><P>
			What is the value of the control variable after the loop has
			finished? It's the <SPAN STYLE="background: #94bd5e">same as it
			was before the loop started.</SPAN> The value of the control
			variable of a <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop
			is automatically saved and restored by Perl. While the loop is
			running, there's no way to access or alter that saved value. So
			after the loop is done, the variable has the value it had before
			the loop, or <TT><FONT COLOR="#cc0000">undef</FONT></TT> if it
			hadn't had a value. That means that if you want to name your loop
			control variable &quot;<TT><FONT COLOR="#cc0000">$rock</FONT></TT>&quot;,
			<SPAN STYLE="background: #94bd5e">you don't have to worry that
			maybe you've already used that name for another variable</SPAN>.<A HREF="#">[16]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP>
			Unless the variable name has been declared as a lexical in the
			current scope, in which case you get a lexically local variable
			instead of a package local variable&iuml;&frac34;—more on this
			in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-4#lperl3-CHP-4">Chapter
			4</A>.</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-7"></A>3.7 Perl's Favorite Default:
			$_</H3>
			<P><A NAME="IXT-3-336015"></A><A NAME="IXT-3-336016"></A>If you
			omit the control variable from the beginning of the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, Perl uses its favorite default variable, <TT><FONT COLOR="#cc0000">$_</FONT></TT>.
			This is (mostly) just like any other scalar variable, except for
			its unusual name. For example: 
			</P>
			<PRE><FONT COLOR="#cc0000">foreach (1..10) {  # Uses $_ by default</FONT>
<FONT COLOR="#cc0000">  print &quot;I can count to $_!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Although this isn't Perl's only default by a long shot, it's
			Perl's most common default. We'll see many other cases in which
			Perl will automatically use <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			when you don't tell it to use some other variable or value,
			thereby saving the programmer from the heavy labor of having to
			think up and type a new variable name. So as not to keep you in
			suspense, one of those cases is <TT><FONT COLOR="#cc0000">print</FONT></TT>,
			which will print <TT><FONT COLOR="#cc0000">$_</FONT></TT> if given
			no other argument: 
			</P>
			<PRE><FONT COLOR="#cc0000">$_ = &quot;Yabba dabba doo\n&quot;;</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e"><FONT COLOR="#000000">print; </FONT></SPAN> # prints $_ by default</FONT></PRE><H4>
			<A NAME="lperl3-CHP-3-SECT-7.1"></A>3.7.1 The reverse Operator</H4>
			<P><A NAME="IXT-3-336017"></A>The <TT><FONT COLOR="#cc0000">reverse</FONT></TT>
			operator takes a list of values (which may come from an array) and
			returns the list in the opposite order. <SPAN STYLE="background: #94bd5e">So
			if you were disappointed that the range operator, </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">..</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			only counts upwards, this is the way to fix it: </SPAN>
			</P>
			<PRE><FONT COLOR="#cc0000">@fred = 6..10;</FONT>
<FONT COLOR="#cc0000">@barney = reverse(@fred); # gets 10, 9, 8, 7, 6</FONT>
<FONT COLOR="#cc0000">@wilma = reverse 6..10;   # gets the same thing, without the other array</FONT>
<FONT COLOR="#cc0000">@fred = reverse @fred;    # puts the result back into the original array</FONT></PRE><P>
			The last line is noteworthy because it uses <TT><FONT COLOR="#cc0000">@fred</FONT></TT>
			twice. Perl always calculates the value being assigned (on the
			right) before it begins the actual assignment. 
			</P>
			<P>Remember that<SPAN STYLE="background: #94bd5e"> </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">reverse</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			<SPAN STYLE="background: #eb613d">returns </SPAN>the reversed
			list; it doesn't affect its arguments</SPAN>. If the return value
			isn't assigned anywhere, it's useless: 
			</P>
			<PRE><FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">reverse @fred;         # WRONG </SPAN>- doesn't change @fred</FONT>
<FONT COLOR="#cc0000">@fred = reverse @fred; # that's better</FONT></PRE><H4>
			<A NAME="lperl3-CHP-3-SECT-7.2"></A>3.7.2 The sort Operator</H4>
			<P><A NAME="IXT-3-336018"></A><A NAME="IXT-3-336019"></A>The <TT><FONT COLOR="#cc0000">sort</FONT></TT>
			operator takes a list of values (which may come from an array) and
			sorts them in the internal character ordering. For ASCII strings,
			that would be ASCIIbetical order. Of course, ASCII is a strange
			place where all of the capital letters come before all of the
			lowercase letters, where the numbers come before the letters, and
			the punctuation marks&iuml;&frac34;—well, those are here, there,
			and everywhere. But sorting in ASCII order is just the default
			behavior; we'll see in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-15#lperl3-CHP-15">Chapter
			15</A>, Strings and Sorting, how to sort in whatever order you'd
			like: 
			</P>
			<PRE><FONT COLOR="#cc0000">@rocks = qw/ bedrock slate rubble granite /;</FONT>
<FONT COLOR="#cc0000">@sorted = sort(@rocks);      # gets bedrock, granite, rubble, slate</FONT>
<FONT COLOR="#cc0000">@back = reverse sort @rocks; # these go from slate to bedrock</FONT>
<FONT COLOR="#cc0000">@rocks = sort @rocks;        # puts sorted result back into @rocks</FONT>
<FONT COLOR="#cc0000">@numbers = sort 97..102;     # gets 100, 101, 102, 97, 98, 99</FONT></PRE><P>
			As you can see from that last example, sorting numbers as if they
			were strings may not give useful results. But, of course, any
			string that starts with <TT><FONT COLOR="#cc0000">1</FONT></TT>
			has to sort before any string that starts with <TT><FONT COLOR="#cc0000">9</FONT></TT>,
			according to the default sorting rules. And like what happened
			with <TT><FONT COLOR="#cc0000">reverse</FONT></TT>, the arguments
			themselves aren't affected. If you want to sort an array, you must
			store the result back into that array: 
			</P>
			<PRE><FONT COLOR="#cc0000">sort @rocks;          # WRONG, doesn't modify @rocks</FONT>
<FONT COLOR="#cc0000">@rocks = sort @rocks; # Now the rock collection is in order</FONT></PRE>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-8"></A>3.8 Scalar and List Context</H3>
			<P><A NAME="lperl3-IDXTERM-300"></A><A NAME="lperl3-IDXTERM-301"></A><A NAME="lperl3-IDXTERM-302"></A>
			This is the most important section in this chapter. In fact, it's
			the most important section in the entire book. In fact, it
			wouldn't be an exaggeration to say that <SPAN STYLE="background: #eb613d">your
			entire career in using Perl will depend upon understanding this
			section.</SPAN> So if you've gotten away with skimming the text up
			to this point, this is where you should really pay attention. 
			</P>
			<P>That's not to say that this section is in any way difficult to
			understand. It's actually a simple idea: a given expression may
			mean different things depending upon where it appears. This is
			nothing new to you; it happens all the time in natural languages.
			For example, in English,<A HREF="#">[17]</A> suppose someone asked
			you what the word &quot;read&quot;<A HREF="#">[18]</A> means. It
			has different meanings depending on how it's used. You can't
			identify the meaning, until you know the context. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP> If
			you aren't a native speaker of English, this analogy may not be
			obvious to you. But context sensitivity happens in every spoken
			language, so you may be able to think of an example in your own
			language.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP> Or
			maybe they were asking what the word &quot;red&quot; means, if
			they were speaking rather than writing a book. It's ambiguous
			either way. As Douglas Hofstadter said, no language can express
			every thought unambiguously, especially this one.</P>
			<P><A NAME="IXT-3-336020"></A><A NAME="IXT-3-336021"></A>The
			context refers to where an expression is found. As Perl is parsing
			your expressions, it always expects either a scalar value or a
			list value.<A HREF="#">[19]</A> What Perl expects is called the
			context of the expression.<A HREF="#">[20]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[19]</SUP>
			Unless, of course, Perl is expecting something else entirely.
			There are other contexts that aren't covered here. In fact, nobody
			knows how many contexts Perl uses; the biggest brains in all of
			Perl haven't agreed on an answer to that yet.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[20]</SUP>
			This is no different than what you're used to in human languages.
			If I make a grammatical mistake, you notice it right away, because
			you expect certain words in places certain. Eventually, you'll
			read Perl this way, too, but at first you have to think about it.</P>
			<PRE><FONT COLOR="#cc0000">5 + something  # The something must be a scalar</FONT>
<FONT COLOR="#cc0000">sort something # The something must be a list</FONT></PRE><P>
			Even if something is the exact same sequence of characters, in one
			case it may give a single, scalar value, while in the other, it
			may give a list.<A HREF="#">[21]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[21]</SUP> The
			list may be just one element long, of course. It could also be
			empty, or it could have any number of elements.</P>
			<P>Expressions in Perl always return the appropriate value for
			their context. For example, how about the &quot;name&quot;<A HREF="#">[22]</A>
			of an array. In a list context, it gives the list of elements. But
			in a scalar context, it <SPAN STYLE="background: #94bd5e">returns
			the number of elements in the array</SPAN>: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[22]</SUP>
			Well, the true name of the array <TT><FONT COLOR="#cc0000">@people</FONT></TT>is
			just <TT><FONT COLOR="#cc0000">people</FONT></TT>. The <TT><FONT COLOR="#cc0000">@</FONT></TT>-sign
			is just a qualifier.</P>
			<PRE><FONT COLOR="#cc0000">@people = qw( fred barney betty );</FONT>
<FONT COLOR="#cc0000">@sorted = sort @people; # list context: barney, betty, fred</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">$number = 5 + @people;  # scalar context: </SPAN>5 + <SPAN STYLE="background: #94bd5e">3</SPAN> gives 8</FONT></PRE><P>
			Even ordinary assignment (to a scalar or a list) causes different
			contexts: 
			</P>
			<PRE><FONT COLOR="#cc0000">@list = @people; # a list of three people</FONT>
<FONT COLOR="#cc0000">$n = @people;    # the number 3</FONT></PRE><P>
			But please don't jump to the conclusion that scalar context always
			gives the number of elements that would have been returned in list
			context. Most list-producing expressions<A HREF="#">[23]</A>
			return something much more interesting than that. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[23]</SUP> But
			with regard to the point of this section, there's no difference
			between a &quot;list-producing&quot; expression and a
			&quot;scalar-producing&quot; one; any expression can produce a
			list or a scalar, depending upon context. So when we say
			&quot;list-producing expressions,&quot; we <SPAN STYLE="background: #94bd5e">mean
			expressions that are typically used in a list context and that
			therefore might surprise you when they're used unexpectedly in a
			scalar context (like </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">reverse</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			or </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">@fred)</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">.</SPAN></P>
			<H4><A NAME="lperl3-CHP-3-SECT-8.1"></A>3.8.1 Using List-Producing
			Expressions in Scalar Context</H4>
			<P>There are many expressions that would typically be used to
			produce a list. If you use one in a scalar context, what do you
			get? See what the author of that operation says about it. Usually,
			that person is Larry, and usually the documentation gives the
			whole story. In fact, a big part of learning Perl is actually
			learning how Larry thinks.<A HREF="#">[24]</A> Therefore, once you
			can think like Larry does, you know what Perl should do. But while
			you're learning, you'll probably need to look into the
			documentation. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[24]</SUP>
			This is only fair, since while writing Perl he tried to think like
			you do to predict what you would want!</P>
			<P>Some expressions don't have a scalar-context value at all. For
			example, what should <TT><FONT COLOR="#cc0000">sort</FONT></TT>
			return in a scalar context? You wouldn't need to sort a list to
			count its elements, so until someone implements something else,
			<TT><FONT COLOR="#cc0000">sort</FONT></TT> in a scalar context
			always returns <TT><FONT COLOR="#cc0000">undef</FONT></TT>. 
			</P>
			<P>Another example is <TT><FONT COLOR="#cc0000">reverse</FONT></TT>.
			In a list context, it gives a reversed list. In a scalar context,
			it returns a reversed string (or reversing the result of
			concatenating all the strings of a list, if given one): 
			</P>
			<PRE><FONT COLOR="#cc0000">@backwards = reverse qw/ yabba dabba doo /;</FONT>
<FONT COLOR="#cc0000">   # gives doo, dabba, yabba</FONT>
<FONT COLOR="#cc0000">$backwards = reverse qw/ yabba dabba doo /;</FONT>
<FONT COLOR="#cc0000">   # gives oodabbadabbay</FONT></PRE><P>
			At first, it's not always obvious whether an expression is being
			used in a scalar or a list context. But, trust us, it will get to
			be second nature for you eventually. 
			</P>
			<P>Here are some common contexts to start you off:</P>
			<PRE><FONT COLOR="#cc0000">$fred = something;            # scalar context</FONT>
<FONT COLOR="#cc0000">@pebbles = something;         # list context</FONT>
<FONT COLOR="#cc0000">($wilma, $betty) = something; # list context</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #eb613d">($dino) = something;          # still list context!</SPAN></FONT></PRE><P>
			Don't be fooled by the one-element list; that last one is a list
			context, not a scalar one. If you're assigning to a list (no
			matter the number of elements), it's a list context. If you're
			assigning to an array, it's a list context. 
			</P>
			<P>Here are some other expressions we've seen, and the contexts
			they provide. First, some that provide scalar context to
			something: 
			</P>
			<PRE><FONT COLOR="#cc0000">$fred = something;</FONT>
<FONT COLOR="#cc0000">$fred[3] = something;</FONT>
<FONT COLOR="#cc0000">123 + something</FONT>
<FONT COLOR="#cc0000">something + 654</FONT>
<FONT COLOR="#cc0000">if (something) { ... }</FONT>
<FONT COLOR="#cc0000">while (something) { ... }</FONT>
<FONT COLOR="#cc0000">$fred[something] = something;</FONT></PRE><P>
			And here are some that provide a list context:</P>
			<PRE><FONT COLOR="#cc0000">@fred = something;</FONT>
<FONT COLOR="#cc0000">($fred, $barney) = something;</FONT>
<FONT COLOR="#cc0000">($fred) = something;</FONT>
<FONT COLOR="#cc0000">push @fred, something;</FONT>
<FONT COLOR="#cc0000">foreach $fred (something) { ... }</FONT>
<FONT COLOR="#cc0000">sort something</FONT>
<FONT COLOR="#cc0000">reverse something</FONT>
<FONT COLOR="#cc0000">print something</FONT></PRE><H4>
			<A NAME="lperl3-CHP-3-SECT-8.2"></A>3.8.2 Using Scalar-Producing
			Expressions in List Context</H4>
			<P>Going this direction is straightforward: if an expression
			doesn't normally have a list value, the scalar value is
			automatically promoted to make a one-element list: 
			</P>
			<PRE><FONT COLOR="#cc0000">@fred = 6 * 7; # gets the one-element list (42)</FONT>
<FONT COLOR="#cc0000">@barney = &quot;hello&quot; . ' ' . &quot;world&quot;;</FONT></PRE><P>
			Well, there's one possible catch:</P>
			<PRE><FONT COLOR="#cc0000">@wilma = undef; # OOPS! Gets the one-element list (undef)</FONT>
<FONT COLOR="#cc0000">  # which is not the same as this:</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">@betty = ( );    # A correct way to empty an array</SPAN></FONT></PRE><P>
			<A NAME="IXTR3-19"></A>Since <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			is a scalar value, assigning <TT><FONT COLOR="#cc0000">undef</FONT></TT>
			to an array doesn't clear the array. The better way to do that is
			to assign an empty list.<A HREF="#">[25]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[25]</SUP>
			Well, in most real-world algorithms, if the variable is declared
			in the proper scope, it will never need to be explicitly emptied.
			So this type of assignment is rare in well-written Perl programs.
			We'll learn about scoping in the next chapter.</P>
			<H4><A NAME="lperl3-CHP-3-SECT-8.3"></A>3.8.3 Forcing Scalar
			Context</H4>
			<P><A NAME="IXT-3-336022"></A>On occasion, you may need to <SPAN STYLE="background: #94bd5e">force
			scalar context where Perl is expecting a list.</SPAN> In that
			case, you can use the fake function <TT><FONT COLOR="#cc0000">scalar</FONT></TT>.
			It's not a true function, because it just tells Perl to provide a
			scalar context: 
			</P>
			<PRE><FONT COLOR="#cc0000">@rocks = qw( talc quartz jade obsidian );</FONT>
<FONT COLOR="#cc0000">print &quot;How many rocks do you have?\n&quot;;</FONT>
<FONT COLOR="#cc0000">print &quot;I have &quot;, @rocks, &quot; rocks!\n&quot;;        # WRONG, prints names of rocks</FONT>
<FONT COLOR="#cc0000">print &quot;I have &quot;, <SPAN STYLE="background: #94bd5e">scalar @rocks, </SPAN>&quot; rocks!\n&quot;; # Correct, gives a number</FONT></PRE><P>
			<A NAME="IXTR3-20"></A><A NAME="IXTR3-21"></A>Oddly enough,
			there's no corresponding function to force list context. It turns
			out never to be needed. Trust us on this, too. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-9"></A>3.9 &lt;STDIN&gt; in List
			Context</H3>
			<P><A NAME="IXT-3-336023"></A>One previously seen operator that
			returns a different value in an array context is the line-input
			operator, <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>. As
			described earlier, <TT><FONT COLOR="#cc0000">&lt;STDIN&gt;</FONT></TT>
			returns the next line of input in a scalar context. Now, in list
			context, this operator returns all of the remaining lines up to
			the end of file. Each line is returned as a separate element of
			the list. For example: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">@lines = &lt;STDIN&gt;; # read standard input in list context</FONT></PRE><P>
			<A NAME="IXT-3-336024"></A>When the input is coming from a file,
			this will read the rest of the file. But how can there be an
			end-of-file when the input comes from the keyboard? On Unix and
			similar systems, including Linux and Mac OS X, you'll normally
			type a Control-D<A HREF="#">[26]</A> to indicate to the system
			that there's no more input; the special character itself is never
			seen by Perl,<A HREF="#">[27]</A> even though it may be echoed to
			the screen. On DOS/Windows systems, use Ctrl-Z instead.<A HREF="#">[28]</A>
			You'll need to check the documentation for your system or ask your
			local expert, if it's different from these. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[26]</SUP>
			This is merely the default; it can be changed by the <TT><FONT COLOR="#cc0000">stty</FONT></TT>command.
			But it's pretty dependable&iuml;&frac34;—we've never seen a Unix
			system where a different character was used to mean end-of-file
			from the keyboard. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[27]</SUP>
			It's the OS that &quot;sees&quot; the control key and reports &quot;end
			of file&quot; to the application.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[28]</SUP>
			There's a bug affecting some ports of Perl for DOS/Windows where
			the first line of output to the terminal following the use of
			Control-Z is obscured. On these systems, you can work around this
			problem by simply printing a blank line (<TT><FONT COLOR="#cc0000">&quot;\n&quot;)</FONT></TT>after
			reading the input.</P>
			<P>If the person running the program types three lines, then
			presses the proper keys needed to indicate end-of-file, the array
			ends up with three elements. Each element will be a string that
			ends in a newline, corresponding to the three newline-terminated
			lines entered. 
			</P>
			<P>Wouldn't it be nice if, having read those lines, you could
			<TT><FONT COLOR="#cc0000">chomp</FONT></TT> the newlines all at
			once? It turns out that if you give <TT><FONT COLOR="#cc0000">chomp</FONT></TT>
			a list of lines, it will remove the newlines from each item in the
			list. For example: 
			</P>
			<PRE><FONT COLOR="#cc0000">@lines = &lt;STDIN&gt;; # Read all the lines</FONT>
<FONT COLOR="#cc0000">chomp(@lines);    # discard all the newline characters</FONT></PRE><P>
			But the more common way to write that is with code similar to what
			we used earlier: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">chomp(@lines = &lt;STDIN&gt;); # Read the lines, not the newlines</FONT></PRE><P>
			Although you're welcome to write your code either way in the
			privacy of your own cubicle, most Perl programmers will expect the
			second, more compact, notation. 
			</P>
			<P>It may be obvious to you (but it's not obvious to everyone)
			that once these lines of input have been read, they can't be
			re-read.<A HREF="#">[29]</A> Once you've reached end-of-file,
			there's no more input out there to read. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[29]</SUP>
			Well, yes, if the input is from a source upon which you can <TT><FONT COLOR="#cc0000">seek</FONT></TT>,
			then you'll be able to go back and read again. But that's not what
			we're talking about here.</P>
			<P>And what happens if the input is coming from a 400MB log file?
			The line input operator reads all of the lines, gobbling up lots
			of memory.<A HREF="#">[30]</A> Perl tries not to limit you in what
			you can do, but the other users of your system (not to mention
			your system administrator) are likely to object. If the input data
			is large, you should generally find a way to deal with it without
			reading it all into memory at once. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[30]</SUP>
			Typically, that's much more memory than the size of the file, too.
			That is, a 400MB file will typically take up at least a full
			gigabyte of memory when read into an array. This is because Perl
			will generally waste memory to save time. This is a good tradeoff;
			if you're short of memory, you can buy more; if you're short on
			time, you're hosed.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic16" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-3-SECT-10"></A>3.10 Exercises</H3>
			<P>See <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-APP-A-SECT-2#lperl3-APP-A-SECT-2">Section
			A.2</A> for answers to the following exercises: 
			</P>
			<OL>
				<LI><P STYLE="font-weight: medium">[6] Write a program that reads
				a list of strings on separate lines until end-of-input and prints
				out the list in reverse order. If the input comes from the
				keyboard, you'll probably need to signal the end of the input by
				pressing Control-D on Unix, or Control-Z on Windows. 
				</P>
				<LI><P>[12] Write a program that reads a list of numbers (on
				separate lines) until end-of-input and then prints for each
				number the corresponding person's name from the list shown below.
				(Hardcode this list of names into your program. That is, it
				should appear in your program's source code.) For example, if the
				input numbers were <TT><FONT COLOR="#cc0000">1</FONT></TT>, <TT><FONT COLOR="#cc0000">2</FONT></TT>,
				<TT><FONT COLOR="#cc0000">4</FONT></TT>, and <TT><FONT COLOR="#cc0000">2</FONT></TT>,
				the output names would be <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
				<TT><FONT COLOR="#cc0000">betty</FONT></TT>, <TT><FONT COLOR="#cc0000">dino</FONT></TT>,
				and <TT><FONT COLOR="#cc0000">betty</FONT></TT>. 
				</P>
				<PRE STYLE="margin-bottom: 0.5cm; font-weight: medium"><FONT COLOR="#cc0000">fred betty barney dino wilma pebbles bamm-bamm</FONT></PRE>
				<LI><P><A NAME="IXTR3-22"></A><A NAME="IXTR3-23"></A>[8] Write a
				program that reads a list of strings (on separate lines) until
				end-of-input. Then it should print the strings in ASCIIbetical
				order. That is, if you enter the strings <TT><FONT COLOR="#cc0000">fred</FONT></TT>,
				<TT><FONT COLOR="#cc0000">barney</FONT></TT>, <TT><FONT COLOR="#cc0000">wilma</FONT></TT>,
				<TT><FONT COLOR="#cc0000">betty</FONT></TT>, the output should
				show <TT><FONT COLOR="#cc0000">barney betty fred wilma</FONT></TT>.
				Are all of the strings on one line in the output, or on separate
				lines? Could you make the output appear in either style? 
				</P>
			</OL>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-1"></A>4.1 System and User
			Functions</H3>
			<P><A NAME="lperl3-IDXTERM-313"></A><A NAME="IXT-4-336025"></A><A NAME="IXT-4-336026"></A>
			We've already seen and used some of the builtin system functions,
			such as <TT><FONT COLOR="#cc0000">chomp</FONT></TT>, <TT><FONT COLOR="#cc0000">reverse</FONT></TT>,
			<TT><FONT COLOR="#cc0000">print</FONT></TT>, and so on. But, as
			other languages do, Perl has the ability to make <I>subroutines</I>,
			which are user-defined functions.<A HREF="#">[1]</A> These let us
			recycle one chunk of code many times in one program.<A HREF="#">[2]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[1]</SUP> In
			Perl, we don't generally make the distinction that Pascal
			programmers are used to, between functions, which return a value,
			and procedures, which don't. But a subroutine is always
			user-defined, while a function may or may not be. That is, the
			word function may be used as a synonym for subroutine, or it may
			mean one of Perl's builtin functions. That's why this chapter is
			titled Subroutines, because it's about the ones you can define,
			not the builtins. Mostly.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[2]</SUP> The
			code examples used in this book are recycled from at least 40%
			post-consumer programming, and are at least 75% recyclable into
			your programs when properly decomposed. 
			</P>
			<P>The <SPAN STYLE="background: #94bd5e">name of a subroutine is
			another Perl identifier </SPAN>(letters, digits, and underscores,
			but can't start with a digit) with a sometimes-optional <SPAN STYLE="background: #94bd5e">ampersand
			(</SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">&amp;</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">)
			in front.</SPAN> There's a rule about when you can omit the
			ampersand and when you cannot; we'll see that rule by the end of
			the chapter. For now, we'll just use it every time that it's not
			forbidden, which is always a safe rule. And we'll tell you every
			place where it's forbidden, of course. 
			</P>
			<P>That subroutine name comes from a separate namespace, so Perl
			won't be confused if you have a subroutine called <TT><FONT COLOR="#cc0000">&amp;fred</FONT></TT>
			and a scalar called <TT><FONT COLOR="#cc0000">$fred</FONT></TT> in
			the same program&iuml;&frac34;—although there's no reason to do
			that under normal circumstances. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-2"></A>4.2 Defining a Subroutine</H3>
			<P><A NAME="IXT-4-336027"></A><A NAME="IXT-4-336028"></A><A NAME="IXT-4-336029"></A>
			<SPAN STYLE="background: #94bd5e">To define your own subroutine,
			use the keyword </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">sub</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			the name of the subroutine (without the ampersand</SPAN>), then
			the indented<A HREF="#">[3]</A> block of code (in curly braces)
			which makes up the <I>body</I> of the subroutine, something like
			this: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[3]</SUP>
			Okay, purists, we admit it: the curly braces are part of the
			block, properly speaking. And Perl doesn't require the indentation
			of the block&iuml;&frac34;—but your maintenance programmer will.
			So please be stylish.</P>
			<PRE><FONT COLOR="#cc0000">sub marine {</FONT>
<FONT COLOR="#cc0000">  $n += 1;  # Global variable $n</FONT>
<FONT COLOR="#cc0000">  print &quot;Hello, sailor number $n!\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Subroutine definitions can be anywhere in your program text, but
			programmers who come from a background of languages like C or
			Pascal like to put them at the start of the file. Others may
			prefer to put them at the end of the file, so that the main part
			of the program appears at the beginning. It's up to you. In any
			case, you don't normally need any kind of forward declaration.<A HREF="#">[4]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[4]</SUP>
			Unless your subroutine is being particularly tricky and declares a
			&quot;prototype,&quot; which dictates how a compiler will parse
			and interpret its invocation arguments. This is rare&iuml;&frac34;—see
			the perlsubmanpage for more information.</P>
			<P>Subroutine definitions are global; without some powerful
			trickiness, there are no private subroutines.<A HREF="#">[5]</A>
			If you have two subroutine definitions with the same name, the
			later one overwrites the earlier one.<A HREF="#">[6]</A> That's
			generally considered bad form, or the sign of a confused
			maintenance programmer. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[5]</SUP> If
			you wish to be powerfully tricky, read the Perl documentation
			about coderefs stored in private (lexical) variables. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[6]</SUP> A
			warnable offense, however.</P>
			<P>As you may have noticed in the previous example, you may use
			any global variables within the subroutine body. In fact, a<SPAN STYLE="background: #94bd5e">ll
			of the variables we've seen so far are globals</SPAN>; that is,
			they are accessible from every part of your program. This
			horrifies linguistic purists, but the Perl development team formed
			an angry mob with torches and ran them out of town years ago.
			We'll see how to make private variables in the section &quot;Private
			Variables in Subroutines&quot; later in this chapter. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-3"></A>4.3 Invoking a Subroutine</H3>
			<P><A NAME="IXT-4-336030"></A><A NAME="IXT-4-336031"></A><A NAME="IXT-4-336032"></A>
			Invoke a subroutine from within any expression by using the
			subroutine name (with the ampersand):<A HREF="#">[7]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[7]</SUP> And
			frequently a pair of parentheses, even if empty. As written, the
			subroutine inherits the caller's <TT><FONT COLOR="#cc0000">@_</FONT></TT>
			value, which we'll be discussing shortly. So don't stop reading
			here, or you'll be writing code with unintended effects!</P>
			<PRE><FONT COLOR="#cc0000">&amp;marine;  # says Hello, sailor number 1!</FONT>
<FONT COLOR="#cc0000">&amp;marine;  # says Hello, sailor number 2!</FONT>
<FONT COLOR="#cc0000">&amp;marine;  # says Hello, sailor number 3!</FONT>
<FONT COLOR="#cc0000">&amp;marine;  # says Hello, sailor number 4!</FONT></PRE><P>
			<A NAME="IXT-4-336033"></A><A NAME="IXT-4-336034"></A>Sometimes,
			we refer to the invocation as calling the subroutine. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic17" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-4"></A>4.4 Return Values</H3>
			<P><A NAME="lperl3-IDXTERM-324"></A>The subroutine is always
			invoked as part of an expression, even if the result of the
			expression isn't being used. When we invoked <TT><FONT COLOR="#cc0000">&amp;marine</FONT></TT>
			earlier, we were calculating the value of the expression
			containing the invocation, but then throwing away the result. 
			</P>
			<P>Many times, we'll call a subroutine and actually do something
			with the result. This means that we'll be paying attention to the
			return value of the subroutine. <SPAN STYLE="background: #94bd5e">All
			Perl subroutines have a return value&iuml;&frac34;—there's no
			distinction between those that return values and those that don't.
			Not all Perl subroutines have a useful return value,</SPAN>
			however. 
			</P>
			<P>Since all Perl subroutines can be called in a way that needs a
			return value, it'd be a bit wasteful to have to declare special
			syntax to &quot;return&quot; a particular value for the majority
			of the cases. So Larry made it simple. Every subroutine is
			chugging along, calculating values as part of its series of
			actions. <SPAN STYLE="background: #94bd5e">Whatever calculation is
			last performed in a subroutine is automatically also the return
			value. </SPAN>
			</P>
			<P>For example, let's define this subroutine:</P>
			<PRE><FONT COLOR="#cc0000">sub sum_of_fred_and_barney {</FONT>
<FONT COLOR="#cc0000">  print &quot;Hey, you called the sum_of_fred_and_barney subroutine!\n&quot;;</FONT>
<FONT COLOR="#cc0000">  $fred + $barney;  # That's the return value</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The last expression evaluated in the body of this subroutine is
			the sum of <TT><FONT COLOR="#cc0000">$fred</FONT></TT> and
			<TT><FONT COLOR="#cc0000">$barney</FONT></TT>, so the sum of <TT><FONT COLOR="#cc0000">$fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">$barney</FONT></TT> will be the
			return value. Here's that in action: 
			</P>
			<PRE><FONT COLOR="#cc0000">$fred = 3;</FONT>
<FONT COLOR="#cc0000">$barney = 4;</FONT>
<FONT COLOR="#cc0000">$c = &amp;sum_of_fred_and_barney; # $c gets 7</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #7da647">print &quot;\$c is $c.\n&quot;;</SPAN></FONT>
<FONT COLOR="#cc0000">$d = 3 * &amp;sum_of_fred_and_barney; # $d gets 21</FONT>
<FONT COLOR="#cc0000">print &quot;\$d is $d.\n&quot;;</FONT></PRE><P>
			That code will produce this output:</P>
			<PRE><FONT COLOR="#cc0000">Hey, you called the sum_of_fred_and_barney subroutine!</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #7da647">$c is 7.</SPAN></FONT>
<FONT COLOR="#cc0000">Hey, you called the sum_of_fred_and_barney subroutine!</FONT>
<FONT COLOR="#cc0000">$d is 21.</FONT></PRE><P>
			That <TT><FONT COLOR="#cc0000">print</FONT></TT> statement is just
			a debugging aid, so that we can see that we called the subroutine.
			You'd take it out when the program is finished. But suppose you
			added another line to the end of the code, like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">sub sum_of_fred_and_barney {</FONT>
<FONT COLOR="#cc0000">  print &quot;Hey, you called the sum_of_fred_and_barney subroutine!\n&quot;;</FONT>
<FONT COLOR="#cc0000">  $fred + $barney;  # That's not really the return value!</FONT>
<FONT COLOR="#cc0000">  print &quot;Hey, I'm returning a value now!\n&quot;; # Oops!</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			In this example, the last expression evaluated is not the
			addition; it's the <TT><FONT COLOR="#cc0000">print</FONT></TT>
			statement. Its return value will normally be <TT><FONT COLOR="#cc0000">1</FONT></TT>,
			meaning &quot;printing was successful,&quot;<A HREF="#">[8]</A>
			but that's not the return value we actually wanted. <SPAN STYLE="background: #ff6633">So
			be careful when adding additional code to a subroutine to ensure
			that the last expression evaluated will be the desired return
			value. </SPAN>
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[8]</SUP> The
			return value of <TT><FONT COLOR="#cc0000">print </FONT></TT>is
			true for a successful operation and false for a failure. We'll see
			how to determine the kind of failure later in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-11#lperl3-CHP-11">Chapter
			11</A>. 
			</P>
			<P><A NAME="IXT-4-336035"></A><A NAME="IXT-4-336036"></A>So, what
			happened to the sum of <TT><FONT COLOR="#cc0000">$fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">$barney</FONT></TT> in that
			subroutine? <SPAN STYLE="background: #ff6633">We didn't put it
			anywhere, so Perl discarded it.</SPAN> If you had requested
			warnings, Perl (noticing that there's nothing useful about adding
			two variables and discarding the result) would likely warn you
			about something like &quot;a useless use of addition in a void
			context.&quot; The term<SPAN STYLE="background: #94bd5e"> <I>void
			context</I> </SPAN>is just a fancy of saying that the <SPAN STYLE="background: #94bd5e">answer
			isn't being stored in a variable or used by another function.</SPAN>
			
			</P>
			<P>&quot;The last expression evaluated&quot; really means the last
			expression evaluated, rather than the last line of text. For
			example, this subroutine returns the larger value of <TT><FONT COLOR="#cc0000">$fred</FONT></TT>
			or <TT><FONT COLOR="#cc0000">$barney</FONT></TT>: 
			</P>
			<PRE><FONT COLOR="#cc0000">sub larger_of_fred_or_barney {</FONT>
<FONT COLOR="#cc0000">  if ($fred &gt; $barney) {</FONT>
<FONT COLOR="#cc0000">    $fred;</FONT>
<FONT COLOR="#cc0000">  } else {</FONT>
<FONT COLOR="#cc0000">    $barney;</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			The last expression evaluated is the single <TT><FONT COLOR="#cc0000">$fred</FONT></TT>
			or <TT><FONT COLOR="#cc0000">$barney</FONT></TT>, which becomes
			the return value. We won't know whether the return value will be
			<TT><FONT COLOR="#cc0000">$fred</FONT></TT> or <TT><FONT COLOR="#cc0000">$barney</FONT></TT>
			until we see what those variables hold at runtime. 
			</P>
			<P><A NAME="IXT-4-336037"></A>A subroutine can also return a list
			of values when evaluated in a list context.<A HREF="#">[9]</A>
			Suppose you wanted to get a range of numbers (as from the range
			operator, <TT><FONT COLOR="#cc0000">..</FONT></TT>), except that
			you want to be able to count down as well as up. The range
			operator only counts upwards, but that's easily fixed: 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><A NAME="IXT-4-336038"></A>
			<SUP>[9]</SUP> You can detect whether a subroutine is being
			evaluated in a scalar or list context using the <TT><FONT COLOR="#cc0000">wantarray</FONT></TT>
			function, which lets you easily write subroutines with specific
			list or scalar context values.</P>
			<PRE><FONT COLOR="#cc0000">sub list_from_fred_to_barney {</FONT>
<FONT COLOR="#cc0000">  if ($fred &lt; $barney) {</FONT>
<FONT COLOR="#cc0000">    # Count upwards from $fred to $barney</FONT>
<FONT COLOR="#cc0000">    $fred..$barney;</FONT>
<FONT COLOR="#cc0000">  } else {</FONT>
<FONT COLOR="#cc0000">    # Count downwards from $fred to $barney</FONT>
<FONT COLOR="#cc0000">    reverse $barney..$fred;</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT>
<FONT COLOR="#cc0000">$fred = 11;</FONT>
<FONT COLOR="#cc0000">$barney = 6;</FONT>
<FONT COLOR="#cc0000">@c = &amp;list_from_fred_to_barney; # @c gets (11, 10, 9, 8, 7, 6)</FONT></PRE><P>
			In this case, the range operator gives us the list from <TT><FONT COLOR="#cc0000">6</FONT></TT>
			to <TT><FONT COLOR="#cc0000">11</FONT></TT>, then <TT><FONT COLOR="#cc0000">reverse</FONT></TT>
			reverses the list, so that it goes from <TT><FONT COLOR="#cc0000">$fred</FONT></TT>
			(<TT><FONT COLOR="#cc0000">11</FONT></TT>) to <TT><FONT COLOR="#cc0000">$barney</FONT></TT>
			(<TT><FONT COLOR="#cc0000">6</FONT></TT>), just as we wanted. 
			</P>
			<P><A NAME="IXTR3-24"></A>These are all rather trivial examples.
			It gets better when we can pass values that are different for each
			invocation into a subroutine instead of relying on global
			variables. In fact, that's coming right up. 
			</P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-5"></A>4.5 Arguments</H3>
			<P><A NAME="lperl3-IDXTERM-330"></A>That subroutine called
			<TT><FONT COLOR="#cc0000">larger_of_fred_or_barney</FONT></TT>
			would be much more useful if it didn't force us to use the global
			variables <TT><FONT COLOR="#cc0000">$fred</FONT></TT> and <TT><FONT COLOR="#cc0000">$barney</FONT></TT>.
			That's because, if we wanted to get the larger value from <TT><FONT COLOR="#cc0000">$wilma</FONT></TT>
			and <TT><FONT COLOR="#cc0000">$betty</FONT></TT>, we currently
			have to copy those into <TT><FONT COLOR="#cc0000">$fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">$barney</FONT></TT> before we can
			use <TT><FONT COLOR="#cc0000">larger_of_fred_or_barney</FONT></TT>.
			And if we had something useful in those variables, we'd have to
			first copy those to other variables, say <TT><FONT COLOR="#cc0000">$save_fred</FONT></TT>
			and <TT><FONT COLOR="#cc0000">$save_barney</FONT></TT>. And then,
			when we're done with the subroutine, we'd have to copy those back
			to <TT><FONT COLOR="#cc0000">$fred</FONT></TT> and <TT><FONT COLOR="#cc0000">$barney</FONT></TT>
			again. 
			</P>
			<P>Luckily, Perl has subroutine arguments. <SPAN STYLE="background: #94bd5e">To
			pass an argument list to the subroutine, simply place the list
			expression, in parentheses, after the subroutine invocation</SPAN>,
			like this: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$n = &amp;max<SPAN STYLE="background: #94bd5e">(10, 15)</SPAN>;  # This sub call has two parameters</FONT></PRE><P>
			<A NAME="lperl3-IDXTERM-331"></A><A NAME="IXT-4-336039"></A><A NAME="IXT-4-336040"></A>
			That list is <I>passed</I> to the subroutine; that is, it's made
			available for the subroutine to use however it needs to. Of
			course, this list has to be stored into a variable, so the
			<SPAN STYLE="background: #94bd5e">parameter list </SPAN>(another
			name for the argument list) <SPAN STYLE="background: #94bd5e">is
			automatically assigned to a special array variable named </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">@_</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			for the duration of the subroutine.</SPAN> The subroutine can
			access this variable to determine both the number of arguments and
			the value of those arguments. 
			</P>
			<P>So, that means that the first subroutine parameter is stored in
			<TT><FONT COLOR="#cc0000">$_[0]</FONT></TT>, the second one is
			stored in <TT><FONT COLOR="#cc0000">$_[1]</FONT></TT>, and so on.
			But&iuml;&frac34;—and here's an important note&iuml;&frac34;—<SPAN STYLE="background: #eb613d">these
			variables have nothing whatsoever to do with the </SPAN><TT><SPAN STYLE="background: #eb613d"><FONT COLOR="#cc0000">$_</FONT></SPAN></TT><SPAN STYLE="background: #eb613d">
			variable, any more than </SPAN><TT><SPAN STYLE="background: #eb613d"><FONT COLOR="#cc0000">$dino[3]</FONT></SPAN></TT><SPAN STYLE="background: #eb613d">
			</SPAN>(an element of the <TT><FONT COLOR="#cc0000">@dino</FONT></TT>
			array)<SPAN STYLE="background: #eb613d"> has to do with </SPAN><TT><SPAN STYLE="background: #eb613d"><FONT COLOR="#cc0000">$dino</FONT></SPAN></TT>
			(a completely distinct scalar variable). It's just that the
			parameter list must be stored into some array variable for the
			subroutine to use it, and Perl uses the array <TT><FONT COLOR="#cc0000">@_</FONT></TT>
			for this purpose. 
			</P>
			<P>Now, you could write the subroutine <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			to look a little like the subroutine <TT><FONT COLOR="#cc0000">&amp;larger_of_fred_or_barney</FONT></TT>,
			but instead of using <TT><FONT COLOR="#cc0000">$a</FONT></TT> you
			could use the first subroutine parameter (<TT><FONT COLOR="#cc0000">$_[0]</FONT></TT>),
			and instead of using <TT><FONT COLOR="#cc0000">$b</FONT></TT>, you
			could use the second subroutine parameter (<TT><FONT COLOR="#cc0000">$_[1]</FONT></TT>).
			And so you could end up with code something like this: 
			</P>
			<PRE><FONT COLOR="#cc0000">sub max {</FONT>
<FONT COLOR="#cc0000">  # Compare this to &amp;larger_of_fred_or_barney</FONT>
<FONT COLOR="#cc0000">  if ($_[0] &gt; $_[1]) { </FONT>
<FONT COLOR="#cc0000">    $_[0];</FONT>
<FONT COLOR="#cc0000">  } else {</FONT>
<FONT COLOR="#cc0000">    $_[1];</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			Well, as we said, you could do that. But it's pretty ugly with all
			of those subscripts, and hard to read, write, check, and debug,
			too. We'll see a better way in a moment. 
			</P>
			<P><A NAME="IXT-4-336041"></A>There's another problem with this
			subroutine. The name <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			is nice and short, but it doesn't remind us that this subroutine
			works properly only if called with exactly two parameters: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$n = &amp;max(10, 15, 27);  # Oops!</FONT></PRE><P>
			<SPAN STYLE="background: #94bd5e">Excess parameters are
			ignored</SPAN>&iuml;&frac34;—since the subroutine never looks at
			<TT><FONT COLOR="#cc0000">$_[2]</FONT></TT>, Perl doesn't care
			whether there's something in there or not. And <SPAN STYLE="background: #94bd5e">insufficient
			parameters are also ignored</SPAN>&iuml;&frac34;—you simply get
			<TT><FONT COLOR="#cc0000">undef</FONT></TT> if you look beyond the
			end of the <TT><FONT COLOR="#cc0000">@_</FONT></TT> array, as with
			any other array. We'll see how to make a better <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>,
			which works with any number of parameters, later in this chapter. 
			</P>
			<P><A NAME="IXTR3-25"></A><A NAME="IXTR3-26"></A>The <TT><FONT COLOR="#cc0000">@_</FONT></TT>
			variable is local to the subroutine;<A HREF="#">[10]</A> if
			there's a global value in <TT><FONT COLOR="#cc0000">@_</FONT></TT>,
			it is saved away before the subroutine is invoked and restored to
			its previous value upon return from the subroutine.<A HREF="#">[11]</A>
			This also means that a subroutine can pass arguments to another
			subroutine without fear of losing its own <TT><FONT COLOR="#cc0000">@_</FONT></TT>
			variable&iuml;&frac34;—the nested subroutine invocation gets its
			own <TT><FONT COLOR="#cc0000">@_</FONT></TT> in the same way. <SPAN STYLE="background: #94bd5e">Even
			if the subroutine calls itself recursively, each invocation gets a
			new </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">@_</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">,
			</SPAN>so <TT><FONT COLOR="#cc0000">@_</FONT></TT> is always the
			parameter list for the current subroutine invocation. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[10]</SUP>
			Unless there's an ampersand in front of the name for the
			invocation, and no parentheses (or arguments) afterward, in which
			case the <TT><FONT COLOR="#cc0000">@_</FONT></TT> array is
			inherited from the caller's context. That's generally a bad idea,
			but is occasionally useful.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[11]</SUP> You
			might recognize that this is the same mechanism as used with the
			control variable of the <TT><FONT COLOR="#cc0000">foreach</FONT></TT>
			loop, as seen in the previous chapter. In either case, the
			variable's value is saved and automatically restored by Perl.
			We'll see this again with the <TT><FONT COLOR="#cc0000">local</FONT></TT>
			operator later in this chapter.</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic18" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-6"></A>4.6 Private Variables in
			Subroutines</H3>
			<P>But if Perl can give us a new <TT><FONT COLOR="#cc0000">@_</FONT></TT>
			for every invocation, can't it give us variables for our own use
			as well? Of course it can. 
			</P>
			<P><A NAME="IXT-4-336042"></A><A NAME="IXT-4-336043"></A><A NAME="IXT-4-336044"></A>
			By default, all variables in Perl are global variables; that is,
			they are accessable from every part of the program. But <SPAN STYLE="background: #e6e64c">you
			can create private variables called <I>lexical variables</I> at
			any time with the </SPAN><TT><SPAN STYLE="background: #e6e64c"><FONT COLOR="#cc0000">my</FONT></SPAN></TT><SPAN STYLE="background: #e6e64c">
			operator: </SPAN>
			</P>
			<PRE><FONT COLOR="#cc0000">sub max {</FONT>
<FONT COLOR="#cc0000">  my($a, $b);       # new, private variables for this block</FONT>
<FONT COLOR="#cc0000">  ($a, $b) = @_;    # give names to the parameters</FONT>
<FONT COLOR="#cc0000">  if ($a &gt; $b) { $a } else { $b }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-4-336045"></A><A NAME="IXT-4-336046"></A>These
			variables are private (or <I>scoped</I>) to the enclosing block;
			any other <TT><FONT COLOR="#cc0000">$a</FONT></TT> or <TT><FONT COLOR="#cc0000">$b</FONT></TT>
			is totally unaffected by these two. And that goes the other way,
			too&iuml;&frac34;—no other code can access or modify these
			private variables, by accident or design.<A HREF="#">[12]</A> <SPAN STYLE="background: #ff6633">So,
			we could drop this subroutine into any Perl program in the world
			and know that we wouldn't mess up that program's</SPAN> <TT><FONT COLOR="#cc0000">$a</FONT></TT>
			and <TT><FONT COLOR="#cc0000">$b</FONT></TT> (if any).<A HREF="#">[13]</A>
			
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[12]</SUP>
			Advanced programmers will realize that a lexical variable may be
			accessible by reference from outside its scope, but never by name.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[13]</SUP> Of
			course,<SPAN STYLE="background: #ff6633"> if that program already
			had a subroutine called </SPAN><TT><SPAN STYLE="background: #ff6633"><FONT COLOR="#cc0000">&amp;max</FONT></SPAN></TT><SPAN STYLE="background: #ff6633">,
			we'd mess that up. </SPAN>
			</P>
			<P><A NAME="IXT-4-336047"></A>It's also worth pointing out that,
			inside the <TT><FONT COLOR="#cc0000">if</FONT></TT>'s blocks,
			there's no semicolon needed after the return value expression.
			Although Perl allows for the last semicolon in a block to be
			omitted, in practice that's omitted only when the code is so
			simple that the block is written in a single line, like the
			previous ones. 
			</P>
			<P>The subroutine in the previous example could be made even
			simpler. Did you notice that the list <TT><FONT COLOR="#cc0000">($a,</FONT></TT>
			<TT><FONT COLOR="#cc0000">$b)</FONT></TT> was written twice? That
			<TT><FONT COLOR="#cc0000">my</FONT></TT> operator can also be
			applied to a list of variables enclosed in parentheses, so it's
			more customary to combine those first two statements in the
			subroutine: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000"><SPAN STYLE="background: #94bd5e">my($a, $b) = @_; </SPAN> # Name the subroutine parameters</FONT></PRE><P>
			That one statement creates the private variables and sets their
			values, so the first parameter now has the easier-to-use name <TT><FONT COLOR="#cc0000">$a</FONT></TT>
			and the second has <TT><FONT COLOR="#cc0000">$b</FONT></TT>.
			<SPAN STYLE="background: #94bd5e">Nearly every subroutine will
			start with a line much like that one, naming its parameters.</SPAN>
			When you see that line, <SPAN STYLE="background: #94bd5e">you'll
			know that the subroutine expects two scalar parameters</SPAN>,
			which we'll call <TT><FONT COLOR="#cc0000">$a</FONT></TT> and <TT><FONT COLOR="#cc0000">$b</FONT></TT>
			inside the subroutine. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic19" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-7"></A>4.7 The local Operator</H3>
			<P>You might consider this next section a giant footnote, but then
			we couldn't have footnotes on footnotes, so we decided to put it
			up in the main text. Skip over this text on first reading, and pop
			right on down to <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-4-SECT-8#lperl3-CHP-4-SECT-8">Section
			4.8</A>. You won't need any of it to do the exercises or write
			Perl code for a long time. But someone invariably asks us in class
			something like &quot;What is that <TT><FONT COLOR="#cc0000">local</FONT></TT>
			thing I see in some programs?&quot; so we're including what we
			normally say as an aside in class for your enjoyment and
			edification. 
			</P>
			<P><A NAME="IXT-4-336048"></A>Occasionally, mostly in older code
			or older Perl books, you'll see the <TT><FONT COLOR="#cc0000">local</FONT></TT>
			operator used instead of <TT><FONT COLOR="#cc0000">my</FONT></TT>.
			It often looks much the same as <TT><FONT COLOR="#cc0000">my</FONT></TT>:
			
			</P>
			<PRE><FONT COLOR="#cc0000">sub max {</FONT>
<FONT COLOR="#cc0000">  local($a, $b) = @_;  # looks a lot like my</FONT>
<FONT COLOR="#cc0000">  if ($a &gt; $b) { $a } else { $b }</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-4-336049"></A><A NAME="IXT-4-336050"></A>But <TT><FONT COLOR="#cc0000">local</FONT></TT>
			is misnamed, or at least misleadingly named. Our friend Chip
			Salzenberg says that if he ever gets a chance to go back in a time
			machine to 1986 and give Larry one piece of advice, he'd tell
			Larry to call <TT><FONT COLOR="#cc0000">local</FONT></TT> by the
			name &quot;save&quot; instead.<A HREF="#">[14]</A> That's because
			<TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">local</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			actually will save the given global variable's value away, so it
			will later automatically be restored to the global variable.</SPAN>
			(That's right: these so-called &quot;<TT><FONT COLOR="#cc0000">local</FONT></TT>&quot;
			variables are actually globals!) This save-and-restore mechanism
			is the same one we've already seen twice now, in the control
			variable of a <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop,
			and in the <TT><FONT COLOR="#cc0000">@_</FONT></TT> array of
			subroutine parameters. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[14]</SUP> We
			would tell Larry to buy stock in Yahoo!, but Chip is more
			idealistic than we are.</P>
			<P><A NAME="IXT-4-336051"></A>What <TT><FONT COLOR="#cc0000">local</FONT></TT>
			actually does, then, is to<SPAN STYLE="background: #94bd5e"> save
			away a copy of the variable's value in</SPAN> a secret place
			(called <SPAN STYLE="background: #94bd5e">the stack</SPAN>). That
			value can't be accessed, modified, or deleted<A HREF="#">[15]</A>
			while it is saved. Then <TT><FONT COLOR="#cc0000">local</FONT></TT>
			sets the variable to an empty value (<TT><FONT COLOR="#cc0000">undef</FONT></TT>
			for scalars, or empty list for arrays), or to whatever value is
			being assigned. When Perl returns from the subroutine,<A HREF="#">[16]</A>
			the variable is automatically restored to its original value. In
			effect, <SPAN STYLE="background: #94bd5e">the variable[name] was
			borrowed for a time and given back </SPAN>(hopefully) before
			anyone noticed that it was borrowed. 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[15]</SUP> Or
			damaged, defiled, read, checked, touched, seen, changed, or
			printed, for that matter. There's no way from within Perl to get
			at the saved value.</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[16]</SUP> Or
			<SPAN STYLE="background: #7da647">when it finishes execution of
			the smallest enclosing block or fil</SPAN>e, to be more precise.</P>
			<H4><A NAME="lperl3-CHP-4-SECT-7.1"></A>4.7.1 The Difference
			Between local and my</H4>
			<P>But what if the subroutine called another subroutine, one that
			did notice that the variable was being borrowed by <TT><FONT COLOR="#cc0000">local</FONT></TT>?
			For example: 
			</P>
			<PRE><FONT COLOR="#cc0000">$office = &quot;global&quot;;  # Global $office</FONT>
<FONT COLOR="#cc0000">&amp;say( );                                # says &quot;global&quot;, accessing $office directly</FONT>

<FONT COLOR="#cc0000">&amp;fred( );                               # says &quot;fred&quot;, dynamic scope,</FONT>
<FONT COLOR="#cc0000">    # because fred's local $office hides the global</FONT>

<FONT COLOR="#cc0000">&amp;barney( );                             # says &quot;global&quot;, lexical scope;</FONT>
<FONT COLOR="#cc0000">    # barney's $office is visible only in that block</FONT>

<FONT COLOR="#cc0000">sub say { print &quot;$office\n&quot;; }         # print the currently visible $office</FONT>
<FONT COLOR="#cc0000">sub fred { local($office) = &quot;fred&quot;; &amp;say( ); }</FONT>
<FONT COLOR="#cc0000">sub barney { my($office) = &quot;barney&quot;; &amp;say( ); }</FONT></PRE><P>
			First, we call the subroutine <TT><FONT COLOR="#cc0000">&amp;say</FONT></TT>,
			which tells us which <TT><FONT COLOR="#cc0000">$office</FONT></TT>
			it sees&iuml;&frac34;—the global <TT><FONT COLOR="#cc0000">$office</FONT></TT>.
			That's normal. 
			</P>
			<P>But then we call Fred's subroutine. Fred has made his own <TT><FONT COLOR="#cc0000">local
			$office</FONT></TT>, so he has actually changed the behavior of
			the <TT><FONT COLOR="#cc0000">&amp;say</FONT></TT> subroutine; now
			it tells us what's in Fred's <TT><FONT COLOR="#cc0000">$office</FONT></TT>.
			We can't tell whether that's what Fred wanted to do or not without
			understanding the meaning of his code. But it's a little odd. 
			</P>
			<P>Barney, however, is a little smarter, as well as being shorter,
			so he uses the shorter (and smarter) operator, <TT><FONT COLOR="#cc0000">my</FONT></TT>.
			Barney's variable <TT><FONT COLOR="#cc0000">$office</FONT></TT> is
			private, and <SPAN STYLE="background: #7da647">Barney's private
			</SPAN><TT><SPAN STYLE="background: #7da647"><FONT COLOR="#cc0000">$office</FONT></SPAN></TT><SPAN STYLE="background: #7da647">
			can't be accessed from outside his subroutine</SPAN>,<SPAN STYLE="background: #94bd5e">
			so the </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">&amp;say</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">
			subroutine is back to norma</SPAN><SPAN STYLE="background: #7da647">l;</SPAN>
			it can see only the global <TT><FONT COLOR="#cc0000">$office</FONT></TT>.
			<SPAN STYLE="background: #ff6633">Barney didn't change the way
			</SPAN><TT><SPAN STYLE="background: #ff6633"><FONT COLOR="#cc0000">&amp;say</FONT></SPAN></TT><SPAN STYLE="background: #ff6633">
			works, which is more like what most programmers would want and
			expect. </SPAN>
			</P>
			<P><A NAME="IXT-4-336052"></A>Now, if you're confused about these
			two operators at this point, that's to be expected. But any time
			that you see <TT><FONT COLOR="#cc0000">local</FONT></TT>, think
			&quot;save,&quot; and that may help. In any new code, just use <TT><FONT COLOR="#cc0000">my</FONT></TT>,
			since <TT><FONT COLOR="#cc0000">my</FONT></TT> variables (lexical
			variables) are faster than globals&iuml;&frac34;—remember,
			so-called <TT><FONT COLOR="#cc0000">local</FONT></TT> variables
			are really globals&iuml;&frac34;—and they'll work more like the
			traditional variables in other modern programming languages. But
			when you're maintaining someone else's old code, you can't
			necessarily change every <TT><FONT COLOR="#cc0000">local</FONT></TT>
			to <TT><FONT COLOR="#cc0000">my</FONT></TT> without checking upon
			whether the programmer was using that save-and-restore
			functionality. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic20" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-8"></A>4.8 Variable-length
			Parameter Lists</H3>
			<P><A NAME="lperl3-IDXTERM-348"></A><A NAME="lperl3-IDXTERM-349"></A>
			In real-world Perl code, subroutines are often given parameter
			lists of arbitrary length. That's because of Perl's &quot;no
			unnecessary limits&quot; philosophy that we've already seen. Of
			course, this is unlike many traditional programming languages,
			which require every subroutine to be strictly typed; that is, to
			permit only a certain, predefined number of parameters of
			predefined types. It's nice that Perl is so flexible, but (as we
			saw with the <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			routine earlier) that may cause problems when a subroutine is
			called with a different number of arguments than the author
			expected. 
			</P>
			<P>Of course, the subroutine can easily <SPAN STYLE="background: #ff6633">check
			that it has the right number of arguments</SPAN> by examining the
			<TT><FONT COLOR="#cc0000">@_</FONT></TT> array. For example, we
			could have written <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			to check its argument list like this:<A HREF="#">[17]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[17]</SUP> As
			soon as you learn about <TT><FONT COLOR="#cc0000">warn</FONT></TT>
			(in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-11#lperl3-CHP-11">Chapter
			11</A>), you'll see that you can use it to turn improper usage
			like this into a proper warning. Or perhaps you'll decide that
			this case is severe enough to warrant using <TT><FONT COLOR="#cc0000">die</FONT></TT>,
			described in the same chapter.</P>
			<PRE><FONT COLOR="#cc0000">sub max {</FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #ff6633">  if (@_ != 2) {</SPAN></FONT>
<FONT COLOR="#cc0000"><SPAN STYLE="background: #ff6633">    print &quot;WARNING! &amp;max should get exactly two arguments!\n&quot;;</SPAN></FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">  # continue as before...</FONT>
<FONT COLOR="#cc0000">  .</FONT>
<FONT COLOR="#cc0000">  .</FONT>
<FONT COLOR="#cc0000">  .</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			That <TT><FONT COLOR="#cc0000">if</FONT></TT>-test<SPAN STYLE="background: #7da647">
			uses the &quot;name&quot; of the array in a scalar context</SPAN>
			<SPAN STYLE="background: #7da647">to find out the number of array
			elements</SPAN>, as we saw in <A HREF="./%3Fxmlid=0-596-00132-0/lperl3-CHP-3#lperl3-CHP-3">Chapter
			3</A>. 
			</P>
			<P>But in real-world Perl programming, <SPAN STYLE="background: #94bd5e">this
			sort of check is hardly ever used</SPAN>; it's <SPAN STYLE="background: #94bd5e">better
			to make the subroutine adapt </SPAN>to the parameters. 
			</P>
			<H4><A NAME="lperl3-CHP-4-SECT-8.1"></A>4.8.1 A Better &amp;max
			Routine</H4>
			<P><A NAME="IXT-4-336053"></A>So let's rewrite <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			to allow for any number of arguments: 
			</P>
			<PRE><FONT COLOR="#cc0000">$maximum = &amp;max(3, 5, 10, 4, 6);</FONT>

<FONT COLOR="#cc0000">sub max {</FONT>
<FONT COLOR="#cc0000">  my($max_so_far) = shift @_;  # the first one is the largest yet seen</FONT>
<FONT COLOR="#cc0000">  foreach (@_) {               # look at the remaining arguments</FONT>
<FONT COLOR="#cc0000">    if ($_ &gt; $max_so_far) {    # could this one be bigger yet?</FONT>
<FONT COLOR="#cc0000">      $max_so_far = $_;</FONT>
<FONT COLOR="#cc0000">    }</FONT>
<FONT COLOR="#cc0000">  }</FONT>
<FONT COLOR="#cc0000">  $max_so_far;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<SPAN STYLE="background: #94bd5e">This code uses what has often
			been called the &quot;high-water mark&quot; algorithm;</SPAN>
			after a flood, when the waters have surged and receded for the
			last time, the high-water mark shows where the highest water was
			seen. In this routine, <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>
			keeps track of our high-water mark, the largest number yet seen. 
			</P>
			<P>The first line sets <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>
			to <TT><FONT COLOR="#cc0000">3</FONT></TT> (the first parameter in
			the example code) by shifting that parameter from the parameter
			array, <TT><FONT COLOR="#cc0000">@_</FONT></TT>. So <TT><FONT COLOR="#cc0000">@_</FONT></TT>
			now holds <TT><FONT COLOR="#cc0000">(5, 10,</FONT></TT> <TT><FONT COLOR="#cc0000">4,
			6)</FONT></TT>, since the <TT><FONT COLOR="#cc0000">3</FONT></TT>
			has been shifted off. And the largest number yet seen is the only
			one yet seen: <TT><FONT COLOR="#cc0000">3</FONT></TT>, the first
			parameter. 
			</P>
			<P>Now, the <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop
			will step through the remaining values in the parameter list, from
			<TT><FONT COLOR="#cc0000">@_</FONT></TT>. The control variable of
			the loop is, by default, <TT><FONT COLOR="#cc0000">$_</FONT></TT>.
			(But, <SPAN STYLE="background: #7da647">remember, there's no
			automatic connection between </SPAN><TT><SPAN STYLE="background: #7da647"><FONT COLOR="#cc0000">@_</FONT></SPAN></TT><SPAN STYLE="background: #7da647">
			and </SPAN><TT><SPAN STYLE="background: #7da647"><FONT COLOR="#cc0000">$_</FONT></SPAN></TT><SPAN STYLE="background: #7da647">;
			it's just a coincidence that they have such similar names.</SPAN>)
			The first time through the loop, <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			is <TT><FONT COLOR="#cc0000">5</FONT></TT>. The <TT><FONT COLOR="#cc0000">if</FONT></TT>
			test sees that it is larger than <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>,
			so <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT> is set to
			<TT><FONT COLOR="#cc0000">5</FONT></TT>&iuml;&frac34;—the new
			high-water mark. 
			</P>
			<P>The next time through the loop, <TT><FONT COLOR="#cc0000">$_</FONT></TT>
			is <TT><FONT COLOR="#cc0000">10</FONT></TT>. That's a new record
			high, so it's stored in <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>
			as well. 
			</P>
			<P>The next time, <TT><FONT COLOR="#cc0000">$_</FONT></TT> is <TT><FONT COLOR="#cc0000">4</FONT></TT>.
			The <TT><FONT COLOR="#cc0000">if</FONT></TT> test fails, since
			that's no larger than <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>,
			which is <TT><FONT COLOR="#cc0000">10</FONT></TT>, so the body of
			the <TT><FONT COLOR="#cc0000">if</FONT></TT> is skipped. 
			</P>
			<P>The next time, <TT><FONT COLOR="#cc0000">$_</FONT></TT> is <TT><FONT COLOR="#cc0000">6</FONT></TT>,
			and the body of the <TT><FONT COLOR="#cc0000">if</FONT></TT> is
			skipped again. And that was the last time through the loop, so the
			loop is done. 
			</P>
			<P>Now, <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT> becomes
			the return value. It's the largest number we've seen, and we've
			seen them all, so it must be the largest from the list: <TT><FONT COLOR="#cc0000">10</FONT></TT>.
			
			</P>
			<H4><A NAME="lperl3-CHP-4-SECT-8.2"></A>4.8.2 Empty Parameter
			Lists</H4>
			<P><A NAME="IXT-4-336054"></A>That improved <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			algorithm works fine now, even if there are more than two
			parameters. But what happens if there are none? 
			</P>
			<P>At first, it may seem too esoteric to worry about. After all,
			why would someone call <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			without giving it any parameters? But maybe someone wrote a line
			like this one: 
			</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">$maximum = &amp;max(@numbers);</FONT></PRE><P>
			And the array <TT><FONT COLOR="#cc0000">@numbers</FONT></TT> might
			sometimes be an empty list; perhaps it was read in from a file
			that turned out to be empty, for example. So what does <TT><FONT COLOR="#cc0000">&amp;max</FONT></TT>
			do in that case? 
			</P>
			<P>The first line of the subroutine sets <TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>
			by using <TT><FONT COLOR="#cc0000">shift</FONT></TT> on <TT><FONT COLOR="#cc0000">@_</FONT></TT>,
			the (now empty) parameter array. That's harmless; the array is
			left empty, and <TT><FONT COLOR="#cc0000">shift</FONT></TT>
			returns <TT><FONT COLOR="#cc0000">undef</FONT></TT> to
			<TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>. 
			</P>
			<P>Now the <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop
			wants to iterate over <TT><FONT COLOR="#cc0000">@_</FONT></TT>,
			but since that's empty, the loop body is executed zero times. 
			</P>
			<P>So in short order, Perl returns the value of
			<TT><FONT COLOR="#cc0000">$max_so_far</FONT></TT>&iuml;&frac34;—<TT><FONT COLOR="#cc0000">undef</FONT></TT>&iuml;&frac34;—as
			the return value of the subroutine. In some sense, that's the
			right answer, because there is no largest value in an empty list. 
			</P>
			<P><A NAME="IXTR3-27"></A><A NAME="IXTR3-28"></A>Of course,
			whoever is calling this subroutine should be aware that the return
			value may be <TT><FONT COLOR="#cc0000">undef</FONT></TT>&iuml;&frac34;—or
			they could simply ensure that the parameter list is never empty. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic21" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<HR SIZE=2>
<P STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR>
		<TD VALIGN=TOP>
			<H3><A NAME="lperl3-CHP-4-SECT-9"></A>4.9 Notes on Lexical (my)
			Variables</H3>
			<P><A NAME="IXT-4-336055"></A>Those <SPAN STYLE="background: #94bd5e">lexical
			variables can actually be used in any block, not merely in a
			subroutine's block. </SPAN>For example, they can be used in the
			block of an <TT><TT><FONT COLOR="#cc0000">if</FONT></TT></TT>,
			<TT><TT><FONT COLOR="#cc0000">while</FONT></TT></TT>, or <TT><TT><FONT COLOR="#cc0000">foreach</FONT></TT></TT>:
			
			</P>
			<PRE><FONT COLOR="#cc0000">foreach (1..10) {</FONT>
<FONT COLOR="#cc0000">  my($square) = $_ * $_;  # private variable in this loop</FONT>
<FONT COLOR="#cc0000">  print &quot;$_ squared is $square.\n&quot;;</FONT>
<FONT COLOR="#cc0000">}</FONT></PRE><P>
			<A NAME="IXT-4-336056"></A>The variable <TT><FONT COLOR="#cc0000">$square</FONT></TT>
			is private to the enclosing block; in this case, that's the block
			of the <TT><FONT COLOR="#cc0000">foreach</FONT></TT> loop. If
			there's no block, the variable is private to the entire source
			file. For now, your programs aren't going to use more than one
			source file, so this isn't an issue. But the important concept is
			that the <SPAN STYLE="background: #94bd5e"><I>scope</I> of a
			lexical variable's name is limited to the smallest enclosing block
			or file.</SPAN> The only code that can say <TT><FONT COLOR="#cc0000">$square</FONT></TT>
			and mean that variable is the code inside that textual scope. This
			is a big win for maintainability&iuml;&frac34;—if the wrong
			value is found in <TT><FONT COLOR="#cc0000">$square</FONT></TT>,
			the culprit will be found within a limited amount of source code.
			As experienced programmers have learned (often the hard way),
			limiting the scope of a variable to a page of code, or even to a
			few lines of code, really speeds along the development and testing
			cycle. 
			</P>
			<P><A NAME="IXT-4-336057"></A>Note also that the <TT><FONT COLOR="#cc0000">my</FONT></TT>
			operator doesn't change the context of an assignment: 
			</P>
			<PRE><FONT COLOR="#cc0000">my($num) = @_;  # list context, same as ($num) = @_;</FONT>
<FONT COLOR="#cc0000">my $num  = @_;  # scalar context, same as $num = @_;</FONT></PRE><P>
			<SPAN STYLE="background: #ff6633">In the first one, </SPAN><TT><FONT COLOR="#cc0000">$num</FONT></TT>
			gets the first parameter, as a list-context assignment;<SPAN STYLE="background: #7da647">
			in the second, it gets the number of parameters, in a scalar
			context.</SPAN> Either line of code could be what the programmer
			wanted; we can't tell from that one line alone, and so Perl can't
			warn you if you use the wrong one. (Of course, you wouldn't have
			both of those lines in the same subroutine, since you can't have
			two lexical variables with the same name declared in the same
			scope; this is just an example.) So, when reading code like this,
			<SPAN STYLE="background: #94bd5e">you can always tell the context
			of the assignment by seeing what the context would be without the
			word </SPAN><TT><SPAN STYLE="background: #94bd5e"><FONT COLOR="#cc0000">my</FONT></SPAN></TT><SPAN STYLE="background: #94bd5e">.
			</SPAN>
			</P>
			<P>Of course, you can use <TT><FONT COLOR="#cc0000">my</FONT></TT>
			to create new, private arrays as well:<A HREF="#">[18]</A> 
			</P>
			<P STYLE="margin-left: 1cm; margin-right: 1cm"><SUP>[18]</SUP> Or
			hashes, which we'll see in the next chapter.</P>
			<PRE STYLE="margin-bottom: 0.5cm"><FONT COLOR="#cc0000">my @phone_number;</FONT></PRE><P>
			Any new variable will start out empty&iuml;&frac34;—<TT><FONT COLOR="#cc0000">undef</FONT></TT>
			for scalars, or the empty list for arrays. 
			</P>
			<P><A HREF="./%3Fxmlid=0-596-00132-0/18961533"><IMG SRC="images/pixel.gif" NAME="Graphic22" ALIGN=BOTTOM WIDTH=2 HEIGHT=2 BORDER=0></A></P>
		</TD>
	</TR>
</TABLE>
<P><A HREF="">page 1</A><BR><A HREF="perl2.html">page 2</A><BR><A HREF="perl3.html">page
3</A><BR><A HREF="perl4.html">page 4</A></P>
</BODY>
</HTML>