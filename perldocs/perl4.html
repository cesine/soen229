<html>
<head>
<title>perldocs page 4</title>
</head>
<body>

<a href="perl1.html">page 1</a><br>
<a href="perl2.html">page 2</a><br>
<a href="perl3.html">page 3</a><br>
<a href="perl4.html">page 4</a><br>
 


<hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-15-SECT-5"></A>
<H3 class="docSection1Title">15.5 Exercises</H3>

<P class="docText">See <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-APP-A-SECT-14#lperl3-APP-A-SECT-14">Section A.14</A> for answers to the following
exercises:
</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">[10] Write a program to read in a list of numbers and sort them
numerically, printing out the resulting list in a right-justified
column. Try it out on this sample data, or use the file
<I>numbers</I>, from the O'Reilly web site (see
the Preface):
</P><PRE><font color="#CC0000">17 1000 04 1.50 3.14159 -10 1.5 4 2001 90210 666</font color="#CC0000"></PRE></span></LI>
<LI><span style="font-weight:normal"><P class="docList">[15] Make a program that will print the following hash's data
sorted in case-insensitive alphabetical order by last name. When the
last names are the same, sort those by first name (again, without
regard for case). That is, the first name in the output should be
Fred's, while the last one should be Betty's. All of the
people with the same family name should be grouped together.
Don't alter the data. The names should be printed with the same
capitalization as shown here. (You can find the source code to create
a hash like this in the file <I>sortable_hash</I> with
the other downloaded files.)
</P><PRE><font color="#CC0000">my %last_name = qw{ 
  fred flintstone Wilma Flintstone Barney Rubble
  betty rubble Bamm-Bamm Rubble PEBBLES FLINTSTONE
}; </font color="#CC0000"></PRE></span></LI>
<LI><span style="font-weight:normal"><P class="docList">[15] Make a program that looks through a given string for every
occurrence of a given substring, printing out the positions where the
substring is found. For example, given the input string
<TT><font color="#CC0000">"This is a test."</font color="#CC0000"></TT> and the substring
<TT><font color="#CC0000">"is"</font color="#CC0000"></TT>, it should report positions
<TT><font color="#CC0000">2</font color="#CC0000"></TT> and <TT><font color="#CC0000">5</font color="#CC0000"></TT>. If the substring were
<TT><font color="#CC0000">"a"</font color="#CC0000"></TT>, it should report <TT><font color="#CC0000">8</font color="#CC0000"></TT>. What
does it report if the substring is<A NAME="IXTR3-113"></A> <TT><font color="#CC0000">"t"</font color="#CC0000"></TT>?<A NAME="IXTR3-114"></A>
</P></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-16"></A>

<H2 class="docChapterTitle">Chapter 16. Simple Databases</H2>

<P class="docText"><A NAME="lperl3-IDXTERM-1028"></A>Databases
permit us to allow data to persist beyond the end of our program. The
kinds of databases we're talking about in this chapter are
merely simple ones; how to use full-featured database implementations
(Oracle, Sybase, Informix, mySQL, and others) is a topic that could
fill an entire book, and usually does. The databases in this chapter
are those that are simple enough to implement that you don't
need to know about modules to use them.<sup class="docFootnote"><A class="docLink" HREF="#">[1]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[1]</A></sup> To be sure,
on some of these, the core of Perl will load a module for you. But
you don't need to know anything about modules to use these
databases.</p></blockquote>


<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-16-SECT-1"></A>
<H3 class="docSection1Title">16.1 DBM Files and DBM Hashes</H3>

<P class="docText"><A NAME="lperl3-IDXTERM-1029"></A> <A NAME="lperl3-IDXTERM-1030"></A>Every
system thas has Perl also has a simple database already available in
the form of DBM files. This lets your program store data for quick
lookup in a file or in a pair of files. When two files are used, one
holds the data and the other holds a table of contents, but you
don't need to know that in order to use DBM files. We're
intentionally being a little vague about the exact implementation,
because that will vary depending upon your machine and configuration;
see the <TT><font color="#CC0000">AnyDBM_file</font color="#CC0000"></TT><A NAME="IXT-16-336559"></A> manpage for more information. Also,
among the downloadable files from the O'Reilly website is a
utility called
<I>which_dbm,</I><A NAME="IXT-16-336560"></A>
<A NAME="IXT-16-336561"></A>
which tries to tell you which implementation you're using, how
many files there are, and what extensions they use, if any.
</P>

<P class="docText">Some DBM file implementations (we'll call it "a
file," even though it may be two actual files) have a limit of
around 1000 bytes for each key and value in the file. Your actual
limit may be larger or smaller than this number, but as long as you
aren't trying to store gigantic text strings in the file, it
shouldn't be a problem. There's no limit to the number of
individual data items in the file, as long as you have enough disk
space.
</P>

<P class="docText">In Perl, we can access the DBM file as a special kind of hash called
a DBM hash. This is a powerful concept, as we'll see.
</P>

<A NAME="lperl3-CHP-16-SECT-1.1"></A>
<H4 class="docSection2Title">16.1.1 Opening and Closing DBM Hashes</H4>

<P class="docText">To associate a DBM database with a DBM hash (that is, to open it),
use the <TT><font color="#CC0000">dbmopen</font color="#CC0000"></TT><A NAME="IXT-16-336562"></A> function,<sup class="docFootnote"><A class="docLink" HREF="#">[2]</A></sup> which looks similar to
<TT><font color="#CC0000">open</font color="#CC0000"></TT>, in a way:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[2]</A></sup> Here we
depart from other beginner documentation, which claims that
<TT><font color="#CC0000">dbmopen </font color="#CC0000"></TT>is deprecated and suggests that you use
the more complicated <TT><font color="#CC0000">tie </font color="#CC0000"></TT><A NAME="IXT-16-336563"></A>interface instead. We disagree, since
<TT><font color="#CC0000">dbmopen </font color="#CC0000"></TT>works just fine, and it keeps you from
having to think harder about what you're doing. Keep the common
tasks simple!</p></blockquote>

<PRE><font color="#CC0000">dbmopen(%DATA, "my_database", 0644)
  or die "Cannot create my_database: $!";</font color="#CC0000"></PRE>

<P class="docText">The first parameter is the name of a Perl hash. (If this hash already
has values, the values are inaccessible while the DBM file is open.)
This hash becomes connected to the DBM database whose name was given
as the second parameter, often stored on disk as a pair of files with
the extensions <TT><font color="#CC0000">.</font color="#CC0000"></TT><span class="docEmphasis">dir</span> and
<TT><font color="#CC0000">.</font color="#CC0000"></TT><span class="docEmphasis">pag</span>. (The filename as given
in the second parameter shouldn't include either extension,
though; the extensions will be automatically added as needed.) In
this case, the files might be called
<I>my_database.dir</I> and
<I>my_database.pag</I>.
</P>

<P class="docText">Any legal hash name may be used as the name of the DBM hash, although
uppercase-only hash names are traditional because their resemblance
to filehandles reminds us that the hash is connected to a file. The
hash name isn't stored anywhere in the file, so you can call it
whatever you'd like.
</P>

<P class="docText">If the file doesn't exist, it will be created and given a
permission mode based upon the value in the third
parameter.<sup class="docFootnote"><A class="docLink" HREF="#">[3]</A></sup> The number is typically specified in
octal; the frequently used value of <TT><font color="#CC0000">0644</font color="#CC0000"></TT> gives
read-only permission to everyone but the owner, who gets read/write
permission. If you're trying to open an existing file,
you'd probably rather have the <TT><font color="#CC0000">dbmopen</font color="#CC0000"></TT>
fail if the file isn't found, so just use
<TT><font color="#CC0000">undef</font color="#CC0000"></TT> as the third parameter.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[3]</A></sup> The actual mode will be modified by the
<TT><font color="#CC0000">umask</font color="#CC0000"></TT>; see the
<span class="docEmphasis">perlfunc</span>manpage for more
information.</p></blockquote>

<P class="docText">The return value from the <TT><font color="#CC0000">dbmopen</font color="#CC0000"></TT> is true if the
database could be opened or created, and false otherwise, just like
<TT><font color="#CC0000">open</font color="#CC0000"></TT>. You should generally use <TT><font color="#CC0000">or
die</font color="#CC0000"></TT> in the same spirit as <TT><font color="#CC0000">open</font color="#CC0000"></TT>.
</P>

<P class="docText">The DBM hash typically stays open throughout the program. When the
program terminates, the association is terminated. You can also break
the association in a manner similar to closing a filehandle, by using
<TT><font color="#CC0000">dbmclose</font color="#CC0000"></TT><A NAME="IXT-16-336564"></A>:
</P>

<PRE><font color="#CC0000">dbmclose(%DATA);</font color="#CC0000"></PRE>


<A NAME="lperl3-CHP-16-SECT-1.2"></A>
<H4 class="docSection2Title">16.1.2 Using a DBM Hash</H4>

<P class="docText">Here's the beauty of the DBM hash: it works just like the
hashes you already understand! To read from the file, look at an
element of the hash. To write to the file, store something into the
hash. In short, it's like any other hash, but instead of being
stored in memory, it's stored on disk. And thus, when your
program opens it up again, the hash is already stuffed full of the
data from the previous invocation.
</P>

<P class="docText">All of the normal hash operations are available:</P>

<PRE><font color="#CC0000">$DATA{"fred"} = "bedrock";      # create (or update) an element
delete $DATA{"barney"};         # remove an element of the database

foreach my $key (keys %DATA) {  # step through all values
  print "$key has value of $DATA{$key}\n";
}</font color="#CC0000"></PRE>

<P class="docText">That last loop could have a problem, since <TT><font color="#CC0000">keys</font color="#CC0000"></TT>
has to traverse the entire hash, possibly producing a very large list
of keys. If you are scanning through a DBM hash, it's generally
more memory-efficient to use the
<TT><font color="#CC0000">each</font color="#CC0000"></TT><A NAME="IXT-16-336565"></A>
function:
</P>

<PRE><font color="#CC0000">while (my($key, $value) = each(%DATA)) {
  print "$key has value of $value\n";
}</font color="#CC0000"></PRE>

<P class="docText">If you are accessing DBM files that are maintained by
<A NAME="IXT-16-336566"></A>C programs, you should be aware that
C programs generally tack on a trailing <A NAME="IXT-16-336567"></A>NUL (<TT><font color="#CC0000">"\0"</font color="#CC0000"></TT>) character to
the end of their strings, for reasons known only to Kernighan and
Ritchie.<sup class="docFootnote"><A class="docLink" HREF="#">[4]</A></sup> The DBM library routines do not need this
NUL (they handle binary data using a byte count, not a NUL-terminated
string), and so the NUL is stored as part of the data.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[4]</A></sup> Well, they're not the only ones:
it's because C uses the NUL byte as the end-of-string
marker.</p></blockquote>

<P class="docText">To cooperate with these programs, you must therefore append a NUL
character to the end of your keys and values, and discard the NUL
from the end of the returned values to have the data make sense. For
example, to look up <TT><font color="#CC0000">merlyn</font color="#CC0000"></TT> in the sendmail aliases
database on a Unix system, you might do something like this:
</P>

<PRE><font color="#CC0000">dbmopen(my %ALI, "/etc/aliases", undef) or die "no aliases?";
my $value = $ALI{"merlyn\0"};                  # note appended NUL
$value =~ s/\0$//;                             # remove trailing NUL
print "Randal's mail is headed for: $value\n"; # show result</font color="#CC0000"></PRE>

<P class="docText">If your DBM files may be concurrently accessed by more than one
process (for example if they're being updated over the Web),
you'll generally need to use an <A NAME="IXT-16-336568"></A>auxiliary lock file. The details of this
are beyond the scope of this book; see <span class="docEmphasis">The Perl
Cookbook</span> by Tom Chrisitansen and Nathan Torkington
(O'Reilly &amp; Associates, Inc.).<A NAME="IXTR3-115"></A> <A NAME="IXTR3-116"></A>
</P>



<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-16-SECT-2"></A>
<H3 class="docSection1Title">16.2 Manipulating Data with pack and unpack</H3>

<P class="docText">When storing
<A NAME="IXT-16-336569"></A>data into a DBM file (or
in one of the other types of databases we'll see in this
chapter), you may need to store more than one item under a single
key. And sometimes you'll need to be able to prepare some
information to be sent over a network connection or to a system-level
function, or to decode it upon arrival. That's why Perl has the
<TT><font color="#CC0000">pack</font color="#CC0000"></TT> and <TT><font color="#CC0000">unpack</font color="#CC0000"></TT> functions.
</P>

<P class="docText">The <TT><font color="#CC0000">pack</font color="#CC0000"></TT><A NAME="IXT-16-336570"></A> function takes a
<A NAME="IXT-16-336571"></A>format string
and a list of arguments and packs the arguments together to make a
string. Here, we can pack three numbers of varying sizes into a
seven-byte string using the formats <TT><font color="#CC0000">c</font color="#CC0000"></TT>,
<TT><font color="#CC0000">s</font color="#CC0000"></TT>, and <TT><font color="#CC0000">l</font color="#CC0000"></TT> (these might remind
some folks of the words "char", "short", and
"long"). The first number gets packed into one byte, the
second into two bytes, and the third into four bytes, which explains
why we say this is a seven-byte string:
</P>

<PRE><font color="#CC0000">my $buffer = pack("c s l", 31, 4159, 265359);</font color="#CC0000"></PRE>

<P class="docText">When you want the original list of items back, you can use the same
format string with the
<TT><font color="#CC0000">unpack</font color="#CC0000"></TT><A NAME="IXT-16-336572"></A> function:
</P>

<PRE><font color="#CC0000">my($char, $short, $long) = unpack("c s l", $buffer);</font color="#CC0000"></PRE>

<P class="docText">There are many different format letters available; some of these are
the same on every machine (so they're useful for sending data
over a network), while others depend upon how your machine likes to
work with data (these are useful for interacting with your
system's own data). See the
<TT><font color="#CC0000">perlfunc</font color="#CC0000"></TT><A NAME="IXT-16-336573"></A> <A NAME="IXT-16-336574"></A> manpage for the latest list of format
letters, as new ones are being added in every new version of Perl.
</P>

<P class="docText"><A NAME="IXT-16-336575"></A>Whitespace may be used at will in a
format string to improve readability, as we did in the previous
example. For most format letters, you can follow the format letter
with a number to indicate a number of times; that is, a format of
<TT><font color="#CC0000">"ccccccc"</font color="#CC0000"></TT> may be written more compactly as
<TT><font color="#CC0000">"c7"</font color="#CC0000"></TT>. Instead of a number, you may follow the last
format letter with a star (<TT><font color="#CC0000">*</font color="#CC0000"></TT>), which means to use
that format as many times as needed to use up the remaining items in
the list (in <TT><font color="#CC0000">pack</font color="#CC0000"></TT>) or to use up the rest of the
string (in <TT><font color="#CC0000">unpack</font color="#CC0000"></TT>). So a format of
<TT><font color="#CC0000">"c*"</font color="#CC0000"></TT> will either unpack a string into a list of
small integers, or pack up those small integers to make a string. For
some format letters, such as <TT><font color="#CC0000">a</font color="#CC0000"></TT>, the number is not
a repeat count; <TT><font color="#CC0000">"a20"</font color="#CC0000"></TT> is a twenty-character ASCII
string, padded with NUL characters as needed.
</P>


<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-16-SECT-3"></A>
<H3 class="docSection1Title">16.3 Fixed-length Random-access Databases</H3>

<P class="docText"><A NAME="lperl3-IDXTERM-1050"></A> <A NAME="lperl3-IDXTERM-1051"></A>Another form of persistent data
is the fixed-length, record-oriented disk file.<sup class="docFootnote"><A class="docLink" HREF="#">[5]</A></sup> In this
scheme, the data consists of a number of records of identical length.
The numbering of the records is either not important or determined by
some indexing scheme.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[5]</A></sup> By
"fixed-length," we don't mean that the file itself
is of a fixed length; it's each individual record that is of a
fixed length. In this section, we'll use an example file in
which every record is 55 bytes long.</p></blockquote>

<P class="docText">For example, we might want to store some information about each
bowler at Bedrock Lanes. Let's say we decide to have a series
of records, one per bowler, in which the data holds the
player's name, age, last five bowling scores, and the time and
date of his last game.
</P>

<P class="docText">We need to decide upon a suitable format for this data. Let's
say that after studying the available formats in the documentation
for <TT><font color="#CC0000">pack</font color="#CC0000"></TT>, we decide to use 40 characters for the
player's name, a one-byte integer for his age,<sup class="docFootnote"><A class="docLink" HREF="#">[6]</A></sup> five
two-byte integers for his last five scores,<sup class="docFootnote"><A class="docLink" HREF="#">[7]</A></sup> and a four-byte integer for the
timestamp of his most-recent game,<sup class="docFootnote"><A class="docLink" HREF="#">[8]</A></sup> giving a format string of <TT><font color="#CC0000">"a40 C
I5 L"</font color="#CC0000"></TT>. Each record is thus 55 bytes long. If we were
reading all of the data in the database, we'd read chunks of 55
bytes until we got to the end. If we wanted to go to the fifth
record, we'd skip ahead 4 x 55 bytes (220 bytes) and read
the fifth record directly.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[6]</A></sup> Since one byte may have 256 different values, this will hold
ages from 0 to 255 with ease. If Methuselah comes to bowl in Bedrock,
we'll have to redesign the database. </p></blockquote>
<blockquote><p class="docFootnote"><sup><A NAME="">[7]</A></sup> We
can't use one-byte integers for the scores, because a bowling
score can be as high as 300. Two-byte integers can hold values from 0
to 65535 (if unsigned) or -32768 to 32767 (if signed). We can use
some of these extra values as special codes; for example, if a player
has only three games on record, the other scores could be set to 9999
to indicate this.</p></blockquote>
<blockquote><p class="docFootnote"><sup><A NAME="">[8]</A></sup> The standard Unix
timestamp format (and the time value used by many other systems) is a
32-bit integer, which fits into four bytes, of course. You'll
probably find it handy to use a module to manipulate time and date
formats.</p></blockquote>

<P class="docText">Perl supports programs that use such a disk file. In order to do so,
however, you need to learn a few more things, including how to:
</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Open a disk file for both reading and writing</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Move around in this file to an arbitrary position</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Fetch data by a length rather than up to the next newline</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Write data down in fixed-length blocks</P></span></LI>
</OL></span>
<P class="docText">The <TT><font color="#CC0000">open</font color="#CC0000"></TT><A NAME="IXT-16-336576"></A>
<A NAME="IXT-16-336577"></A> function has an
additional mode we haven't shown yet. If you use
<TT><font color="#CC0000">"+&lt;"</font color="#CC0000"></TT> at the front of the filename
parameter's string, that is similar to using
<TT><font color="#CC0000">"&lt;"</font color="#CC0000"></TT> to open the existing file for reading,
except that it also asks for write permission on the file. Thus you
can have read/write access to the file:
</P>

<PRE><font color="#CC0000">open(FRED, "&lt;fred");  # open file fred for reading (error if file absent)
open(FRED, "+&lt;fred"); # open file fred read/write (error if file absent)</font color="#CC0000"></PRE>

<P class="docText">Similarly, <TT><font color="#CC0000">"+&gt;"</font color="#CC0000"></TT> says to create a new file (as
<TT><font color="#CC0000">"&gt;"</font color="#CC0000"></TT> would), but to have read access to it as
well, thus also giving read/write access:
</P>

<PRE><font color="#CC0000">open(WILMA, "&gt;wilma");  # make new file wilma (wiping out existing file)
open(WILMA, "+&gt;wilma"); # make new file wilma, but also with read access</font color="#CC0000"></PRE>

<P class="docText">Do you see the important difference between the two new modes? Both
give read/write access to a file. But <TT><font color="#CC0000">"+&lt;"</font color="#CC0000"></TT> lets
you work with an existing file; it doesn't create it. The
second mode, <TT><font color="#CC0000">"+&gt;"</font color="#CC0000"></TT> isn't often useful,
because it gives read/write access to a new, empty file that it has
just created. That's mostly used for temporary (scratch) files.
</P>

<P class="docText">Once we've got the file open, we need to move around in it. You
do this with the <TT><font color="#CC0000">seek</font color="#CC0000"></TT><A NAME="IXT-16-336578"></A> function:
</P>

<PRE><font color="#CC0000">seek(FRED, 55 * $n, 0);  # seek to start of record $n</font color="#CC0000"></PRE>

<P class="docText">The first parameter to <TT><font color="#CC0000">seek</font color="#CC0000"></TT> is a filehandle, the
second parameter gives the offset in bytes from the start of the
file, and the third parameter is zero.<sup class="docFootnote"><A class="docLink" HREF="#">[9]</A></sup> To get to a certain record in our file of bowling data,
you'll need to skip over some other records. Since each record
is 55 bytes long, we'll multiply <TT><font color="#CC0000">$n</font color="#CC0000"></TT> times
<TT><font color="#CC0000">55</font color="#CC0000"></TT> to find out which byte position we want. (Note
that the record numbers are thus zero-based; record zero is at the
beginning of the file.)
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[9]</A></sup> Actually, the
third parameter is the "whence" parameter. You can use a
different value than zero if you want to seek to a position relative
to the current position, or relative to the end of the file; see the
<span class="docEmphasis">perlfunc</span>manpage for more
information. Most people will simply want to use zero here.</p></blockquote>

<P class="docText">Once the file pointer has been positioned with
<TT><font color="#CC0000">seek</font color="#CC0000"></TT>, the next input or output operation will
start at that position.
</P>

<P class="docText">When we're ready to read from the file, we can't use the
ordinary line-input operator because that's made to read lines,
not 55-byte records. There may not be a newline character in this
entire file, or it may appear in packed data in the middle of a
record. Instead, we'll use the
<TT><font color="#CC0000">read</font color="#CC0000"></TT><A NAME="IXT-16-336579"></A> function:
</P>

<PRE><font color="#CC0000">my $buf;  # The input buffer variable
my $number_read = read(FRED, $buf, 55);</font color="#CC0000"></PRE>

<P class="docText">As you can see, the first parameter to <TT><font color="#CC0000">read</font color="#CC0000"></TT> is
the filehandle. The second parameter is a buffer variable; the data
read will be placed into this variable. (Yes, this is an odd way to
get the result.) The third parameter is the number of bytes to read;
here we've asked for 55 bytes, since that's the size of
our record. Normally, you can expect the length of
<TT><font color="#CC0000">$buf</font color="#CC0000"></TT> to be the specified number of bytes, and you
can expect that the return value (in <TT><font color="#CC0000">$number_read</font color="#CC0000"></TT>)
to be the same. But if your current position in the file is only five
bytes from the end when you request 55 bytes, you'll get only
five. Under normal circumstances, you'll get as many bytes as
you ask for.
</P>

<P class="docText">Once you've got those 55 bytes, what can you do with them? You
can unpack them (using the format we previously designed) to get the
bowler's name and other information, of course:
</P>

<PRE><font color="#CC0000">my($name, $age, $score_1, $score_2, $score_3, $score_4, $score_5, $when)
  = unpack "a40 C I5 L", $buf;</font color="#CC0000"></PRE>

<P class="docText">Since we can read the information from the file with
<TT><font color="#CC0000">read</font color="#CC0000"></TT>, can you guess how we can write it back
into the file? Sorry, it's not <TT><font color="#CC0000">write</font color="#CC0000"></TT>; that
was a trick question.<sup class="docFootnote"><A class="docLink" HREF="#">[10]</A></sup> You already know the correct function, which is
<TT><font color="#CC0000">print</font color="#CC0000"></TT><A NAME="IXT-16-336580"></A>. But you have to be sure that the data
string is exactly the right size; if it's too large,
you'll overwrite the next record's data, but if
it's too small, leftover data in the current record may be
mixed with the new data. To ensure that the length is correct,
we'll use <TT><font color="#CC0000">pack</font color="#CC0000"></TT>. Let's say that Wilma
has just bowled a game and her new score is in
<TT><font color="#CC0000">$new_score</font color="#CC0000"></TT>. That will be the first of the five
most-recent scores we keep for her (<TT><font color="#CC0000">$score_5</font color="#CC0000"></TT>, as
the oldest one, will be discarded), and in place of
<TT><font color="#CC0000">$when</font color="#CC0000"></TT> (the timestamp of her previous game),
we'll store the current time from the <TT><font color="#CC0000">time</font color="#CC0000"></TT>
function:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[10]</A></sup> Perl actually does have a
<TT><font color="#CC0000">write</font color="#CC0000"></TT> function, but that is used with formats,
which are beyond the scope of this book. See the
<span class="docEmphasis">perlform</span>manpage.</p></blockquote>

<PRE><font color="#CC0000">print FRED pack("a40 C I5 L",
  $name, $age,
  $new_score, $score_1, $score_2, $score_3, $score_4,
  time);</font color="#CC0000"></PRE>

<P class="docText">On some systems, you'll have to use <TT><font color="#CC0000">seek</font color="#CC0000"></TT>
whenever you switch from reading to writing, even if the current
position in the file is already correct. It's not a bad idea,
then, to always use <TT><font color="#CC0000">seek</font color="#CC0000"></TT> right before reading or
printing.
</P>

<P class="docText">Rather than use the two constant values <TT><font color="#CC0000">"a40 C I5
L"</font color="#CC0000"></TT> and <TT><font color="#CC0000">55</font color="#CC0000"></TT> throughout the program, as
we've done here, it would generally be better to define them
just once near the top of the code. That way, if we ever need to
change the database format, we don't have to go searching
through our code for places where the number <TT><font color="#CC0000">55</font color="#CC0000"></TT>
appears. Here's one way you might define both of those values,
using the <TT><font color="#CC0000">length</font color="#CC0000"></TT><A NAME="IXT-16-336581"></A> function to determine the length of a
string so you won't have to count bytes:<A NAME="IXTR3-117"></A> <A NAME="IXTR3-118"></A>
</P>

<PRE><font color="#CC0000">my $pack_format = "a40 C I5 L";
my $pack_length = length pack($pack_format, "dummy data", 
  0, 1, 2, 3, 4, 5, 6);</font color="#CC0000"></PRE>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-16-SECT-4"></A>
<H3 class="docSection1Title">16.4 Variable-length (Text) Databases</H3>

<P class="docText"><A NAME="lperl3-IDXTERM-1060"></A> <A NAME="lperl3-IDXTERM-1061"></A> <A NAME="lperl3-IDXTERM-1062"></A>Many simple databases are merely text
files written in a format that allows a program to read and maintain
them. For example, a configuration file for some program might be a
text file, with one configuration parameter being set on each line.
Or maybe the file is a mailing list, with one name and address on
each line (probably with the components of the name and address
separated by tab characters).
</P>

<P class="docText">Updating text files is more difficult than it probably seems at
first. But that's only because we're used to seeing text
files rendered as pages (or screens) of text. If you could see the
file as it is written in the filesystem, the difficulty is more
apparent. Since we can't show you the file as it's
actually written without opening up a disk drive, here's our
rendition of a piece of a text file<sup class="docFootnote"><A class="docLink" HREF="#">[11]</A></sup>:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[11]</A></sup> Of course, the
real file wouldn't have lines at all; it's one long
stream of text. And the newline character should really be a
single-character code. But these differences don't hurt this as
an example.</p></blockquote>

<PRE><font color="#CC0000">He had bought a large map representing the sea,\n  Without the l
east vestige of land:\nAnd the crew were much pleased when they 
found it to be\n  A map they could all understand.\n\n"What's th
e good of Mercator's North Poles and Equators,\n  Tropics, Zones
, and Meridian Lines?"\nSo the Bellman would cry: and the crew w
ould reply\n  "They are merely conventional signs!\n\n"Other map
s are such shapes, with their islands and capes!\n  But we've go
t our brave Captain to thank:"\n(So the crew would protest) "tha
t he's bought us the best-\n  A perfect and absolute blank!"\n\n</font color="#CC0000"></PRE>

<P class="docText">If you had this file open in your text editor, it would be easy to
change a word, add a comma, or fix a misspelling. If your editor is
powerful enough, in fact, you could change the indentation of each
line with a single command. But the text file is a stream of bytes;
if you wanted to add even a single comma, the remainder of the text
file (possibly thousands or millions of bytes) would have to move
over to make room. Nearly every tiny change would mean lots of slow
copying operations on the file. So how can we edit the file
efficiently?
</P>

<P class="docText">The most common way of programmatically updating a text file is by
writing an entirely new file that looks similar to the old one, but
making whatever changes we need as we go along. As you'll see,
this technique gives nearly the same result as updating the file
itself, but it has some beneficial side effects as well.
</P>

<P class="docText">In this example, we've got hundreds of files with a similar
format. One of them is <I>fred03.dat</I>, and
it's full of lines like these:
</P>

<PRE><font color="#CC0000">Program name: granite
Author: Gilbert Bates
Company: RockSoft
Department: R&amp;D
Phone: +1 503 555-0095
Date: Tues March 9, 1999
Version: 2.1
Size: 21k
Status: Final beta</font color="#CC0000"></PRE>

<P class="docText">We need to fix this file so that it has some different information.
Here's roughly what this one should look like when we're
done:
</P>

<PRE><font color="#CC0000">Program name: granite
Author: Randal L. Schwartz
Company: RockSoft
Department: R&amp;D
Date: June 12, 2002 6:38 pm
Version: 2.1
Size: 21k
Status: Final beta</font color="#CC0000"></PRE>

<P class="docText">In short, we need to make three changes. The name of the
<TT><font color="#CC0000">Author</font color="#CC0000"></TT> should be changed; the
<TT><font color="#CC0000">Date</font color="#CC0000"></TT> should be updated to today's date, and
the <TT><font color="#CC0000">Phone</font color="#CC0000"></TT> should be removed completely. And we
have to make these changes in hundreds of similar files as well.
</P>

<P class="docText">Perl supports a way of in-place editing of
<A NAME="IXT-16-336582"></A>files with a little extra help from
the <A NAME="IXT-16-336583"></A>diamond operator
("<TT><font color="#CC0000">&lt;&gt;</font color="#CC0000"></TT>"). Here's a program
to do what we want, although it may not be obvious how it works at
first. This program's only new feature is the special variable
<TT><font color="#CC0000">$^I</font color="#CC0000"></TT>; ignore that for now, and we'll come
back to it:
</P>

<PRE><font color="#CC0000">#!/usr/bin/perl -w

use strict;

chomp(my $date = `date`);
@ARGV = glob "fred*.dat" or die "no files found";
$^I = ".bak";

while (&lt;&gt;) {
  s/^Author:.*/Author: Randal L. Schwartz/;
  s/^Phone:.*\n//;
  s/^Date:.*/Date: $date/;
  print;
}</font color="#CC0000"></PRE>

<P class="docText">Since we need today's date, the program starts by using the
system <I>date</I><A NAME="IXT-16-336584"></A> command. A better way to get the date
(in a slightly different format) would almost surely be to use
Perl's own
<TT><font color="#CC0000">localtime</font color="#CC0000"></TT><A NAME="IXT-16-336585"></A> function in a scalar context:
</P>

<PRE><font color="#CC0000">my $date = localtime;</font color="#CC0000"></PRE>

<P class="docText">To get the list of files for the diamond operator, we read them from
a glob. The next line sets <TT><font color="#CC0000">$^I</font color="#CC0000"></TT>, but keep ignoring
that for the moment.
</P>

<P class="docText">The main loop reads, updates, and prints one line at a time. (With
what you know so far, that means that all of the files' newly
modified contents will be dumped to your terminal, scrolling
furiously past your eyes, without the files being changed at all. But
stick with us.) Note that the second substitution can replace the
entire line containing the phone number with an empty
string—leaving not even a newline—so when that's
printed, nothing comes out, and it's as if the
<TT><font color="#CC0000">Phone</font color="#CC0000"></TT> never existed. Most input lines won't
match any of the three patterns, and those will be unchanged in the
output.
</P>

<P class="docText">So this result is close to what we want, except that we haven't
shown you how the updated information gets back out on to the disk.
The answer is in the variable
<TT><font color="#CC0000">$^I</font color="#CC0000"></TT><A NAME="IXT-16-336586"></A>. By default it's
<TT><font color="#CC0000">undef</font color="#CC0000"></TT>, and everything is normal. But when
it's set to some string, it makes the diamond operator
("<TT><font color="#CC0000">&lt;&gt;</font color="#CC0000"></TT>") even more magical than
usual.
</P>

<P class="docText">We already know about much of the diamond's magic—it will
automatically open and close a series of files for you, or read from
the standard-input stream if there aren't any filenames given.
But when there's a string in <TT><font color="#CC0000">$^I</font color="#CC0000"></TT>, that
string is used as a backup filename's extension. Let's
see that in action.
</P>

<P class="docText">Let's say it's time for the diamond to open our file
<I>fred03.dat</I>. It opens it like before, but now it
renames it, calling it <I>fred03.dat.bak</I>.<sup class="docFootnote"><A class="docLink" HREF="#">[12]</A></sup> We've
still got the same file open, but now it has a different name on the
disk. Next, the diamond creates a new file and gives it the name
<I>fred03.dat</I>. That's okay; we weren't
using that name any more. And now the diamond selects the new file as
the default for output, so that anything that we print will go into
that file.<sup class="docFootnote"><A class="docLink" HREF="#">[13]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[12]</A></sup> Some of the details of this procedure will vary on non-Unix
systems, but the end result should be nearly the same. See the
release notes for your port of Perl.</p></blockquote>
<blockquote><p class="docFootnote"><sup><A NAME="">[13]</A></sup> The diamond also tries to duplicate the
original file's permission and ownership settings as much as
possible; for example, if the old one was world-readable, the new one
should be, as well.</p></blockquote>

<P class="docText">So now the <TT><font color="#CC0000">while</font color="#CC0000"></TT> loop will read a line from the
old file, update that, and print it out to the new file. This program
can update hundreds of files in a few seconds on a typical machine.
Pretty powerful, huh?
</P>

<P class="docText">Once the program has finished, what does the user see? The user says,
"Ah, I see what happened! Perl edited my file
<I>fred03.dat</I>, making the changes I needed, and
saved me a copy of the original in the <A NAME="IXT-16-336587"></A>backup file
<I>fred03.dat.bak</I> just to be helpful!" But we
now know the truth: Perl didn't really edit any file. It made a
modified copy, said "Abracadabra!", and switched the
files around while we were watching sparks come out of the magic
wand. Tricky.
</P>

<P class="docText">Some folks use a <A NAME="IXT-16-336588"></A>
<A NAME="IXT-16-336589"></A>tilde
("<TT><font color="#CC0000">~</font color="#CC0000"></TT>") as the value for
<TT><font color="#CC0000">$^I</font color="#CC0000"></TT>, since that resembles what
<I>emacs</I> does for backup files. Another possible
value for <TT><font color="#CC0000">$^I</font color="#CC0000"></TT> is the empty string. This enables
in-place editing, but doesn't save the original data in a
backup file. But since a small typo in your pattern could wipe out
all of the old data, using the empty string is recommended only if
you want to find out how good your backup tapes are. It's easy
enough to delete the backup files when you're done. And when
something goes wrong and you need to rename the backup files to their
original names, you'll be glad that you know how to use Perl to
do that (see the multiple-file rename example in <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-13#lperl3-CHP-13">Chapter 13</A>).
</P>

<A NAME="lperl3-CHP-16-SECT-4.1"></A>
<H4 class="docSection2Title">16.4.1 In-place Editing from the Command Line</H4>

<P class="docText"><A NAME="IXT-16-336590"></A> <A NAME="IXT-16-336591"></A>A program like the example
from the previous section is fairly easy to write. But Larry decided
it wasn't easy enough.
</P>

<P class="docText">Imagine that you need to update hundreds of files that have the
misspelling <TT><font color="#CC0000">Randall</font color="#CC0000"></TT> instead of the
one-<TT><font color="#CC0000">l</font color="#CC0000"></TT> name <TT><font color="#CC0000">Randal</font color="#CC0000"></TT>. You could
write a program like the one in the previous section. Or you could do
it all with a one-line program, right on the command line:
</P>

<PRE><font color="#CC0000">$ <B>perl -p -i.bak -w -e 's/Randall/Randal/g' fred*.dat</B></font color="#CC0000"></PRE>

<P class="docText">Perl has a whole slew of command-line options that can be used to
build a complete program in a few keystrokes.<sup class="docFootnote"><A class="docLink" HREF="#">[14]</A></sup>
Let's see what these few do.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[14]</A></sup> See
the<A NAME="IXT-16-336592"></A> <span class="docEmphasis">perlrun</span>manpage for the complete list.</p></blockquote>

<P class="docText">Starting the command with <TT><font color="#CC0000">perl</font color="#CC0000"></TT> does something like
putting <TT><font color="#CC0000">#!/usr/bin/perl</font color="#CC0000"></TT> at the top of a file does:
it says to use the program <I>perl</I> to process what
follows.
</P>

<P class="docText">The <TT><font color="#CC0000">-p</font color="#CC0000"></TT><A NAME="IXT-16-336593"></A> option tells Perl to write a program for
you. It's not much of a program, though; it looks something
like this:<sup class="docFootnote"><A class="docLink" HREF="#">[15]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[15]</A></sup> Actually, the <TT><font color="#CC0000">print</font color="#CC0000"></TT>
occurs in a <TT><font color="#CC0000">continue</font color="#CC0000"></TT> block. See the
<span class="docEmphasis">perlsyn</span>and
<span class="docEmphasis">perlrun</span>manpages for more
information.</p></blockquote>

<PRE><font color="#CC0000">while (&lt;&gt;) { print; }. </font color="#CC0000"></PRE>

<P class="docText">If you want even less, you could use
<TT><font color="#CC0000">-n</font color="#CC0000"></TT><A NAME="IXT-16-336594"></A> instead; that leaves out the
<TT><font color="#CC0000">print</font color="#CC0000"></TT> statement. (Fans of <I>awk</I>
will recognize <TT><font color="#CC0000">-p</font color="#CC0000"></TT> and <TT><font color="#CC0000">-n</font color="#CC0000"></TT>.)
Again, it's not much of a program, but it's pretty good
for the price of a few keystrokes.
</P>

<P class="docText">The next option is
<TT><font color="#CC0000">-i.bak</font color="#CC0000"></TT><A NAME="IXT-16-336595"></A>, which you might have guessed sets
<TT><font color="#CC0000">$^I</font color="#CC0000"></TT> to <TT><font color="#CC0000">".bak"</font color="#CC0000"></TT> before the
program starts. If you don't want a backup file, you can use
<TT><font color="#CC0000">-i</font color="#CC0000"></TT> alone, with no extension.
</P>

<P class="docText">We've seen <TT><font color="#CC0000">-w</font color="#CC0000"></TT><A NAME="IXT-16-336596"></A> before—it turns on warnings.
</P>

<P class="docText">The <TT><font color="#CC0000">-e</font color="#CC0000"></TT><A NAME="IXT-16-336597"></A> option says "executable code
follows." That means that the
<TT><font color="#CC0000">s/Randall/Randal/g</font color="#CC0000"></TT> string is treated as Perl code.
Since we've already got a <TT><font color="#CC0000">while</font color="#CC0000"></TT> loop (from
the <TT><font color="#CC0000">-p</font color="#CC0000"></TT> option), this code is put inside the loop,
before the <TT><font color="#CC0000">print</font color="#CC0000"></TT>. For technical reasons, the last
semicolon in the <TT><font color="#CC0000">-e</font color="#CC0000"></TT> code is optional. But if you
have more than one <TT><font color="#CC0000">-e</font color="#CC0000"></TT>, and thus more than one
chunk of code, only the semicolon at the end of the last one may
safely be omitted.
</P>

<P class="docText">The last command-line parameter is <TT><font color="#CC0000">fred*.dat</font color="#CC0000"></TT>,
which says that <TT><font color="#CC0000">@ARGV</font color="#CC0000"></TT> should hold the list of
filenames that match that glob. Put the pieces all together, and
it's as if we had written a program like this:
</P>

<PRE><font color="#CC0000">#!/usr/bin/perl -w

@ARGV = glob "fred*.dat";
$^I = ".bak";

while (&lt;&gt;) {
  s/Randall/Randal/g;
  print;
}</font color="#CC0000"></PRE>

<P class="docText">Compare this program to the one we used in the previous section.
It's pretty similar. These command-line options are pretty
handy, aren't they?<A NAME="IXTR3-119"></A> <A NAME="IXTR3-120"></A> <A NAME="IXTR3-121"></A>
</P>



<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-16-SECT-5"></A>
<H3 class="docSection1Title">16.5 Exercises</H3>

<P class="docText">These exercises are all related; it may be helpful to see what the
second and third should do before starting on the first. See <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-APP-A-SECT-15#lperl3-APP-A-SECT-15">Section A.15</A> for answers.
</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">[15] Make a program that will read through the
<I>perlfunc.pod</I> file looking for identifier names
on <TT><font color="#CC0000">=item</font color="#CC0000"></TT> lines (as in the similar exercise at the
end of <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-9#lperl3-CHP-9">Chapter 9</A>). The program should write a
database showing the <span class="docEmphasis">first</span> line number on which
each identifier appears. That is, if <TT><font color="#CC0000">fred</font color="#CC0000"></TT> was
mentioned on lines 23, 29, and 54, the value stored under the key
<TT><font color="#CC0000">fred</font color="#CC0000"></TT> would be 23. (Hint: the special
<TT><font color="#CC0000">$.</font color="#CC0000"></TT> variable gives the line number of the line that
was just read.)
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">[10] Make a program that will take a Perl function name on the
command line, and report what <TT><font color="#CC0000">=item</font color="#CC0000"></TT> line of the
<I>perlfunc.pod</I> file first mentions that function.
Your program should not have to read through a long file to get this
answer. What should your program do if the function name isn't
found?
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">[10] (Extra credit exercise.) Modify the program from the previous
exercise so that when the function is found in the database, your
program will launch your favorite pager program to view the
<I>perlfunc.pod</I> file at that line. (Hint: many
programs that can be used for viewing text files work like
<I>less</I> does, with a command line like <TT><font color="#CC0000">less
+1234</font color="#CC0000"></TT> <TT><font color="#CC0000"><I>filename</I></font color="#CC0000"></TT> to start viewing
the file at line 1234. Your favorite text editor may also support
this convention, which is also used by <I>more</I>,
<I>pico</I>, <I>vi</I>,
<I>emacs</I>, and <I>view</I>.)<A NAME="IXTR3-122"></A>
</P></span></LI>
</OL></span>

<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17"></A>

<H2 class="docChapterTitle">Chapter 17. Some Advanced Perl Techniques</H2>

<P class="docText"><A NAME="lperl3-IDXTERM-1083"></A>What we've put in the
rest of this book is the core of Perl, the part that every Perl user
should understand. But there are a few other techniques that, while
not obligatory, are still valuable tools to have in your toolbox.
We've gathered the most important of those for this chapter.
</P>

<P class="docText">Don't be misled by the title of the chapter, though; the
techniques here aren't especially more difficult to understand
than what we have elsewhere. They are "advanced" merely
in the sense that they aren't necessary for beginners. The
first time you read this book, you may want to skip (or skim) this
chapter so you can get right to using Perl. Come back to it a month
or two later, when you're ready to get even more out of Perl.
Consider this entire chapter a huge footnote<sup class="docFootnote"><A class="docLink" HREF="#">[1]</A></sup>.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[1]</A></sup> We
contemplated doing that in one of the drafts, but got firmly rejected
by O'Reilly's editors.</p></blockquote>


<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17-SECT-1"></A>
<H3 class="docSection1Title">17.1 Trapping Errors with eval</H3>

<P class="docText"><A NAME="lperl3-IDXTERM-1084"></A> <A NAME="lperl3-IDXTERM-1085"></A>Sometimes, your ordinary, everyday code
can cause a fatal error in your program. Each of these typical
statements could crash a program:
</P>

<PRE><font color="#CC0000">$barney = $fred / $dino;         # divide-by-zero error?

print "match\n" if /^($wilma)/;  # illegal regular expression error?

open CAVEMAN, $fred              # user-generated error from die?
  or die "Can't open file '$fred' for input: $!";</font color="#CC0000"></PRE>

<P class="docText">You could go to some trouble to catch some of these, but it's
hard to get them all. (How could you check the string
<TT><font color="#CC0000">$wilma</font color="#CC0000"></TT> from that example to ensure that it makes a
valid regular expression?) Fortunately, Perl provides a simple way to
catch fatal errors: wrap the code in an <TT><font color="#CC0000">eval</font color="#CC0000"></TT>
block:
</P>

<PRE><font color="#CC0000">eval { $barney = $fred / $dino } ;</font color="#CC0000"></PRE>

<P class="docText">Now, even if <TT><font color="#CC0000">$dino</font color="#CC0000"></TT> is zero, that line won't
crash the program. The <TT><font color="#CC0000">eval</font color="#CC0000"></TT> is actually an
expression (not a control structure, like <TT><font color="#CC0000">while</font color="#CC0000"></TT> or
<TT><font color="#CC0000">foreach</font color="#CC0000"></TT>) so that semicolon is required at the end
of the block.
</P>

<P class="docText">When a normally fatal error happens during the execution of an
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> block, the block is done running, but the
program doesn't crash. So that means that right after an
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> finishes, you'll be wanting to know
whether it exited normally or whether it caught a fatal error for
you. The answer is in the special <TT><font color="#CC0000">$@</font color="#CC0000"></TT> variable. If
the <TT><font color="#CC0000">eval</font color="#CC0000"></TT> caught a fatal error,
<TT><font color="#CC0000">$@</font color="#CC0000"></TT> will hold what would have been the
program's dying words, perhaps something like: <TT><font color="#CC0000">Illegal
division by zero at my_program line 12</font color="#CC0000"></TT>. If there was no
error, <TT><font color="#CC0000">$@</font color="#CC0000"></TT> will be empty. Of course, that means
that <TT><font color="#CC0000">$@</font color="#CC0000"></TT> is a useful Boolean (true/false) value,
true if there was an error, so you'll sometimes see code like
this after an <TT><font color="#CC0000">eval</font color="#CC0000"></TT> block:
</P>

<PRE><font color="#CC0000">print "An error occurred: $@" if $@;</font color="#CC0000"></PRE>

<P class="docText">The <TT><font color="#CC0000">eval</font color="#CC0000"></TT> block is a true block, so it makes a
new scope for lexical (<TT><font color="#CC0000">my</font color="#CC0000"></TT>) variables. This piece
of a program shows an <TT><font color="#CC0000">eval</font color="#CC0000"></TT> block hard at work:
</P>

<PRE><font color="#CC0000">foreach my $person (qw/ fred wilma betty barney dino pebbles /) {
  eval {
    open FILE, "&lt;$person"
      or die "Can't open file '$person': $!";

    my($total, $count);

    while (&lt;FILE&gt;) {
      $total += $_;
      $count++;
    }

    my $average = $total/$count;
    print "Average for file $person was $average\n";

    &amp;do_something($person, $average);
  };

  if ($@) {
    print "An error occurred ($@), continuing\n";
  }
}</font color="#CC0000"></PRE>

<P class="docText">How many possible fatal errors are being trapped here? If there is an
error in opening the file, that error is trapped. Calculating the
average may divide by zero, so that error is trapped. Even the call
to the mysteriously named <TT><font color="#CC0000">&amp;do_something</font color="#CC0000"></TT>
subroutine will be protected against fatal errors, because an
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> block traps any otherwise-fatal errors that
occur during the time that it's active. (This feature is handy
if you have to call a subroutine written by someone else, and you
don't know whether they've coded defensively enough to
avoid crashing your program.)
</P>

<P class="docText">If an error occurs during the processing of one of the files,
we'll get an error message, but the program will go on to the
next file without further complaint.
</P>

<P class="docText">You can nest <TT><font color="#CC0000">eval</font color="#CC0000"></TT> blocks inside other
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> blocks. The inner one traps errors while it
runs, keeping them from reaching the outer blocks. (Of course, after
the inner <TT><font color="#CC0000">eval</font color="#CC0000"></TT> finishes, if it caught an error,
you may wish to re-post the error by using <TT><font color="#CC0000">die</font color="#CC0000"></TT>,
thereby letting the outer <TT><font color="#CC0000">eval</font color="#CC0000"></TT> catch it.) An
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> block traps any errors that occur during
its execution, including errors that happen during subroutine calls
(as we saw in the example earlier).
</P>

<P class="docText">We mentioned earlier that the <TT><font color="#CC0000">eval</font color="#CC0000"></TT> is an
expression, which is why the trailing semicolon is needed after the
closing curly brace. But since it's an expression, it has a
return value. If there's no error, it's like a
subroutine: the return value is the last expression evaluated, or
it's returned early with an optional <TT><font color="#CC0000">return</font color="#CC0000"></TT>
keyword. Here's another way to do the math without having to
worry about divide-by-zero:
</P>

<PRE><font color="#CC0000">my $barney = eval { $fred / $dino };</font color="#CC0000"></PRE>

<P class="docText">If the <TT><font color="#CC0000">eval</font color="#CC0000"></TT> traps a fatal error, the return
value is either <TT><font color="#CC0000">undef</font color="#CC0000"></TT> or an empty list, depending
upon the context. So in the previous example,
<TT><font color="#CC0000">$barney</font color="#CC0000"></TT> is either the correct result from
dividing, or it's <TT><font color="#CC0000">undef</font color="#CC0000"></TT>; we don't
really need to check <TT><font color="#CC0000">$@</font color="#CC0000"></TT> (although it's
probably a good idea to check <TT><font color="#CC0000">defined($barney)</font color="#CC0000"></TT>
before we use it further).
</P>

<P class="docText">There are four kinds of problems that <TT><font color="#CC0000">eval</font color="#CC0000"></TT>
can't trap. The first group are the very serious errors that
crash Perl itself, such as running out of memory or getting an
untrapped signal. Since Perl itself isn't running,
there's no way it can trap these errors.<sup class="docFootnote"><A class="docLink" HREF="#">[2]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[2]</A></sup> Some
of these errors are listed with an <TT><font color="#CC0000">(X)</font color="#CC0000"></TT> code on the
<span class="docEmphasis">perldiag</span><A NAME="IXT-17-336598"></A> manpage, if
you're curious.</p></blockquote>

<P class="docText">Of course, syntax errors inside the <TT><font color="#CC0000">eval</font color="#CC0000"></TT> block
are caught at compile time—they're never returned in
<TT><font color="#CC0000">$@</font color="#CC0000"></TT>.
</P>

<P class="docText">The <TT><font color="#CC0000">exit</font color="#CC0000"></TT> operator terminates the program at once,
even if it's called from a subroutine inside an
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> block. (This correctly implies that when
writing a subroutine, you should use <TT><font color="#CC0000">die</font color="#CC0000"></TT> rather
than <TT><font color="#CC0000">exit</font color="#CC0000"></TT> to signal when something goes wrong.)
</P>

<P class="docText">The fourth and final kind of problem that an
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> block can't trap are warnings, either
user-generated ones (from <TT><font color="#CC0000">warn</font color="#CC0000"></TT>) or Perl's
internally generated warnings (requested with the
<TT><font color="#CC0000">-w</font color="#CC0000"></TT> command-line option or the <TT><font color="#CC0000">use
warnings</font color="#CC0000"></TT> pragma). There's a separate mechanism from
<TT><font color="#CC0000">eval</font color="#CC0000"></TT> for trapping warnings; see the discussion of
the __<TT><font color="#CC0000">WARN</font color="#CC0000"></TT>__ pseudosignal in the Perl
documentation for the details.
</P>

<P class="docText">We should also mention that there's another form of
<TT><font color="#CC0000">eval</font color="#CC0000"></TT><A NAME="IXT-17-336599"></A> that
can be dangerous if it's mishandled. In fact, you'll
sometimes run across someone who will say that you shouldn't
use <TT><font color="#CC0000">eval</font color="#CC0000"></TT> in your code for security reasons.
They're (mostly) right that <TT><font color="#CC0000">eval</font color="#CC0000"></TT> should be
used only with great care, but they're talking about the
<span class="docEmphasis">other</span> form of <TT><font color="#CC0000">eval</font color="#CC0000"></TT>, sometimes
called "<TT><font color="#CC0000">eval</font color="#CC0000"></TT> of a string". If the
keyword <TT><font color="#CC0000">eval</font color="#CC0000"></TT> is followed directly by a block of
code in curly braces, as we're doing here, there's no
need to worry—that's the safe kind of
<TT><font color="#CC0000">eval</font color="#CC0000"></TT>.<A NAME="IXTR3-123"></A> <A NAME="IXTR3-124"></A> 
</P>


<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17-SECT-2"></A>
<H3 class="docSection1Title">17.2 Picking Items from a List with grep</H3>

<P class="docText">Sometimes you'll want only certain items from a list. Maybe
it's only the odd numbers selected from a list of numbers, or
maybe it's only the lines mentioning <TT><font color="#CC0000">Fred</font color="#CC0000"></TT>
from a file of text. As we'll see in this section, picking some
items from a list can be done simply with the
<A NAME="IXT-17-336600"></A><TT><font color="#CC0000">grep</font color="#CC0000"></TT>
operator.
</P>

<P class="docText">Let's try that first one and get the odd numbers from a large
list of numbers. We don't need anything new to do that:
</P>

<PRE><font color="#CC0000">my @odd_numbers;

foreach (1..1000) {
  push @odd_numbers, $_ if $_ % 2;
}</font color="#CC0000"></PRE>

<P class="docText">That code uses the <A NAME="IXT-17-336601"></A> <A NAME="IXT-17-336602"></A>modulus operator
(<TT><font color="#CC0000">%</font color="#CC0000"></TT>), which we saw in <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-2#lperl3-CHP-2">Chapter 2</A>.
If a number is even, that number "mod two" gives zero,
which is false. But an odd number will give one; since that's
true, only the odd numbers will be pushed onto the array.
</P>

<P class="docText">Now, there's nothing wrong with that code as it
stands—except that it's a little longer to write and
slower to run than it might be, since Perl provides the
<TT><font color="#CC0000">grep</font color="#CC0000"></TT> operator:
</P>

<PRE><font color="#CC0000">my @odd_numbers = grep { $_ % 2 } 1..1000;</font color="#CC0000"></PRE>

<P class="docText">That line gets a list of 500 odd numbers in one quick line of code.
How does it work? The first argument to <TT><font color="#CC0000">grep</font color="#CC0000"></TT> is a
block that uses <TT><font color="#CC0000">$_</font color="#CC0000"></TT> as a placeholder for each item
in the list, and returns a Boolean (true/false) value. The remaining
arguments are the list of items to search through. The
<TT><font color="#CC0000">grep</font color="#CC0000"></TT> operator will evaluate the expression once
for each item in the list, much as our original
<TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop did. For the ones where the last
expression of the block returns a true value, that element is
included in the list that results from <TT><font color="#CC0000">grep</font color="#CC0000"></TT>.
</P>

<P class="docText">While the <TT><font color="#CC0000">grep</font color="#CC0000"></TT> is running, <TT><font color="#CC0000">$_</font color="#CC0000"></TT>
is aliased to one element of the list after another. We've seen
this behavior before, in the <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop.
It's generally a bad idea to modify <TT><font color="#CC0000">$_</font color="#CC0000"></TT>
inside the <TT><font color="#CC0000">grep</font color="#CC0000"></TT> expression, because this will
damage the original data.
</P>

<P class="docText">The <TT><font color="#CC0000">grep</font color="#CC0000"></TT><A NAME="IXT-17-336603"></A> operator shares
its name with a classic Unix utility that picks matching lines from a
file by using regular expressions. We can do that with Perl's
<TT><font color="#CC0000">grep</font color="#CC0000"></TT>, which is much more powerful. Here we pull
only the lines mentioning <TT><font color="#CC0000">fred</font color="#CC0000"></TT> from a file:
</P>

<PRE><font color="#CC0000">my @matching_lines = grep { /\bfred\b/i } &lt;FILE&gt;;</font color="#CC0000"></PRE>

<P class="docText">There's a simpler syntax for <TT><font color="#CC0000">grep</font color="#CC0000"></TT>, too. If
all you need for the selector is a simple expression (rather than a
whole block), you can just use that expression, followed by a comma,
in place of the block. Here's the simpler way to write that
latest example:
</P>

<PRE><font color="#CC0000">my @matching_lines = grep /\bfred\b/i, &lt;FILE&gt;;</font color="#CC0000"></PRE>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17-SECT-3"></A>
<H3 class="docSection1Title">17.3 Transforming Items from a List with map</H3>

<P class="docText">Another common task is transforming items from a list. For example,
suppose you have a list of numbers that should be formatted as
<A NAME="IXT-17-336604"></A>"money
numbers" for
<A NAME="IXT-17-336605"></A>output, as with the subroutine
<TT><font color="#CC0000">&amp;big_money</font color="#CC0000"></TT> (from <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-15#lperl3-CHP-15">Chapter 15</A>). But we don't want to modify the
original data; we need a modified copy of the list just for output.
Here's one way to do that:
</P>

<PRE><font color="#CC0000">my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);
my @formatted_data;

foreach (@data) {
  push @formatted_data, &amp;big_money($_);
}</font color="#CC0000"></PRE>

<P class="docText">That looks similar in form to the example code used at the beginning
of the section on <TT><font color="#CC0000">grep</font color="#CC0000"></TT>, doesn't it? So it
may not surprise you that the replacement code resembles the first
<TT><font color="#CC0000">grep</font color="#CC0000"></TT> example:
</P>

<PRE><font color="#CC0000">my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);

my @formatted_data = map { &amp;big_money($_) } @data;</font color="#CC0000"></PRE>

<P class="docText">The <TT><font color="#CC0000">map</font color="#CC0000"></TT><A NAME="IXT-17-336606"></A> <A NAME="IXT-17-336607"></A> operator looks much like
<TT><font color="#CC0000">grep</font color="#CC0000"></TT> because it has the same kind of arguments: a
block that uses <TT><font color="#CC0000">$_</font color="#CC0000"></TT>, and a list of items to
process. And it operates in a similar way, evaluating the block once
for each item in the list, with <TT><font color="#CC0000">$_</font color="#CC0000"></TT> aliased to a
different original list element each time. But the last expression of
the block is used differently; instead of giving a Boolean value, the
final value actually becomes part of the resulting list.<sup class="docFootnote"><A class="docLink" HREF="#">[3]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[3]</A></sup> One other important difference is that the expression used by
<TT><font color="#CC0000">map</font color="#CC0000"></TT> is evaluated in a list context and may return
any number of items, not necessarily one each time.</p></blockquote>

<P class="docText">Any <TT><font color="#CC0000">grep</font color="#CC0000"></TT> or <TT><font color="#CC0000">map</font color="#CC0000"></TT> statement could
be rewritten as a <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop pushing items onto
a temporary array. But the shorter way is typically more efficient
and more convenient. Since the result of <TT><font color="#CC0000">map</font color="#CC0000"></TT> or
<TT><font color="#CC0000">grep</font color="#CC0000"></TT> is a list, it can be passed directly to
another function. Here we can print that list of formatted
"money numbers" as an indented list under a heading:
</P>

<PRE><font color="#CC0000">print "The money numbers are:\n",
  map { sprintf("%25s\n", $_) } @formatted_data;</font color="#CC0000"></PRE>

<P class="docText">Of course, we could have done that processing all at once, without
even the temporary array <TT><font color="#CC0000">@formatted_data</font color="#CC0000"></TT>:
</P>

<PRE><font color="#CC0000">my @data = (4.75, 1.5, 2, 1234, 6.9456, 12345678.9, 29.95);
print "The money numbers are:\n",
  map { sprintf("%25s\n", &amp;big_money($_) ) } @data;</font color="#CC0000"></PRE>

<P class="docText">As we saw with <TT><font color="#CC0000">grep</font color="#CC0000"></TT>, there's also a simpler
syntax for <TT><font color="#CC0000">map</font color="#CC0000"></TT>. If all you need for the selector
is a simple expression (rather than a whole block), you can just use
that expression, followed by a comma, in place of the block:
</P>

<PRE><font color="#CC0000">print "Some powers of two are:\n",
  map "\t" . ( 2 ** $_ ) . "\n", 0..15;</font color="#CC0000"></PRE>


<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17-SECT-4"></A>
<H3 class="docSection1Title">17.4 Unquoted Hash Keys</H3>

<P class="docText">Perl offers many shortcuts that can help the programmer. Here's
a handy one: you may omit the quote marks on some
<A NAME="IXT-17-336608"></A> <A NAME="IXT-17-336609"></A> <A NAME="IXT-17-336610"></A>hash keys.
</P>

<P class="docText">Of course, you can't omit the quote marks on just
<span class="docEmphasis">any</span> key, since a hash key may be any arbitrary
string. But keys are often simple. If the hash key is made up of
nothing but letters, digits, and underscores without starting with a
digit, you <span class="docEmphasis">may</span> be able to omit the quote marks.
This kind of simple string without quote marks is called a
<I>bareword</I><A NAME="IXT-17-336611"></A>,
since it stands alone without quotes.
</P>

<P class="docText">One place you are permitted to use this shortcut is the most common
place a hash key appears: in the curly braces of a hash element
reference. For example, instead of <TT><font color="#CC0000">$score{"fred"}</font color="#CC0000"></TT>,
you could write simply <TT><font color="#CC0000">$score{fred}</font color="#CC0000"></TT>. Since many
hash keys are simple like this, not using quotes is a real
convenience. But beware; if there's anything inside the curly
braces besides a bareword, Perl will interpret it as an expression.
</P>

<P class="docText">Another place where hash keys appear is when assigning an entire hash
using a list of key-value pairs. The <A NAME="IXT-17-336612"></A> <A NAME="IXT-17-336613"></A>
<A NAME="IXT-17-336614"></A>big arrow
(<TT><font color="#CC0000">=&gt;</font color="#CC0000"></TT>) is especially useful between a key and a
value, because (again, only if the key is a bareword) the big arrow
quotes it for you:
</P>

<PRE><font color="#CC0000"># Hash containing bowling scores
my %score = (
  barney   =&gt; 195,
  fred     =&gt; 205,
  dino     =&gt; 30,
);</font color="#CC0000"></PRE>

<P class="docText">This is the one important difference between the big arrow and a
comma; a bareword to the left of the big arrow is implicitly quoted.
(Whatever is on the right is left alone, though.) This feature of the
big arrow doesn't have to be used only for hashes, although
that's the most frequent use.
</P>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17-SECT-5"></A>
<H3 class="docSection1Title">17.5 More Powerful Regular Expressions</H3>

<P class="docText"><A NAME="lperl3-IDXTERM-1105"></A>After already reading three chapters
about regular expressions, you know that they're a powerful
feature in the core of Perl. But there are even more features that
the Perl developers have added; we'll see some of the most
important ones in this section. At the same time, you'll see a
little more about the internal operation of the
<A NAME="IXT-17-336615"></A>regular expression engine.
</P>

<A NAME="lperl3-CHP-17-SECT-5.1"></A>
<H4 class="docSection2Title">17.5.1 Non-greedy Quantifiers</H4>

<P class="docText"><A NAME="lperl3-IDXTERM-1107"></A>The
four quantifiers we've already seen (in <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-8#lperl3-CHP-8">Chapter 8</A>) are all <I>greedy</I>. That
means that they match as much as they can, only to reluctantly give
some back if that's necessary to allow the overall pattern to
succeed. Here's an example: Suppose you're using the
pattern <TT><font color="#CC0000">/fred.+barney/</font color="#CC0000"></TT> on the string
<TT><font color="#CC0000">fred</font color="#CC0000"></TT> <TT><font color="#CC0000">and barney went bowling last
night</font color="#CC0000"></TT>. Of course, we know that the regular expression will
match that string, but let's see how it goes about
it.<sup class="docFootnote"><A class="docLink" HREF="#">[4]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[4]</A></sup> The regular expression engine makes a few
optimizations that make the true story different than we tell it
here, and those optimizations change from one release of Perl to the
next. You shouldn't be able to tell from the functionality that
it's not doing as we say, though. If you want to know how it
really works, you should read the latest source code. Be sure to
submit patches for any bugs you find.</p></blockquote>

<P class="docText">First, of course, the subpattern <TT><font color="#CC0000">fred</font color="#CC0000"></TT> matches the
identical literal string. The next part of the pattern is the
<TT><font color="#CC0000">.+</font color="#CC0000"></TT>, which matches any character except newline, at
least one time. But the plus quantifier is greedy; it prefers to
match as much as possible. So it immediately matches all of the rest
of the string, including the word <TT><font color="#CC0000">night</font color="#CC0000"></TT>. (This may
surprise you, but the story isn't over yet.)
</P>

<P class="docText">Now the subpattern <TT><font color="#CC0000">barney</font color="#CC0000"></TT> would like to match, but
it can't—we're at the end of the string. But since
the <TT><font color="#CC0000">.+</font color="#CC0000"></TT> could still be successful even if it
matched one fewer character, it reluctantly gives back the letter
<TT><font color="#CC0000">t</font color="#CC0000"></TT> at the end of the string. (It's greedy,
but it wants the whole pattern to succeed even more than it wants to
match everything all by itself.)
</P>

<P class="docText">The subpattern <TT><font color="#CC0000">barney</font color="#CC0000"></TT> tries again to match, and
still can't. So the <TT><font color="#CC0000">.+</font color="#CC0000"></TT> gives back the letter
<TT><font color="#CC0000">h</font color="#CC0000"></TT> and lets it try again. One character after
another, the <TT><font color="#CC0000">.+</font color="#CC0000"></TT> gives back what it matched until
finally it gives up all of the letters of <TT><font color="#CC0000">barney</font color="#CC0000"></TT>.
Now, finally, the subpattern <TT><font color="#CC0000">barney</font color="#CC0000"></TT> can match, and
the overall match succeeds.
</P>

<P class="docText">Regular expression engines do a lot of backtracking like that, trying
every different way of fitting the pattern to the string until one of
them succeeds, or until none of them has.<sup class="docFootnote"><A class="docLink" HREF="#">[5]</A></sup> But as you could see from
this example, that can involve a lot of backtracking, as the
quantifier gobbles up too much of the string and has to be forced to
return some of it.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[5]</A></sup> In fact,
some regular expression engines try every different way, even
continuing on <span class="docEmphasis">after</span> they find one that fits. But
Perl's regular expression engine is primarily interested in
whether the pattern can or cannot match, so finding even one match
means that the engine's work is done. Again, see Jeffrey
Friedl's <A NAME="IXT-17-336616"></A><span class="docEmphasis">Mastering Regular
Expressions</span>.</p></blockquote>

<P class="docText">For each of the greedy quantifiers, though, there's also a
non-greedy quantifier available. Instead of the plus
(<TT><font color="#CC0000">+</font color="#CC0000"></TT>), we can use the non-greedy quantifier
<TT><font color="#CC0000">+?</font color="#CC0000"></TT>, which matches one or more times (just as the
plus does), except that it prefers to match as few times as possible,
rather than as many as possible. Let's see how that new
quantifier works when the pattern is rewritten as
<TT><font color="#CC0000">/fred.+?barney/</font color="#CC0000"></TT>.
</P>

<P class="docText">Once again, <TT><font color="#CC0000">fred</font color="#CC0000"></TT> matches right at the start. But
this time the next part of the pattern is <TT><font color="#CC0000">.+?</font color="#CC0000"></TT>,
which would prefer to match no more than one character, so it matches
just the space after <TT><font color="#CC0000">fred</font color="#CC0000"></TT>. The next subpattern is
<TT><font color="#CC0000">barney</font color="#CC0000"></TT>, but that can't match here (since the
string at the current position begins with <TT><font color="#CC0000">and
barney</font color="#CC0000"></TT>...). So the <TT><font color="#CC0000">.+?</font color="#CC0000"></TT> reluctantly
matches the <TT><font color="#CC0000">a</font color="#CC0000"></TT> and lets the rest of the pattern try
again. Once again, <TT><font color="#CC0000">barney</font color="#CC0000"></TT> can't match, so
the <TT><font color="#CC0000">.+?</font color="#CC0000"></TT> accepts the letter <TT><font color="#CC0000">n</font color="#CC0000"></TT>
and so on. Once the <TT><font color="#CC0000">.+?</font color="#CC0000"></TT> has matched five
characters, <TT><font color="#CC0000">barney</font color="#CC0000"></TT> can match, and the pattern is a
success.
</P>

<P class="docText">There was still some backtracking, but since the engine had to go
back and try again just a few times, it should be a big improvement
in speed. Well, it's an improvement if you'll generally
find <TT><font color="#CC0000">barney</font color="#CC0000"></TT> near <TT><font color="#CC0000">fred</font color="#CC0000"></TT>. If your
data often had <TT><font color="#CC0000">fred</font color="#CC0000"></TT> near the start of the string
and <TT><font color="#CC0000">barney</font color="#CC0000"></TT> only at the end, the greedy quantifier
might be a faster choice. In the end, the speed of the regular
expression depends upon the data.
</P>

<P class="docText">But the non-greedy quantifiers aren't just about efficiency.
Although they'll always match (or fail to match) the same
strings as their greedy counterparts, they may match different
amounts of the strings. For example, suppose you had some
HTML-like<sup class="docFootnote"><A class="docLink" HREF="#">[6]</A></sup> text, and you want to remove all of
the tags <TT><font color="#CC0000">&lt;BOLD&gt;</font color="#CC0000"></TT> and
<TT><font color="#CC0000">&lt;/BOLD&gt;</font color="#CC0000"></TT>, leaving their contents intact.
Here's the text:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[6]</A></sup> Once again, we aren't using real HTML
because you can't correctly parse HTML with simple regular
expressions. If you really need to work with HTML or a similar markup
language, use a module that's made to handle the
complexities.</p></blockquote>

<PRE><font color="#CC0000">I'm talking about the cartoon with Fred and &lt;BOLD&gt;Wilma&lt;/BOLD&gt;!</font color="#CC0000"></PRE>

<P class="docText">And here's a substitution to remove those tags. But
what's wrong with it?
</P>

<PRE><font color="#CC0000">s#&lt;BOLD&gt;(.*)&lt;/BOLD&gt;#$1#g;</font color="#CC0000"></PRE>

<P class="docText">The problem is that the star is greedy.<sup class="docFootnote"><A class="docLink" HREF="#">[7]</A></sup> What if the text had said this instead?
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[7]</A></sup> There's
another possible problem: we should have used the <TT><font color="#CC0000">/s</font color="#CC0000"></TT>
modifier as well, since the end tag may be on a different
line than the start tag. It's a good thing that this is just an
example; if we were writing something like this for real, we would
have taken our own advice and used a well-written module.</p></blockquote>

<PRE><font color="#CC0000">I thought you said Fred and &lt;BOLD&gt;Velma&lt;/BOLD&gt;, not &lt;BOLD&gt;Wilma&lt;/BOLD&gt;</font color="#CC0000"></PRE>

<P class="docText">In that case, the pattern would match from the first
<TT><font color="#CC0000">&lt;BOLD&gt;</font color="#CC0000"></TT> to the last
<TT><font color="#CC0000">&lt;/BOLD&gt;</font color="#CC0000"></TT>, leaving intact the ones in the
middle of the line. Oops! Instead, we want a non-greedy quantifier.
The non-greedy form of star is <TT><font color="#CC0000">*?</font color="#CC0000"></TT>, so the
substitution now looks like this:
</P>

<PRE><font color="#CC0000">s#&lt;BOLD&gt;(.*?)&lt;/BOLD&gt;#$1#g;</font color="#CC0000"></PRE>

<P class="docText">And it does the right thing. </P>

<P class="docText">Since the non-greedy form of the plus was <TT><font color="#CC0000">+?</font color="#CC0000"></TT> and
the non-greedy form of the star was <TT><font color="#CC0000">*?</font color="#CC0000"></TT>,
you've probably realized that the other two quantifiers look
similar. The non-greedy form of any curly-brace quantifier looks the
same, but with a question mark after the closing brace, like
<TT><font color="#CC0000">{5,10}?</font color="#CC0000"></TT> or <TT><font color="#CC0000">{8,}?</font color="#CC0000"></TT>.<sup class="docFootnote"><A class="docLink" HREF="#">[8]</A></sup> And
even the question-mark quantifier has a non-greedy form:
<TT><font color="#CC0000">??</font color="#CC0000"></TT>. That matches either once or not at all, but it
prefers not to match anything.<A NAME="IXTR3-125"></A> 
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[8]</A></sup> In theory, there's also a non-greedy quantifier form that
specifies an exact number, like <TT><font color="#CC0000">{3}?</font color="#CC0000"></TT>. But since
that says to match exactly three of the preceding item, it has no
flexibility to be either greedy or non-greedy.</p></blockquote>


<A NAME="lperl3-CHP-17-SECT-5.2"></A>
<H4 class="docSection2Title">17.5.2 Matching Multiple-line Text</H4>

<P class="docText">Classic regular expressions were used to match just single lines of
<A NAME="IXT-17-336617"></A>text. But since Perl can work with strings
of any length, Perl's patterns can match multiple lines of text
as easily as single lines. Of course, you have to include an
expression that holds more than one line of text. Here's a
string that's four lines long:
</P>

<PRE><font color="#CC0000">$_ = "I'm much better\nthan Barney is\nat bowling,\nWilma.\n";</font color="#CC0000"></PRE>

<P class="docText">Now, the
<A NAME="IXT-17-336618"></A>anchors <TT><font color="#CC0000">^</font color="#CC0000"></TT> and
<TT><font color="#CC0000">$</font color="#CC0000"></TT> are normally anchors for the start and end of
the whole string (see <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-8-SECT-3#lperl3-CHP-8-SECT-3">Section 8.3</A> in
<A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-8#lperl3-CHP-8">Chapter 8</A>). But the
<TT><font color="#CC0000">/m</font color="#CC0000"></TT><A NAME="IXT-17-336619"></A> regular expression option lets them
match at internal newlines as well (think <TT><font color="#CC0000">m</font color="#CC0000"></TT> for
multiple lines). This makes them anchors for the start and end of
each <span class="docEmphasis">line</span>, rather than the whole string. So this
pattern can match:
</P>

<PRE><font color="#CC0000">print "Found 'wilma' at start of line\n" if /^wilma\b/im;</font color="#CC0000"></PRE>

<P class="docText">Similarly, you could do a substitution on each line in a multiline
string. Here, we read an entire file into one variable,<sup class="docFootnote"><A class="docLink" HREF="#">[9]</A></sup> then add the file's name as a
prefix at the start of each line:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[9]</A></sup> Hope it's a small one. The file, that is, not the
variable.</p></blockquote>

<A NAME="IXTR3-126"></A><PRE><font color="#CC0000">open FILE, $filename
  or die "Can't open '$filename': $!";
my $lines = join '', &lt;FILE&gt;;
$lines =~ s/^/$filename: /gm;</font color="#CC0000"></PRE>



<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17-SECT-6"></A>
<H3 class="docSection1Title">17.6 Slices</H3>

<P class="docText"><A NAME="lperl3-IDXTERM-1113"></A>It often
happens that we need to work with only a few elements from a given
list. For example, the Bedrock Library keeps information about their
patrons in a large file.<sup class="docFootnote"><A class="docLink" HREF="#">[10]</A></sup> Each
line in the file describes one patron with six colon-separated
fields: a person's name, library card number, home address,
home phone number, work phone number, and number of items currently
checked out. A little bit of the file looks something like this:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[10]</A></sup> It should really be a
full-featured database rather than a flat file. They plan to upgrade
their system, right after the next Ice Age.</p></blockquote>

<PRE><font color="#CC0000">fred flintstone:2168:301 Cobblestone Way:555-1212:555-2121:3
barney rubble:709918:3128 Granite Blvd:555-3333:555-3438:0</font color="#CC0000"></PRE>

<P class="docText">One of the library's applications needs only the card numbers
and number of items checked out; it doesn't use any of the
other data. It could use code something like this to get only the
fields it needs:
</P>

<PRE><font color="#CC0000">while (&lt;FILE&gt;) {
  chomp;
  my @items = split /:/;
  my($card_num, $count) = ($items[1], $items[5]);
  ...  # now work with those two variables
}</font color="#CC0000"></PRE>

<P class="docText">But the array <TT><font color="#CC0000">@items</font color="#CC0000"></TT> isn't needed for
anything else; it seems like a waste.<sup class="docFootnote"><A class="docLink" HREF="#">[11]</A></sup>
Maybe it would be better to assign the result of
<TT><font color="#CC0000">split</font color="#CC0000"></TT><A NAME="IXT-17-336620"></A> to a list of scalars, like this:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[11]</A></sup> It's not
much of a waste, really. But stay with us. All of these techniques
are used by programmers who don't understand slices, so
it's worthwhile to see all of them here.</p></blockquote>

<PRE><font color="#CC0000">my($name, $card_num, $addr, $home, $work, $count) = split /:/;</font color="#CC0000"></PRE>

<P class="docText">Well, that avoids the unneeded array
<TT><font color="#CC0000">@items</font color="#CC0000"></TT>—but now we have four scalar variables
that we didn't really need. For this situation, some people
used to make up a number of dummy variable names, like
<TT><font color="#CC0000">$dummy_1</font color="#CC0000"></TT>, that showed that they really
didn't care about that element from the
<TT><font color="#CC0000">split</font color="#CC0000"></TT>. But Larry thought that that was too much
trouble, so he added a special use of
<TT><font color="#CC0000">undef</font color="#CC0000"></TT><A NAME="IXT-17-336621"></A>. If
an item in a list being assigned to is <TT><font color="#CC0000">undef</font color="#CC0000"></TT>, that
means simply to ignore the corresponding element of the source list:
</P>

<PRE><font color="#CC0000">my(undef, $card_num, undef, undef, undef, $count) = split /:/;</font color="#CC0000"></PRE>

<P class="docText">Is this any better? Well, it has an advantage that there aren't
any unneeded variables. But it has the disadvantage that you have to
count <TT><font color="#CC0000">undef</font color="#CC0000"></TT>s to tell which element is
<TT><font color="#CC0000">$count</font color="#CC0000"></TT>. And this becomes quite unwieldy if there
are more elements in the list. For example, some people who wanted
just the mtime value from <TT><font color="#CC0000">stat</font color="#CC0000"></TT> were writing code
like this:
</P>

<PRE><font color="#CC0000">my(undef, undef, undef, undef, undef, undef, undef, 
  undef, undef, $mtime) = stat $some_file;</font color="#CC0000"></PRE>

<P class="docText">If you use the wrong number of <TT><font color="#CC0000">undef</font color="#CC0000"></TT>s,
you'll get the atime or ctime by mistake, and that's a
tough one to debug. There's a better way: Perl can index into a
list as if it were an array. This is a <I>list
slice</I>. Here, since the mtime is item <TT><font color="#CC0000">9</font color="#CC0000"></TT>
in the list returned by <TT><font color="#CC0000">stat</font color="#CC0000"></TT>,<sup class="docFootnote"><A class="docLink" HREF="#">[12]</A></sup> we can
get it with a subscript:
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[12]</A></sup> It's the tenth item, but the index number is
<TT><font color="#CC0000">9</font color="#CC0000"></TT>, since the first item is at index
<TT><font color="#CC0000">0</font color="#CC0000"></TT>. This is the same kind of zero-based indexing
that we've used already with arrays.</p></blockquote>

<PRE><font color="#CC0000">my $mtime = (stat $some_file)[9];</font color="#CC0000"></PRE>

<P class="docText">Those parentheses are required around the list of items (in this
case, the return value from <TT><font color="#CC0000">stat</font color="#CC0000"></TT>). If you wrote it
like this, it wouldn't work:
</P>

<PRE><font color="#CC0000">my $mtime = stat($some_file)[9];  # Syntax error!</font color="#CC0000"></PRE>

<P class="docText">A list slice has to have a subscript expression in square brackets
after a list in parentheses. The parentheses holding the arguments to
a function call don't count.
</P>

<P class="docText">Going back to the Bedrock Library, the list we're working with
is the return value from <TT><font color="#CC0000">split</font color="#CC0000"></TT>. We can now use a
slice to pull out item <TT><font color="#CC0000">1</font color="#CC0000"></TT> and item
<TT><font color="#CC0000">5</font color="#CC0000"></TT> with subscripts:
</P>

<PRE><font color="#CC0000">my $card_num = (split /:/)[1];
my $count = (split /:/)[5];</font color="#CC0000"></PRE>

<P class="docText">Using a scalar-context slice like this (pulling just a single element
from the list) isn't bad, but it would be more efficient and
simpler if we didn't have to do the <TT><font color="#CC0000">split</font color="#CC0000"></TT>
twice. So let's not do it twice; let's get both values at
once by using a list slice in list context:
</P>

<PRE><font color="#CC0000">my($card_num, $count) = (split /:/)[1, 5];</font color="#CC0000"></PRE>

<P class="docText">The indices pull out element <TT><font color="#CC0000">1</font color="#CC0000"></TT> and element
<TT><font color="#CC0000">5</font color="#CC0000"></TT> from the list, returning those as a two-element
list. When that's assigned to the two <TT><font color="#CC0000">my</font color="#CC0000"></TT>
variables, we get exactly what we wanted. We do the
<TT><font color="#CC0000">slice</font color="#CC0000"></TT> just once, and we set the two variables with
a simple notation.
</P>

<P class="docText">A slice is often the simplest way to pull a few items from a list.
Here, we can pull just the first and last items from a list, using
the fact that index <TT><font color="#CC0000">-1</font color="#CC0000"></TT> means the last
element:<sup class="docFootnote"><A class="docLink" HREF="#">[13]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[13]</A></sup> Sorting a list merely to find the extreme
elements isn't likely to be the most efficient way. But
Perl's sort is fast enough that this is generally acceptable,
as long as the list doesn't have more than a few hundred
elements.</p></blockquote>

<PRE><font color="#CC0000">my($first, $last) = (sort @names)[0, -1];</font color="#CC0000"></PRE>

<P class="docText">The subscripts of a slice may be in any order and may even repeat
values. This example pulls five items from a list of ten:
</P>

<PRE><font color="#CC0000">my @names = qw{ zero one two three four five six seven eight nine };
my @numbers = ( @names )[ 9, 0, 2, 1, 0 ];
print "Bedrock @numbers\n";  # says Bedrock nine zero two one zero</font color="#CC0000"></PRE>

<A NAME="lperl3-CHP-17-SECT-6.1"></A>
<H4 class="docSection2Title">17.6.1 Array Slice</H4>

<P class="docText">That previous example could be made even simpler. When slicing
elements from an
<A NAME="IXT-17-336622"></A>array (as opposed to a list), the
parentheses aren't needed. So we could have done the slice like
this:
</P>

<PRE><font color="#CC0000">my @numbers = @names[ 9, 0, 2, 1, 0 ];</font color="#CC0000"></PRE>

<P class="docText">This isn't merely a matter of omitting the parentheses; this is
actually a different notation for accessing array elements: an
<I>array slice</I>. Earlier (in <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-3#lperl3-CHP-3">Chapter 3</A>), we said that the at-sign on
<TT><font color="#CC0000">@names</font color="#CC0000"></TT> meant "all of the elements."
Actually, in a linguistic sense, it's more like a plural
marker, much like the letter "s" in words like
"cats" and "dogs." In Perl, the dollar sign
means there's just one of something, but the at-sign means
there's a list of items.
</P>

<P class="docText">A slice is always a list, so the array slice notation uses an at-sign
to indicate that. When you see something like <TT><font color="#CC0000">@names[ ...
]</font color="#CC0000"></TT> in a Perl program, you'll need to do just as Perl
does and look at the at-sign at the beginning as well as the square
brackets at the end. The square brackets mean that you're
indexing into an array, and the at-sign means that you're
getting a whole list<sup class="docFootnote"><A class="docLink" HREF="#">[14]</A></sup>
of elements, not just a single one (which is what the dollar sign
would mean). See <A class="docLink" HREF="#lperl3-CHP-17-FIG-1">Figure 17-1</A>.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[14]</A></sup> Of course, when we say "a
whole list," that doesn't necessarily mean more elements
than one—the list could be empty, after all.</p></blockquote>

<CENTER>
<H5 class="docFigureTitle"><A NAME="lperl3-CHP-17-FIG-1"></A>Figure 17-1. Array slices versus single elements</H5>
<IMG BORDER="0" WIDTH="161" HEIGHT="191" SRC="lrnp_1701.gif" ALT="lrnp_1701.gif"></CENTER>

<P class="docText">The punctuation mark at the front of the variable reference (either
the dollar sign or at-sign) determines the context of the subscript
expression. If there's a dollar sign in front, the subscript
expression is evaluated in a scalar context to get an index. But if
there's an at-sign in front, the subscript expression is
evaluated in a list context to get a list of indices.
</P>

<P class="docText">So we see that <TT><font color="#CC0000">@names[ 2, 5 ]</font color="#CC0000"></TT> means the same list
as <TT><font color="#CC0000">($names[2],</font color="#CC0000"></TT> <TT><font color="#CC0000">$names[5])</font color="#CC0000"></TT> does.
If you want that list of values, you can simply use the array slice
notation. Any place you might want to write the list, you can instead
use the simpler array slice.
</P>

<P class="docText">But the slice can be used in one place where the list can't: a
slice may be interpolated directly into a string:
</P>

<PRE><font color="#CC0000">my @names = qw{ zero one two three four five six seven eight nine };
print "Bedrock @names[ 9, 0, 2, 1, 0 ]\n";</font color="#CC0000"></PRE>

<P class="docText">If we were to interpolate <TT><font color="#CC0000">@names</font color="#CC0000"></TT>, that would give
all of the items from the array, separated by spaces. If instead we
interpolate <TT><font color="#CC0000">@names[ 9, 0, 2, 1, 0 ]</font color="#CC0000"></TT>, that gives
just those items from the array, separated by spaces.<sup class="docFootnote"><A class="docLink" HREF="#">[15]</A></sup>
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[15]</A></sup> More accurately, the items of the list are separated by the
contents of Perl's <TT><font color="#CC0000">$"</font color="#CC0000"></TT> variable, whose
default is a space. This should not normally be changed. When
interpolating a list of values, Perl internally does <TT><font color="#CC0000">join
$", @list</font color="#CC0000"></TT>, where <TT><font color="#CC0000">@list</font color="#CC0000"></TT> stands in for the
list expression. </p></blockquote>

<P class="docText">Let's go back to the Bedrock Library for a moment. Maybe now
our program is updating Mr. Slate's address and phone number in
the patron file, because he just moved into a large new place in the
Hollyrock hills. If we've got a list of information about him
in <TT><font color="#CC0000">@items</font color="#CC0000"></TT>, we could do something like this to
update just those two elements of the array:
</P>

<PRE><font color="#CC0000">my $new_home_phone = "555-6099";
my $new_address = "99380 Red Rock West";
@items[2, 3] = ($new_address, $new_home_phone);</font color="#CC0000"></PRE>

<P class="docText">Once again, the array slice makes a more compact notation for a list
of elements. In this case, that last line is the same as an
assignment to <TT><font color="#CC0000">($items[2],</font color="#CC0000"></TT>
<TT><font color="#CC0000">$items[3])</font color="#CC0000"></TT>, but more compact and efficient.
</P>


<A NAME="lperl3-CHP-17-SECT-6.2"></A>
<H4 class="docSection2Title">17.6.2 Hash Slice</H4>

<P class="docText">In a way exactly analogous to an array slice, we can also slice some
elements from a <A NAME="IXT-17-336623"></A>hash in a <I>hash
slice</I>. Remember when three of our characters went
bowling, and we kept their bowling scores in the
<TT><font color="#CC0000">%score</font color="#CC0000"></TT> hash? We could pull those scores with a
list of hash elements or with a slice. These two techniques are
equivalent, although the second is more concise and efficient:
</P>

<PRE><font color="#CC0000">my @three_scores = ($score{"barney"}, $score{"fred"}, $score{"dino"});

my @three_scores = @score{ qw/ barney fred dino/ };</font color="#CC0000"></PRE>

<P class="docText">A slice is always a list, so the hash slice notation uses an at-sign
to indicate that.<sup class="docFootnote"><A class="docLink" HREF="#">[16]</A></sup> When you see something like <TT><font color="#CC0000">@score{ ...
}</font color="#CC0000"></TT> in a Perl program, you'll need to do just as Perl
does and look at the at-sign at the beginning as well as the curly
braces at the end. The curly braces mean that you're indexing
into a hash; the at-sign means that you're getting a whole list
of elements, not just a single one (which is what the dollar sign
would mean). See <A class="docLink" HREF="#lperl3-CHP-17-FIG-2">Figure 17-2</A>.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[16]</A></sup> If it sounds as if we're
repeating ourselves here, it's because we want to emphasize
that hash slices are analogous to array slices. If it sounds as if
we're not repeating ourselves here, it's because we want
to emphasize that hash slices are analogous to array slices. </p></blockquote>

<CENTER>
<H5 class="docFigureTitle"><A NAME="lperl3-CHP-17-FIG-2"></A>Figure 17-2. Hash slices versus single elements</H5>
<IMG BORDER="0" WIDTH="150" HEIGHT="191" SRC="lrnp_1702.gif" ALT="lrnp_1702.gif"></CENTER>

<P class="docText">As we saw with the array slice, the punctuation mark at the front of
the variable reference (either the dollar sign or at-sign) determines
the context of the subscript expression. If there's a dollar
sign in front, the subscript expression is evaluated in a scalar
context to get a single key.<sup class="docFootnote"><A class="docLink" HREF="#">[17]</A></sup> But if there's an at-sign in front, the
subscript expression is evaluated in a list context to get a list of
keys.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[17]</A></sup> There's an
exception you're not likely to run across, since it isn't
used much in modern Perl code. See the entry for
<TT><font color="#CC0000">$;</font color="#CC0000"></TT> in the <span class="docEmphasis">perlvar</span> manpage.
</p></blockquote>

<P class="docText">It's normal at this point to wonder why there's no
percent sign ("<TT><font color="#CC0000">%</font color="#CC0000"></TT>") here, when
we're talking about a hash. That's the marker that means
there's a whole hash; a hash slice (like any other slice) is
always a <span class="docEmphasis">list</span>, not a hash.<sup class="docFootnote"><A class="docLink" HREF="#">[18]</A></sup> In Perl, the dollar sign means
there's just one of something, but the at-sign means
there's a list of items, and the percent sign means
there's an entire hash.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[18]</A></sup> A
hash slice is a slice (not a hash) in the same way that a house fire
is a fire (not a house), while a fire house is a house (not a fire).
More or less.</p></blockquote>

<P class="docText">As we saw with array slices, a hash slice may be used instead of the
corresponding list of elements from the hash, anywhere within Perl.
So we can set our friends' bowling scores in the hash (without
disturbing any other elements in the hash) in this simple way:
</P>

<PRE><font color="#CC0000">my @players = qw/ barney fred dino /;
my @bowling_scores = (195, 205, 30);
@score{ @players } = @bowling_scores;</font color="#CC0000"></PRE>

<P class="docText">That last line does the same thing as if we had assigned to the
three-element list <TT><font color="#CC0000">($score{"barney"}, $score{"fred"},
$score{"dino"})</font color="#CC0000"></TT>.
</P>

<P class="docText">A hash slice may be interpolated, too. Here, we print out the scores
for our favorite bowlers:
</P>

<A NAME="IXTR3-127"></A><PRE><font color="#CC0000">print "Tonight's players were: @players\n";
print "Their scores were: @score{@players}\n";</font color="#CC0000"></PRE>



<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-CHP-17-SECT-7"></A>
<H3 class="docSection1Title">17.7 Exercise</H3>

<P class="docText">See <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-APP-A-SECT-16#lperl3-APP-A-SECT-16">Section A.16</A> for an answer to the following
exercise:
</P>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">[30] Make a program that reads a list of strings from a file, one
string per line, and then lets the user interactively enter patterns
that may match some of the strings. For each pattern, the program
should tell how many strings from the file matched, then which ones
those were. Don't re-read the file for each new pattern; keep
the strings in memory. The filename may be hard-coded in the file. If
a pattern is invalid (for example, if it has unmatched parentheses),
the program should simply report that error and let the user continue
trying patterns. When the user enters a blank line instead of a
pattern, the program should quit. (If you need a file full of
interesting strings to try matching, try the file
<I>sample_text</I> in the files you've surely
downloaded by now from the O'Reilly website; see the
Preface.)<A NAME="IXTR3-128"></A> 
</P></span></LI>
</OL></span>







<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A"></A>

<H2 class="docAppendixTitle">Appendix A. Exercise Answers</H2>

<P class="docText"><A NAME="lperl3-IDXTERM-1119"></A>
<A NAME="lperl3-IDXTERM-1120"></A>This appendix contains the answers to the
excerses that appear throughout the book.
</P>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-1"></A>
<H3 class="docSection1Title">A.1 Answers to Chapter 2 Exercises </H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">#!/usr/bin/perl -w
$pi = 3.141592654;
$circ = 2 * $pi * 12.5;
print "The circumference of a circle of radius 12.5 is $circ.\n";</font color="#CC0000"></PRE><P class="docList">As you see, we started this program with a typical
<TT><font color="#CC0000">#!</font color="#CC0000"></TT> line; your path to Perl may vary. We also
turned on warnings.
</P>
<P class="docList">The first real line of code sets the value of <TT><font color="#CC0000">$pi</font color="#CC0000"></TT>
to our value of <IMG BORDER="0" WIDTH="18" HEIGHT="15" SRC="U03C0.gif" ALT="U03C0.gif">. There are several reasons a good programmer
will prefer to use a constant<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> value like
this: it takes time to type <TT><font color="#CC0000">3.141592654</font color="#CC0000"></TT> into your
program if you ever need it more than once. It may be a mathematical
bug if you accidentally used <TT><font color="#CC0000">3.141592654</font color="#CC0000"></TT> in one
place and <TT><font color="#CC0000">3.14159</font color="#CC0000"></TT> in another. There's only
one line to check on to make sure you didn't accidentally type
<TT><font color="#CC0000">3.141952654</font color="#CC0000"></TT> and send your space probe to the wrong
planet. It's easier to type <TT><font color="#CC0000">$pi</font color="#CC0000"></TT> than <IMG BORDER="0" WIDTH="18" HEIGHT="15" SRC="U03C0.gif" ALT="U03C0.gif">,
especially if you don't have Unicode. And it will be easy to
maintain the program in case the value of <IMG BORDER="0" WIDTH="18" HEIGHT="15" SRC="U03C0.gif" ALT="U03C0.gif"> ever
changes.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> If you'd prefer a
more formal sort of constants, the <TT><font color="#CC0000">constant</font color="#CC0000"></TT> pragma
may be what you're looking for.</p></blockquote>  <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> It nearly did change by a legislative act in
the state of Indiana. <A class="docLink" target="_blank" HREF="http://www.urbanlegends.com/legal/pi_indiana.html">http://www.urbanlegends.com/legal/pi_indiana.html</A></p></blockquote>
<P class="docList">Next we calculate the circumference, storing it into
<TT><font color="#CC0000">$circ</font color="#CC0000"></TT>, and we print it out in a nice message. The
message ends with a newline character, because every line of a good
program's output should end with a newline. Without it, you
might end up with output looking something like this, depending upon
your shell's prompt:
</P>
<PRE><font color="#CC0000">The circumference of a circle of radius 12.5 is
78.53981635.bash-2.01$[]</font color="#CC0000"></PRE><P class="docList">The box represents the input cursor, blinking at the end of the line,
and that's the shell's prompt at the end of the
message.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> Since the
circumference isn't really
<TT><font color="#CC0000">78.53981635.bash-2.01$</font color="#CC0000"></TT>, this should probably be
construed as a bug. So use <TT><font color="#CC0000">\n</font color="#CC0000"></TT> at the end of each
line of output.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> We asked O'Reilly to spend the extra
money to print the input cursor with blinking ink, but they
wouldn't do it for us.</p></blockquote> </span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">#!/usr/bin/perl -w
$pi = 3.141592654;
print "What is the radius? ";
chomp($radius = &lt;STDIN&gt;);
$circ = 2 * $pi * $radius;
print "The circumference of a circle of radius $radius is $circ.\n";</font color="#CC0000"></PRE><P class="docList">This is just like the last one, except that now we ask the user for
the radius, and then we use <TT><font color="#CC0000">$radius</font color="#CC0000"></TT> in every place
where we previously used the hard-coded value
<TT><font color="#CC0000">12.5</font color="#CC0000"></TT>. If we had written the first program with
more foresight, in fact, we would have had a variable named
<TT><font color="#CC0000">$radius</font color="#CC0000"></TT> in that one as well. Note that we
<TT><font color="#CC0000">chomp</font color="#CC0000"></TT>ed the line of input. If we hadn't, the
mathematical formula would still have worked, because a string like
<TT><font color="#CC0000">"12.5\n"</font color="#CC0000"></TT> is converted to the number
<TT><font color="#CC0000">12.5</font color="#CC0000"></TT> without any problem. But when we print out
the message, it would look like this:
</P>
<PRE><font color="#CC0000">The circumference of a circle of radius 12.5
 is 78.53981635.</font color="#CC0000"></PRE><P class="docList">Notice that the newline character is still in
<TT><font color="#CC0000">$radius</font color="#CC0000"></TT>, even though we've used that
variable as a number. Since we had a space between
<TT><font color="#CC0000">$radius</font color="#CC0000"></TT> and the word
"<TT><font color="#CC0000">is</font color="#CC0000"></TT>" in the <TT><font color="#CC0000">print</font color="#CC0000"></TT>
statement, there's a space at the beginning of the second line
of output. The moral of the story is: <TT><font color="#CC0000">chomp</font color="#CC0000"></TT> your
input unless you have a reason not to do that.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">#!/usr/bin/perl -w
$pi = 3.141592654;
print "What is the radius? ";
chomp($radius = &lt;STDIN&gt;);
$circ = 2 * $pi * $radius;
if ($radius &lt; 0) {
  $circ = 0;
}
print "The circumference of a circle of radius $radius is $circ.\n";</font color="#CC0000"></PRE><P class="docList">Here we added the check for a bogus radius. Even if the given radius
was impossible, the returned circumference will at least be
nonnegative. You could have changed the given radius to be zero, and
then calculated the circumference, too; there's more than one
way to do it. In fact, that's the Perl motto: There Is More
Than One Way To Do It. And that's why each exercise answer
starts with "Here's one way to do it."
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "Enter first number: ";
chomp($one = &lt;STDIN&gt;);
print "Enter second number: ";
chomp($two = &lt;STDIN&gt;);
$result = $one * $two;
print "The result is $result.\n";</font color="#CC0000"></PRE><P class="docList">Notice that we've left off the <TT><font color="#CC0000">#!</font color="#CC0000"></TT> line for
this answer. In fact, from here on, we'll assume that you know
it's there, so you don't need to read it each time.
</P>
<P class="docList">Perhaps those are poor choices for variable names. In a large
program, a maintenance programmer might think that
<TT><font color="#CC0000">$two</font color="#CC0000"></TT> should have the value of
<TT><font color="#CC0000">2</font color="#CC0000"></TT>. In this short program, it probably
doesn't matter, but in a large one we could have called them
something more descriptive, with names like
<TT><font color="#CC0000">$first_response</font color="#CC0000"></TT>.
</P>
<P class="docList">In this program, it wouldn't make any difference if we forgot
to <TT><font color="#CC0000">chomp</font color="#CC0000"></TT> the two variables <TT><font color="#CC0000">$one</font color="#CC0000"></TT>
and <TT><font color="#CC0000">$two</font color="#CC0000"></TT>, since we never use them as strings once
they've been set. But if next week our maintenance programmer
edits the program to print a message like: <TT><font color="#CC0000">The result of
multiplying $one by $two is $result.\n</font color="#CC0000"></TT>, those pesky
newlines will come back to haunt us. Once again,
<TT><font color="#CC0000">chomp</font color="#CC0000"></TT> unless you have a reason not to
<TT><font color="#CC0000">chomp<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup></font color="#CC0000"></TT>—like in the next exercise.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> Chomping is like chewing—not
always needed, but most of the time it doesn't hurt.</p></blockquote>
</span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "Enter a string: ";
$str = &lt;STDIN&gt;;
print "Enter a number of times: ";
chomp($num = &lt;STDIN&gt;);
$result = $str x $num;
print "The result is:\n$result";</font color="#CC0000"></PRE><P class="docList">This program is almost the same as the last one, in a sense.
We're "multiplying" a string by a number of times.
So we've kept the structure of the previous exercise. In this
case, though, we didn't want to <TT><font color="#CC0000">chomp</font color="#CC0000"></TT> the
first input item—the string—because the exercise asked
for the strings to appear on separate lines. So, if the user entered
<TT><font color="#CC0000">fred</font color="#CC0000"></TT> and a newline for the string, and
<TT><font color="#CC0000">3</font color="#CC0000"></TT> for the number, we'd get a newline after
each <TT><font color="#CC0000">fred</font color="#CC0000"></TT> just as we wanted.
</P>
<P class="docList">In the <TT><font color="#CC0000">print</font color="#CC0000"></TT> statement at the end, we put the
newline before <TT><font color="#CC0000">$result</font color="#CC0000"></TT> because we wanted to have
the first <TT><font color="#CC0000">fred,</font color="#CC0000"></TT> printed on a line of its own. That
is, we didn't want output like this, with only two of the three
<TT><font color="#CC0000">fred</font color="#CC0000"></TT>s aligned in a column:
</P>
<PRE><font color="#CC0000">The result is: fred
fred
fred</font color="#CC0000"></PRE><P class="docList">At the same time, we didn't need to put another newline at the
end of the <TT><font color="#CC0000">print</font color="#CC0000"></TT> output because
<TT><font color="#CC0000">$result</font color="#CC0000"></TT> should already end with a newline.
</P>
<P class="docList">In most cases, Perl won't mind where you put spaces in your
program; you can put in spaces or leave them out. But it's
important not to accidentally spell the wrong thing! If the
<TT><font color="#CC0000">x</font color="#CC0000"></TT> runs up against the preceding variable name
<TT><font color="#CC0000">$str</font color="#CC0000"></TT>, Perl will see <TT><font color="#CC0000">$strx</font color="#CC0000"></TT>,
which won't work.
</P></span></LI>
</OL></span>

<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-2"></A>
<H3 class="docSection1Title">A.2 Answers to Chapter 3 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "Enter some lines, then press Ctrl-D:\n"; # or maybe Ctrl-Z
@lines = &lt;STDIN&gt;;
@reverse_lines = reverse @lines;
print @reverse_lines;</font color="#CC0000"></PRE><P class="docList">...or, even more simply:</P>
<PRE><font color="#CC0000">print "Enter some lines, then press Ctrl-D:\n";
print reverse &lt;STDIN&gt;;</font color="#CC0000"></PRE><P class="docList">Most Perl programmers would prefer the second one, as long as you
don't need to keep the list of lines around for later use.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">@names = qw/ fred betty barney dino wilma pebbles bamm-bamm /;
print "Enter some numbers from 1 to 7, one per line, then press Ctrl-D:\n";
chomp(@numbers = &lt;STDIN&gt;);
foreach (@numbers) {
  print "$names[ $_ - 1 ]\n";
}</font color="#CC0000"></PRE><P class="docList">We have to subtract one from the index number so that the user can
count from 1 to 7 even though the array is indexed from 0 to 6.
Another way to accomplish this would be to have a dummy item in the
<TT><font color="#CC0000">@names</font color="#CC0000"></TT> array, like this:
</P>
<PRE><font color="#CC0000">@names = qw/ dummy_item fred betty barney dino wilma pebbles bamm-bamm /;</font color="#CC0000"></PRE><P class="docList">Give yourself extra credit if you checked to make sure that the
user's choice of index was in fact in the range 1 to 7.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it, if you want the output all on one line:</P><PRE><font color="#CC0000">chomp(@lines = &lt;STDIN&gt;);
@sorted = sort @lines;
print "@sorted\n";</font color="#CC0000"></PRE><P class="docList">...or, to get the output on separate lines:</P>
<PRE><font color="#CC0000">print sort &lt;STDIN&gt;;</font color="#CC0000"></PRE></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-3"></A>
<H3 class="docSection1Title">A.3 Answers to Chapter 4 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">sub total {
  my $sum;  # private variable
  foreach (@_) {
    $sum += $_;
  }
  $sum;
}</font color="#CC0000"></PRE><P class="docList">This subroutine uses <TT><font color="#CC0000">$sum</font color="#CC0000"></TT> to keep a running total.
At the start of the subroutine, <TT><font color="#CC0000">$sum</font color="#CC0000"></TT> is
<TT><font color="#CC0000">undef</font color="#CC0000"></TT>, since it's a new variable. Then, the
<TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop steps through the parameter list
(from <TT><font color="#CC0000">@_</font color="#CC0000"></TT>), using <TT><font color="#CC0000">$_</font color="#CC0000"></TT> as the
control variable. (Note: once again, there's no automatic
connection between <TT><font color="#CC0000">@_</font color="#CC0000"></TT>, the parameter array, and
<TT><font color="#CC0000">$_</font color="#CC0000"></TT>, the default variable for the
<TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop.)
</P>
<P class="docList">The first time through the <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop, the first
number (in <TT><font color="#CC0000">$_</font color="#CC0000"></TT>) is added to
<TT><font color="#CC0000">$sum</font color="#CC0000"></TT>. Of course, <TT><font color="#CC0000">$sum</font color="#CC0000"></TT> is
<TT><font color="#CC0000">undef</font color="#CC0000"></TT>, since nothing has been stored in there. But
since we're using it as a number, which Perl sees because of
the numeric operator <TT><font color="#CC0000">+=</font color="#CC0000"></TT>, Perl acts as if
it's already initialized to <TT><font color="#CC0000">0</font color="#CC0000"></TT>. Perl thus
adds the first parameter to <TT><font color="#CC0000">0</font color="#CC0000"></TT>, and puts the total
back into <TT><font color="#CC0000">$sum</font color="#CC0000"></TT>.
</P>
<P class="docList">Next time through the loop, the next parameter is added to
<TT><font color="#CC0000">$sum</font color="#CC0000"></TT>, which is no longer <TT><font color="#CC0000">undef</font color="#CC0000"></TT>.
The sum is placed back into <TT><font color="#CC0000">$sum</font color="#CC0000"></TT>, and on through
the rest of the parameters. Finally, the last line returns
<TT><font color="#CC0000">$sum</font color="#CC0000"></TT> to the caller.
</P>
<P class="docList">There's a potential bug in this subroutine, depending upon how
you think of things. Suppose that this subroutine was called with an
empty parameter list (as we considered with the rewritten subroutine
<TT><font color="#CC0000">&amp;max</font color="#CC0000"></TT> in the chapter text). In that case,
<TT><font color="#CC0000">$sum</font color="#CC0000"></TT> would be <TT><font color="#CC0000">undef</font color="#CC0000"></TT>, and that
would be the return value. But in this subroutine, it would probably
be "more correct" to return <TT><font color="#CC0000">0</font color="#CC0000"></TT> as the
sum of the empty list, rather than <TT><font color="#CC0000">undef</font color="#CC0000"></TT>. (Of
course, if you wished to distinguish the sum of an empty list from
the sum of, say, <TT><font color="#CC0000">(3, -5, 2)</font color="#CC0000"></TT>, returning
<TT><font color="#CC0000">undef</font color="#CC0000"></TT> would be the right thing to do.)
</P>
<P class="docList">If you don't want a possibly undefined return value, though,
it's easy to remedy: simply initialize <TT><font color="#CC0000">$sum</font color="#CC0000"></TT>
to zero rather than using the default of <TT><font color="#CC0000">undef</font color="#CC0000"></TT>:
</P>
<PRE><font color="#CC0000">my $sum = 0;</font color="#CC0000"></PRE><P class="docList">Now the subroutine will always return a number, even if the parameter
list were empty.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000"># Remember to include &amp;total from previous exercise!
print "The numbers from 1 to 1000 add up to ", &amp;total(1..1000), ".\n";</font color="#CC0000"></PRE><P class="docList">Note that we can't call the subroutine from inside the
double-quoted string,<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> so the subroutine call is another separate item being
passed to <TT><font color="#CC0000">print</font color="#CC0000"></TT>. The total should be
<TT><font color="#CC0000">500500</font color="#CC0000"></TT>, a nice round number. And it
shouldn't take any noticeable time at all to run this program;
passing a parameter list of 1000 values is an everyday task for Perl.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> We can't do this without
advanced trickiness, that is. It's rare to find anything that
you <span class="docEmphasis">absolutely</span> can't do in Perl.</p></blockquote>
</span></LI>
</OL></span>

<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-4"></A>
<H3 class="docSection1Title">A.4 Answers to Chapter 5 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">my %last_name = qw{
  fred flintstone
  barney rubble
  wilma flintstone
};
print "Please enter a first name: ";
chomp(my $name = &lt;STDIN&gt;);
print "That's $name $last_name{$name}.\n";</font color="#CC0000"></PRE><P class="docList">In this one, we used a <TT><font color="#CC0000">qw//</font color="#CC0000"></TT> list (with curly
braces as the delimiter) to initialize the hash. That's fine
for this simple data set, and it's easy to maintain because
each data item is a simple given name and simple family name, with
nothing tricky. But if your data might contain spaces—for
example, if <TT><font color="#CC0000">robert</font color="#CC0000"></TT> <TT><font color="#CC0000">de niro</font color="#CC0000"></TT> or
<TT><font color="#CC0000">mary kay place</font color="#CC0000"></TT> were to visit Bedrock—this
simple method wouldn't work so well.
</P>
<P class="docList">You might have chosen to assign each key/value pair separately,
something like this:
</P>
<PRE><font color="#CC0000">my %last_name;
$last_name{"fred"} = "flintstone";
$last_name{"barney"} = "rubble";
$last_name{"wilma"} = "flintstone";</font color="#CC0000"></PRE><P class="docList">Note that (if you chose to declare the hash with
<TT><font color="#CC0000">my</font color="#CC0000"></TT>, perhaps because <TT><font color="#CC0000">use</font color="#CC0000"></TT>
<TT><font color="#CC0000">strict</font color="#CC0000"></TT> was in effect), you must declare the hash
before assigning any elements. You can't use
<TT><font color="#CC0000">my</font color="#CC0000"></TT> on only part of a variable, like this:
</P>
<PRE><font color="#CC0000">my $last_name{"fred"} = "flintstone";  # Oops!</font color="#CC0000"></PRE><P class="docList">The <TT><font color="#CC0000">my</font color="#CC0000"></TT> operator works only with
<span class="docEmphasis">entire</span> variables, never with just one element of
an array or hash. Speaking of lexical variables, you may have noticed
that the lexical variable <TT><font color="#CC0000">$name</font color="#CC0000"></TT> is being declared
inside of the <TT><font color="#CC0000">chomp</font color="#CC0000"></TT> function call; it is fairly
common to declare each <TT><font color="#CC0000">my</font color="#CC0000"></TT> variable as it is
needed, like this.
</P>
<P class="docList">This is another case where <TT><font color="#CC0000">chomp</font color="#CC0000"></TT> is vital. If
someone enters the five-character string <TT><font color="#CC0000">"fred\n"</font color="#CC0000"></TT>
and we fail to <TT><font color="#CC0000">chomp</font color="#CC0000"></TT> it, we'll be looking
for <TT><font color="#CC0000">"fred\n"</font color="#CC0000"></TT> as an element of the hash—and
it's not there. Of course, <TT><font color="#CC0000">chomp</font color="#CC0000"></TT> alone
won't make this bulletproof; if someone enters <TT><font color="#CC0000">"fred
\n"</font color="#CC0000"></TT> (with a trailing space), we don't have a way with
what we've seen so far to tell that they meant
<TT><font color="#CC0000">fred</font color="#CC0000"></TT>.
</P>
<P class="docList">If you added a check whether the given key <TT><font color="#CC0000">exists</font color="#CC0000"></TT>
in the hash, so that you'll give the user an explanatory
message when they misspell a name, give yourself extra points for
that.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">my(@words, %count, $word);     # (optionally) declare our variables
chomp(@words = &lt;STDIN&gt;);

foreach $word (@words) {
  $count{$word} += 1;          # or $count{$word} = $count{$word} + 1;
}

foreach $word (keys %count) {  # or sort keys %count
  print "$word was seen $count{$word} times.\n";
}</font color="#CC0000"></PRE><P class="docList">In this one, we declared all of the variables at the top. People who
come to Perl from a background in languages like Pascal (where
variables are always declared "at the top") may find that
way more familiar than declaring variables as they are needed. Of
course, we're declaring these because we're pretending
that <TT><font color="#CC0000">use strict</font color="#CC0000"></TT> may be in effect; by default, Perl
won't require such declarations.
</P>
<P class="docList">Next, we use the line-input operator,
<TT><font color="#CC0000">&lt;STDIN&gt;</font color="#CC0000"></TT>, in a list context to read all of
the input lines into <TT><font color="#CC0000">@words</font color="#CC0000"></TT>, and then we
<TT><font color="#CC0000">chomp</font color="#CC0000"></TT> those all at once. So
<TT><font color="#CC0000">@words</font color="#CC0000"></TT> is our list of words from the input (if the
words were all on separate lines, as they should have been, of
course).
</P>
<P class="docList">Now, the first foreach loop goes through all of the words. That loop
contains the most important statement of the entire program, the
statement that says to add one to <TT><font color="#CC0000">$count{$word}</font color="#CC0000"></TT>,
and put the result back into <TT><font color="#CC0000">$count{$word}</font color="#CC0000"></TT>.
Although you could write it either the short way (with the
<TT><font color="#CC0000">+=</font color="#CC0000"></TT> operator) or the long way, the short way is
just a little bit more efficient, since Perl has to look up
<TT><font color="#CC0000">$word</font color="#CC0000"></TT> in the hash just once.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> Also,
at least in some versions of Perl, the shorter way will avoid a
warning about using an undefined value that may crop up with the
longer one. The warning may also be avoided by using the <TT><font color="#CC0000">++</font color="#CC0000"></TT>
operator to increment the variable, although we
haven't shown you that operator yet.</p></blockquote> <P class="docList">For each word in the first <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop, we add
one to <TT><font color="#CC0000">$count{$word}</font color="#CC0000"></TT>. So, if the first word is
<TT><font color="#CC0000">fred</font color="#CC0000"></TT>, we add one to
<TT><font color="#CC0000">$count{"fred"}</font color="#CC0000"></TT>. Of course, since this is the first
time we've seen <TT><font color="#CC0000">$count{"fred"}</font color="#CC0000"></TT>, it's
<TT><font color="#CC0000">undef</font color="#CC0000"></TT>. But since we're treating it as a
number (with the numeric <TT><font color="#CC0000">+=</font color="#CC0000"></TT> operator, or with
<TT><font color="#CC0000">+</font color="#CC0000"></TT>, if you wrote it the long way), Perl converts
<TT><font color="#CC0000">undef</font color="#CC0000"></TT> to <TT><font color="#CC0000">0</font color="#CC0000"></TT> for us,
automatically. The total is <TT><font color="#CC0000">1</font color="#CC0000"></TT>, which is then
stored back into <TT><font color="#CC0000">$count{"fred"}</font color="#CC0000"></TT>.
</P>
<P class="docList">The next time through that <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop,
let's say the word is <TT><font color="#CC0000">barney</font color="#CC0000"></TT>. So, we add one
to <TT><font color="#CC0000">$count{"barney"}</font color="#CC0000"></TT>, bumping it up from
<TT><font color="#CC0000">undef</font color="#CC0000"></TT> to <TT><font color="#CC0000">1,</font color="#CC0000"></TT> as well.
</P>
<P class="docList">Now let's say the next word is <TT><font color="#CC0000">fred</font color="#CC0000"></TT> again.
When we add one to <TT><font color="#CC0000">$count{"fred"}</font color="#CC0000"></TT>, which is
already <TT><font color="#CC0000">1</font color="#CC0000"></TT>, we get <TT><font color="#CC0000">2</font color="#CC0000"></TT>. This goes
back into <TT><font color="#CC0000">$count{"fred"}</font color="#CC0000"></TT>, meaning that we've
now seen <TT><font color="#CC0000">fred</font color="#CC0000"></TT> twice.
</P>
<P class="docList">When we finish the first <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop, then,
we've counted how many times each word has appeared. The hash
has a key for each (unique) word from the input, and the
corresponding value is the number of times that word appeared.
</P>
<P class="docList">So now, the second <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop goes through the
keys of the hash, which are the unique words from the input. In this
loop, we'll see each <span class="docEmphasis">different</span> word once.
For each one, it says something like "<TT><font color="#CC0000">fred was seen 3
times.</font color="#CC0000"></TT>"
</P>
<P class="docList">If you want the extra credit on this problem, you could put
<TT><font color="#CC0000">sort</font color="#CC0000"></TT> before <TT><font color="#CC0000">keys</font color="#CC0000"></TT> to print out
the keys in order. If there will be more than a dozen items in an
output list, it's generally a good idea for them to be sorted,
so that a human being who is trying to debug the program will fairly
quickly be able to find the item he or she wants.
</P></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-5"></A>
<H3 class="docSection1Title">A.5 Answers to Chapter 6 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print reverse &lt;&gt;;</font color="#CC0000"></PRE><P class="docList">Well, that's pretty simple! But it works because
<TT><font color="#CC0000">print</font color="#CC0000"></TT> is looking for a list of strings to print,
which it gets by calling <TT><font color="#CC0000">reverse</font color="#CC0000"></TT> in a list
context. And <TT><font color="#CC0000">reverse</font color="#CC0000"></TT> is looking for a list of
strings to reverse, which it gets by using the diamond operator in
list context. So, the diamond returns a list of all of the lines from
all of the files of the user's choice. That list of lines is
just what <I>cat</I> would print out. Now
<TT><font color="#CC0000">reverse</font color="#CC0000"></TT> reverses the list of lines, and
<TT><font color="#CC0000">print</font color="#CC0000"></TT> prints them out.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "Enter some lines, then press Ctrl-D:\n";  # or Ctrl-Z
chomp(my @lines = &lt;STDIN&gt;);

print "1234567890" x 7, "12345\n";  # ruler line to column 75

foreach (@lines) {
  printf "%20s\n", $_;
}</font color="#CC0000"></PRE><P class="docList">Here, we start by reading in and chomping all of the lines of text.
Then we print the ruler line. Since that's a debugging aid,
we'd generally comment-out that line when the program is done.
We could have typed <TT><font color="#CC0000">"1234567890"</font color="#CC0000"></TT> again and again,
or even used copy-and-paste to make a ruler line as long as we
needed, but we chose to do it this way because it's kind of
cool.
</P>
<P class="docList">Now, the <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop iterates over the list of
lines, printing each one with the <TT><font color="#CC0000">%20s</font color="#CC0000"></TT> conversion.
If you chose to do so, you could have created a format to print the
list all at once, without the loop:
</P>
<PRE><font color="#CC0000">my $format = "%20s\n" x @lines;
printf $format, @lines;</font color="#CC0000"></PRE><P class="docList">It's a common mistake to get 19-character columns. That happens
when you say to yourself,<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> "Hey, why do we
<TT><font color="#CC0000">chomp</font color="#CC0000"></TT> the input if we're only going to add
the newlines back on later?" So you leave out the
<TT><font color="#CC0000">chomp</font color="#CC0000"></TT> and use a format of
<TT><font color="#CC0000">"%20s"</font color="#CC0000"></TT> (without a newline).<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> And now,
mysteriously, the output is off by one space. So, what went wrong?
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> Or to Larry, if he's
standing nearby.</p></blockquote>  <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> Unless
Larry told you not to do that.</p></blockquote> <P class="docList">The problem happens when Perl tries to count the spaces needed to
make the right number of columns. If the user enters
<TT><font color="#CC0000"><B>hello</B></font color="#CC0000"></TT> and a newline, Perl sees
<span class="docEmphasis">six</span> characters, not five, since newline is a
character. So it prints fourteen spaces and a six-character string,
sure that it gives the twenty characters you asked for in
<TT><font color="#CC0000">"%20s"</font color="#CC0000"></TT>. Oops.
</P>
<P class="docList">Of course, Perl isn't looking at the contents of the string to
determine the width; it merely checks the raw number of characters. A
newline (or another special character, such as a tab or a null
character) will throw things off.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> As Larry should
have explained to you by now.</p></blockquote> </span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "What column width would you like? ";
chomp(my $width = &lt;STDIN&gt;);

print "Enter some lines, then press Ctrl-D:\n";  # or Ctrl-Z
chomp(my @lines = &lt;STDIN&gt;);

print "1234567890" x (($width+9)/10), "\n";      # ruler line as needed

foreach (@lines) {
  printf "%${width}s\n", $_;
}</font color="#CC0000"></PRE><P class="docList">This is much like the previous one, but we ask for a column width
first. We ask for that first because we can't ask for more
input <span class="docEmphasis">after</span> the end-of-file indicator, at least
on some systems. Of course, in the real world, you'll generally
have a better end-of-input indicator when getting input from the
user, as we'll see in later chapters.
</P>
<P class="docList">Another change from the previous exercise's answer is the ruler
line. We used some math to cook up a ruler line that's at least
as long as we need, as suggested as an "extra credit"
part of the exercise. Proving that our math is correct is an
additional challenge. (Hint: Consider possible widths of
<TT><font color="#CC0000">50</font color="#CC0000"></TT> and <TT><font color="#CC0000">51</font color="#CC0000"></TT>, and remember that
the right side operand to <TT><font color="#CC0000">x</font color="#CC0000"></TT> is truncated, not
rounded.)
</P>
<P class="docList">To generate the format this time, we used the expression
<TT><font color="#CC0000">"%${width}s\n"</font color="#CC0000"></TT>, which interpolates
<TT><font color="#CC0000">$width</font color="#CC0000"></TT>. The curly braces are required to
"insulate" the name from the following
<TT><font color="#CC0000">s</font color="#CC0000"></TT>; without the curly braces, we'd be
interpolating <TT><font color="#CC0000">$widths</font color="#CC0000"></TT>, the wrong variable. If you
forgot how to use curly braces to do this, though, you could have
written an expression like <TT><font color="#CC0000">'%' . $width . "s\n"</font color="#CC0000"></TT> to
get the same format string.
</P>
<P class="docList">The value of <TT><font color="#CC0000">$width</font color="#CC0000"></TT> brings up another case where
<TT><font color="#CC0000">chomp</font color="#CC0000"></TT> is vital. If the width isn't
chomped, the resulting format string would resemble
<TT><font color="#CC0000">"%30\ns\n"</font color="#CC0000"></TT>. That's not useful.
</P>
<P class="docList">People who have seen <TT><font color="#CC0000">printf</font color="#CC0000"></TT> before may have
thought of another solution. Because <TT><font color="#CC0000">printf</font color="#CC0000"></TT>
comes to us from C, which doesn't have string interpolation, we
can use the same trick that C programmers use. If an asterisk
("<TT><font color="#CC0000">*</font color="#CC0000"></TT>") appears in place of a numeric
field width in a conversion, a value from the list of parameters will
be used:
</P>
<PRE><font color="#CC0000">printf "%*s\n", $width, $_;</font color="#CC0000"></PRE></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-6"></A>
<H3 class="docSection1Title">A.6 Answers to Chapter 7 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">/fred/</font color="#CC0000"></PRE><P class="docList">Of course, you have to put that into the test program! This is pretty
simple. The more important part of this exercise is trying it out on
the sample strings. It doesn't match <TT><font color="#CC0000">Fred</font color="#CC0000"></TT>,
showing that regular expressions are case-sensitive. (We'll see
how to change that later.) It does match <TT><font color="#CC0000">frederick</font color="#CC0000"></TT>
and <TT><font color="#CC0000">Alfred</font color="#CC0000"></TT>, since both of those strings contain
the four-letter string <TT><font color="#CC0000">fred</font color="#CC0000"></TT>.. (Matching whole
words only, so that <TT><font color="#CC0000">frederick</font color="#CC0000"></TT> and
<TT><font color="#CC0000">Alfred</font color="#CC0000"></TT> wouldn't match, is another feature
we'll see later.)
</P>
<P class="docList">If the test program is working correctly,<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> it should show those two
matches as something like <TT><font color="#CC0000">|&lt;fred&gt;erick|</font color="#CC0000"></TT> and
<TT><font color="#CC0000">|Al&lt;fred&gt;|</font color="#CC0000"></TT>, using the angle brackets to show
where <TT><font color="#CC0000">fred</font color="#CC0000"></TT> was found inside each string.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> If the test
program didn't work correctly, you probably didn't
download it as we suggested. And you probably didn't test what
you typed, as we also suggested. But in that case, you probably
didn't do the exercises either; you're just reading these
answers in the back of the book, and so the test program (which you
didn't actually run) performed flawlessly. In that case, this
footnote is pointless.</p></blockquote> </span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">/a+b*/</font color="#CC0000"></PRE><P class="docList">That matches the letter <TT><font color="#CC0000">a</font color="#CC0000"></TT> one or more times
(that's the plus), followed by <TT><font color="#CC0000">b</font color="#CC0000"></TT> zero or
more times (that's the star). Well, that's what the
exercise asked for, but you may have come up with something
different. After all, if you're looking for
<span class="docEmphasis">any</span> number of <TT><font color="#CC0000">b</font color="#CC0000"></TT>'s, you
know you'll always find what you're looking for. So you
could have written <TT><font color="#CC0000">/a+/</font color="#CC0000"></TT> instead, and matched the
same strings.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> To be sure, you'll match
different parts of the strings. But any string that matches
<TT><font color="#CC0000">/a+b*/</font color="#CC0000"></TT> will also match <TT><font color="#CC0000">/a+/</font color="#CC0000"></TT>,
and vice versa.</p></blockquote> <P class="docList">For that matter, when you want to match one or more
<TT><font color="#CC0000">a</font color="#CC0000"></TT>'s, you know that the match will succeed
when you find even the first one. So, <TT><font color="#CC0000">/a/</font color="#CC0000"></TT> will
match the same set of strings as the first two. The description
"any string containing at least one <TT><font color="#CC0000">a</font color="#CC0000"></TT>
followed by any number of <TT><font color="#CC0000">b</font color="#CC0000"></TT>'s" means
the exact same thing as "any string containing
<TT><font color="#CC0000">a</font color="#CC0000"></TT>." Of the sample strings, this matches all
of them except <TT><font color="#CC0000">fred</font color="#CC0000"></TT>.
</P>
<P class="docList">There are even more ways to make this pattern than we show here.
Often, in trying to write a pattern, you will need to decide which
one of many possible patterns best suits your needs.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">/\\*\**/</font color="#CC0000"></PRE><P class="docList">That's what the text asked for: a backslash (typed twice, since
we mean a <span class="docEmphasis">real</span> backslash<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>) zero or more times
(that's the first star), followed by an asterisk (backslashed,
since star is a metacharacter) zero or more times (that's the
last star). Whew!
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> Whenever you mean a real backslash in Perl, type two of them. A
lone backslash may try to do something magical, but two of them will
always mean a real backslash. </p></blockquote> <P class="docList">And what about the sample strings? Did it match any of them? You bet:
it matches all of them! It's because the backslashes and
asterisks aren't required in the pattern; that is, this pattern
can match the empty string. Here's a rule you can rely upon:
when a pattern <span class="docEmphasis">may</span> freely match the empty
string, it'll <span class="docEmphasis">always</span> match, since the
empty string can be found in any string. In fact, it'll always
match in the <span class="docEmphasis">first</span> place that you look.
</P>
<P class="docList">So, this pattern matches all four characters in
<TT><font color="#CC0000">\\**</font color="#CC0000"></TT>, as you'd expect. It matches the empty
string at the beginning of <TT><font color="#CC0000">fred</font color="#CC0000"></TT>, which you may not
have expected. In the string <TT><font color="#CC0000">barney \\\***</font color="#CC0000"></TT>, it
matches the empty string at the beginning. You might wish it would
hunt down the backslashes and stars at the end of that string, but it
doesn't bother. It looks at the beginning, sees zero
backslashes followed by zero asterisks, declares the match a success,
and goes home to watch television. And in <TT><font color="#CC0000">*wilma\</font color="#CC0000"></TT>,
it matches just the star at the beginning; as you see, this pattern
never gets away from the beginning of the string, since it always
matches at the first opportunity.
</P>
<P class="docList">Now, if someone asked you for a pattern to match any number of
backslashes followed by any number of asterisks, you'd be
technically correct to give them this one. But chances are,
that's not what they really wanted. Spoken languages like
English may be ambiguous and not say exactly what they mean, but
regular expressions always mean exactly what they say they mean.
</P>
<P class="docList">In this case, maybe the person who asked for the pattern forgot to
say that he or she always wants to match at least one character, when
the pattern matches at all. We can do that. If there's at least
one backslash, <TT><font color="#CC0000">/\\+\**/</font color="#CC0000"></TT> will match. (That's
just like what we had before, but there's a plus in place of
the first star, meaning one or more backslashes.) If there's
not at least one backslash, then in order to match at least one
character, we'll need at least one asterisk, so we want
<TT><font color="#CC0000">/\*+/</font color="#CC0000"></TT>. When you put those two possibilities
together, you get:
</P>
<PRE><font color="#CC0000">/\\+\**|\*+/</font color="#CC0000"></PRE><P class="docList">Ugly, isn't it? Regular expressions are powerful but not
beautiful. And they've contributed to Perl being maligned as a
"write-only language." To be sure that no one criticizes
your code in that way, though, it's kind to put an explanatory
comment near any pattern that's not obvious. On the other hand,
when you've been using these for a year, you will have a
different definition of "obvious" than you have today.
</P>
<P class="docList">How does this new pattern work with the sample strings? With
<TT><font color="#CC0000">\\**</font color="#CC0000"></TT>, it matches all four characters, just like
the last one. It won't match <TT><font color="#CC0000">fred</font color="#CC0000"></TT>, which is
probably the right behavior given the problem description. For
<TT><font color="#CC0000">barney \\\***</font color="#CC0000"></TT>, it matches the six characters at
the end, as you hoped. And for <TT><font color="#CC0000">*wilma\</font color="#CC0000"></TT>, it matches
the asterisk at the beginning.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">while (&lt;&gt;) {
  if (/wilma/) {
    print;
  }
}</font color="#CC0000"></PRE><P class="docList">This is a <I>grep</I>-like program. For each line of text
(contained in <TT><font color="#CC0000">$_</font color="#CC0000"></TT>), we check to see whether the
pattern matches. If it matches, we print it. This program uses
<TT><font color="#CC0000">print</font color="#CC0000"></TT>'s default: if you don't tell
it to print something else, it prints <TT><font color="#CC0000">$_</font color="#CC0000"></TT>. So we
have written a program that uses <TT><font color="#CC0000">$_</font color="#CC0000"></TT> all the way
through, but never mentions it anywhere. Perl folks love to use the
defaults and save time typing, so you'll see a lot of programs
that do this.
</P>
<P class="docList">And if, for extra credit, you wanted to match a capitalized
<TT><font color="#CC0000">Wilma</font color="#CC0000"></TT> as well, <TT><font color="#CC0000">/wilma|Wilma/</font color="#CC0000"></TT>
would do the job. Or, more simply, you could have written
<TT><font color="#CC0000">/(w|W)ilma/</font color="#CC0000"></TT>. People who have used other regular
expression implementations and already know about character classes,
which we'll discuss in the next chapter, could make that last
one even shorter (and more efficient).<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> If you made
the whole pattern case-insensitive, shame on you. We haven't
learned that yet. Besides, that would match <TT><font color="#CC0000">WILMA</font color="#CC0000"></TT>,
which shouldn't match, according to the exercise
description.</p></blockquote> </span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">while (&lt;&gt;) {
  if (/wilma/) {
    if (/fred/) {
      print;
    }
  }
}</font color="#CC0000"></PRE><P class="docList">This tests <TT><font color="#CC0000">/fred/</font color="#CC0000"></TT> only after we find
<TT><font color="#CC0000">/wilma/</font color="#CC0000"></TT> matches, but <TT><font color="#CC0000">fred</font color="#CC0000"></TT> could
appear before or after <TT><font color="#CC0000">wilma</font color="#CC0000"></TT> in the line; each
test is independent of the other.
</P>
<P class="docList">If you wanted to avoid the extra nested <TT><font color="#CC0000">if</font color="#CC0000"></TT> test,
you might have written something like this:<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> Folks who
know about the logical-and operator, which we saw in <A class="docLink" HREF="?xmlid=0-596-00132-0/lperl3-CHP-10#lperl3-CHP-10">Chapter 10</A>, could do both tests <TT><font color="#CC0000">/fred/</font color="#CC0000"></TT>
and <TT><font color="#CC0000">/wilma/</font color="#CC0000"></TT> in the same <TT><font color="#CC0000">if</font color="#CC0000"></TT>
conditional. That's more efficient, more scalable,
and an all-around better way than the ones given here. But we
haven't seen logical-and yet.</p></blockquote> <PRE><font color="#CC0000">while (&lt;&gt;) {
  if (/wilma.*fred|fred.*wilma/) {
    print;
  }
}</font color="#CC0000"></PRE><P class="docList">This works because we'll either have <TT><font color="#CC0000">wilma</font color="#CC0000"></TT>
before <TT><font color="#CC0000">fred</font color="#CC0000"></TT>, or <TT><font color="#CC0000">fred</font color="#CC0000"></TT> before
<TT><font color="#CC0000">wilma</font color="#CC0000"></TT>. If we had written just
<TT><font color="#CC0000">/wilma.*fred/</font color="#CC0000"></TT>, that wouldn't have matched a
line like <TT><font color="#CC0000">fred and wilma flintstone</font color="#CC0000"></TT>, even though
that line mentions both of them.
</P>
<P class="docList">We made this an extra-credit exercise because many folks have a
mental block here. We showed you an "or" operation (with
the vertical bar, "<TT><font color="#CC0000">|</font color="#CC0000"></TT>"), but we never
showed you an "and" operation. That's because there
isn't one in regular expressions.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> If you want to know whether one pattern and another are
both successful, just test both of them.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> But there are
some tricky and advanced ways of doing what some folks would call an
"and" operation. These are generally less efficient than
using Perl's logical-and, though, depending upon what
optimizations Perl and its regular expression engine can make.</p></blockquote>
</span></LI>
</OL></span>

<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-7"></A>
<H3 class="docSection1Title">A.7 Answers to Chapter 8 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">/\b(fred|wilma)\s+flintstone\b/</font color="#CC0000"></PRE><P class="docList">If you forgot to use the <TT><font color="#CC0000">\b</font color="#CC0000"></TT> word-boundary anchors,
take off half a point; without those, this would mistakenly match
strings like <TT><font color="#CC0000">alfred</font color="#CC0000"></TT>
<TT><font color="#CC0000">flintstones</font color="#CC0000"></TT>. The exercise description said to
match <span class="docEmphasis">words</span>.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">The point of this exercise may not be obvious, but in the real world,
you'll often have to do something similar. Someday,
you'll be unlucky enough to have a confusing program to
maintain, and you'll wonder what the author was trying to
accomplish.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> If you're especially unlucky, this
happens when you look at your own code ten minutes after writing
it.</p></blockquote> <P class="docList"><TT><font color="#CC0000">/"([^"]*)"/</font color="#CC0000"></TT> matches a simple string in double
quotes. By a "simple" string, we don't mean one
like Perl's double-quoted strings, which could contain a
backslashed double-quote mark or other backslash magic. This matches
just a double-quote mark, the contents of the string (which
can't contain a double quote), and a closing quote mark. The
contents may be empty. The parentheses aren't needed for
grouping, so they seem to be memory parentheses; as we'll see
in the next chapter, this regular expression memory, which holds the
quoted substring, is probably being saved for some later use. Perhaps
this pattern would be used in reading a configuration file with
quoted strings, although in that case it should probably use anchors.
</P>
<P class="docList"><TT><font color="#CC0000">/^0?[0-3]?[0-7]{1,2}$/</font color="#CC0000"></TT> matches if the string has
nothing but an octal number (perhaps with a leading zero) in the
range from <TT><font color="#CC0000">0</font color="#CC0000"></TT> through <TT><font color="#CC0000">0377</font color="#CC0000"></TT>. Note
that this one is anchored at both ends, so it doesn't allow
anything else in the string before or after the number. (The previous
pattern wasn't anchored; it could match anywhere in the
string.)
</P>
<P class="docList"><TT><font color="#CC0000">/^\b[\w.]{1,12}\b$/</font color="#CC0000"></TT> matches strings made up of
nothing but letters, digits, underscores, and dots, but never
starting or ending with a dot. Also, the strings are limited to a
maximum of 12 characters.
</P>
<P class="docList">You may have noticed that the dot inside the character class is not
special, so it doesn't need to be backslashed. That makes the
character class match ordinary letters, digits, and underscores, and
also dots.
</P>
<P class="docList">The way we can be sure that this one won't allow a string to
start or end with a dot is that it has both a word-boundary anchor
and a start-of-string or end-of-string anchor at each end of the
string. The word-boundary anchor can match only if there's a
"word" starting or ending there, and a dot can't be
part of a word.
</P>
<P class="docList">So, this would match strings like <TT><font color="#CC0000">perl.tar.gz</font color="#CC0000"></TT>, but
not <TT><font color="#CC0000">some_excessively_long_filename</font color="#CC0000"></TT> or
<TT><font color="#CC0000">perl.tar.</font color="#CC0000"></TT> or <TT><font color="#CC0000">.profile</font color="#CC0000"></TT> or
<TT><font color="#CC0000">..</font color="#CC0000"></TT>.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> This pattern could be useful for
validating user-chosen filenames.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> You may know that file and
directory names beginning with a dot are not displayed by default on
Unix systems, and that the special directory name <TT><font color="#CC0000">..</font color="#CC0000"></TT>
always means the directory one level higher in the
hierarchy.</p></blockquote> </span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">/^\$[A-Za-z_]\w*$/</font color="#CC0000"></PRE><P class="docList">The dollar sign at the start has to be backslashed to mean a real
dollar sign. What follows must be a letter or underscore, then zero
or more letters, digits, or underscores.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">This pattern is surprisingly tricky to get right. Here's how we
construct it, step by step.
</P><P class="docList">We start out by needing to match a word, so that's
<TT><font color="#CC0000">/\w+/</font color="#CC0000"></TT>. Of course, we want to remember that word
for later, so we add parentheses: <TT><font color="#CC0000">/(\w+)/</font color="#CC0000"></TT>. And we
want to match it when it occurs two or more times, so that's
<TT><font color="#CC0000">/(\w+)\1+/</font color="#CC0000"></TT>. (The plus sign at the end means
<span class="docEmphasis">one</span> or more times—but that's in
addition to the one time that the word occurred originally.)
</P>
<P class="docList">But we're not done yet. Now we need to allow for the whitespace
which may come between the words. We don't want to memorize the
whitespace (since it may vary), so we'll put it outside the
parentheses: <TT><font color="#CC0000">/(\w+)\s\1+/</font color="#CC0000"></TT>. Oh, but there could be
any number of whitespace characters, so long as there's at
least one, so we'll add a plus sign. So now we have
<TT><font color="#CC0000">/(\w+)\s+\1+/</font color="#CC0000"></TT>.
</P>
<P class="docList">But that's not right; the final plus sign is modifying the
backreference alone. We need it to apply to both the backreference
(that is, our repeated word) and the whitespace in front of it:
<TT><font color="#CC0000">/(\w+)(\s+\1)+/</font color="#CC0000"></TT>. So, now we can match a triple
word. First, the part in the first parenthesis pair matches the first
occurrence, then the part in the second parenthesis pair can twice
match some whitespace followed by that same word. When we try it out,
it matches all of our sentences with doubled words, so we happily put
it into our program and move on to the next project.
</P>
<P class="docList">Then, the next week, we get a bug report! The pattern reports a match
on the sentence <TT><font color="#CC0000">This is a test</font color="#CC0000"></TT>, even though
there's clearly no doubled word there. In moments, we've
fired up the pattern test program<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup>
to see what part of the string is matching: <TT><font color="#CC0000">|Th&lt;is is&gt;
a test|</font color="#CC0000"></TT>. There it is, a doubled word <TT><font color="#CC0000">is</font color="#CC0000"></TT>,
hidden in an ordinary string.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> We told you that it
would come in handy, and we weren't kidding.</p></blockquote> <P class="docList">Clearly, this is a job for a word boundary anchor; we can't
have our word start in the middle of another word. So we fix the
program to use <TT><font color="#CC0000">/\b(\w+)(\s+\1)+/</font color="#CC0000"></TT>, and sit back,
confident that we've got it right this time.
</P>
<P class="docList">And then, just when you got started on another project,
<span class="docEmphasis">another</span> bug report comes in. This time,
we've matched the doubled word <TT><font color="#CC0000">the</font color="#CC0000"></TT> in the
phrase <TT><font color="#CC0000">the</font color="#CC0000"></TT> <TT><font color="#CC0000">theory</font color="#CC0000"></TT>. Yes, we need
a word boundary at the <span class="docEmphasis">end</span> of the pattern to
keep from matching a partial word there:
<TT><font color="#CC0000">/\b(\w+)(\s+\1)+\b/</font color="#CC0000"></TT>. Now we've finally
gotten it right.
</P>
<P class="docList">What you've just read is a true story. The regular expression
has been changed, but the bug reports are real. It does happen, more
often than we'd like to admit, that even after you've
been writing these patterns for years, you can make a pattern which
has a bug, you can test it with a number of test cases, you can put
it into a long-running program, the Perl documentation, or even a
best-selling Perl book, and not realize that the bug is there until
much later.
</P>
<P class="docList">The moral of the story is that regular expressions can be
challenging. If you're serious about learning about regular
expressions, though (and all Perl programmers should be), we highly
recommend the book <span class="docEmphasis">Mastering Regular
Expressions</span>, by Jeffry Friedl (O'Reilly &amp;
Associates, Inc.).
</P></span></LI>
</OL></span>

<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-8"></A>
<H3 class="docSection1Title">A.8 Answers to Chapter 9 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">/($what){3}/</font color="#CC0000"></PRE><P class="docList">Once <TT><font color="#CC0000">$what</font color="#CC0000"></TT> has been interpolated, this gives a
pattern resembling <TT><font color="#CC0000">/(fred|barney){3}/</font color="#CC0000"></TT>. Without the
parentheses, the pattern would be something like
<TT><font color="#CC0000">/fred|barney{3}/</font color="#CC0000"></TT>, which is the same as
<TT><font color="#CC0000">/fred|barneyyy/</font color="#CC0000"></TT>. So, the parentheses are required.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">@ARGV = '/path/to/perlfunc.pod';  # or mentioned on the command line

while (&lt;&gt;) {
  if (/^=item\s+([a-z_]\w*)/i) {
    print "$1\n";                 # print out that identifier name
  }
}</font color="#CC0000"></PRE><P class="docList">With what we've shown you so far, the only way to open an
arbitrary file for input is to use the diamond operator (or to use
input redirection, perhaps). So we put the path to
<TT><font color="#CC0000">perlfunc.pod</font color="#CC0000"></TT> into <TT><font color="#CC0000">@ARGV</font color="#CC0000"></TT>.
</P>
<P class="docList">The heart of this program is the pattern, which looks for an
identifier name on an <TT><font color="#CC0000">=item</font color="#CC0000"></TT> line. The exercise
description was ambiguous, in that it didn't say whether
<TT><font color="#CC0000">=item</font color="#CC0000"></TT> had to be in lower case; the author of this
pattern seems to have decided that it should be a case-insensitive
pattern. If you interpreted it otherwise, you could have used the
pattern <TT><font color="#CC0000">/^=item\s+([a-zA-Z_]\w*)/</font color="#CC0000"></TT>.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">@ARGV = '/path/to/perlfunc.pod';  # or mentioned on the command line

my %seen;                         # (optionally) declaring the hash

while (&lt;&gt;) {
  if (/^=item\s+([a-z_]\w*)/i) {
    $seen{$1} += 1;               # a tally for each item
  }
}

foreach (sort keys %seen) {
  if ($seen{$_} &gt; 2) {            # more than twice
    print "$_ was seen $seen{$_} times.\n";
  }
}</font color="#CC0000"></PRE><P class="docList">This one starts out much like the previous one, but declares the hash
<TT><font color="#CC0000">%seen</font color="#CC0000"></TT> (in case <TT><font color="#CC0000">use strict</font color="#CC0000"></TT> might
be in effect). This is called <TT><font color="#CC0000">%seen</font color="#CC0000"></TT> because it
tells us which identifier names we've seen so far in the
program, and how many times. This is a common use of a hash. The
first loop now counts each identifier name, as an entry in
<TT><font color="#CC0000">%seen</font color="#CC0000"></TT>, instead of printing it out.
</P>
<P class="docList">The second loop goes through the keys of <TT><font color="#CC0000">%seen</font color="#CC0000"></TT>,
which are the different identifier names we've seen. It sorts
the list, which (although not specified in the exercise description)
is a courtesy to the user, who might otherwise have to search for the
desired item in a long list.
</P>
<P class="docList">Although it may not be obvious, this program is pretty close to a
real-world problem that most of us are likely to see. Imagine that
your webserver's 400-megabyte logfile has some information you
need. There's no way you're going to read that file on
your own; you'll want a program to match the information you
need (with a pattern) and then print it out in some nice report
format. Perl is good for putting together quick programs to do that
sort of thing.
</P></span></LI>
</OL></span>

<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-9"></A>
<H3 class="docSection1Title">A.9 Answer to Chapter 10 Exercise</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">my $secret = int(1 + rand 100);
# This next line may be un-commented during debugging
# print "Don't tell anyone, but the secret number is $secret.\n";

while (1) {
  print "Please enter a guess from 1 to 100: ";
  chomp(my $guess = &lt;STDIN&gt;);
  if ($guess =~ /quit|exit|^\s*$/i) {
    print "Sorry you gave up. The number was $secret.\n";
    last;
  } elsif ($guess &lt; $secret) {
    print "Too small. Try again!\n";
  } elsif ($guess == $secret) {
    print "That was it!\n";
    last;
  } else {
    print "Too large. Try again!\n";
  }
}</font color="#CC0000"></PRE><P class="docList">The first line picks out our secret number from <TT><font color="#CC0000">1</font color="#CC0000"></TT>
to <TT><font color="#CC0000">100</font color="#CC0000"></TT>. Here's how it works. First,
<TT><font color="#CC0000">rand</font color="#CC0000"></TT> is Perl's random number function, so
<TT><font color="#CC0000">rand 100</font color="#CC0000"></TT> gives us a random number in the range
from zero up to (but not including) <TT><font color="#CC0000">100</font color="#CC0000"></TT>. That is,
the largest possible value of that expression is something like
<TT><font color="#CC0000">99.999</font color="#CC0000"></TT>.<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> Adding one gives a number
from <TT><font color="#CC0000">1</font color="#CC0000"></TT> to <TT><font color="#CC0000">100.999</font color="#CC0000"></TT>, then the
<TT><font color="#CC0000">int</font color="#CC0000"></TT> function truncates that, giving a result from
<TT><font color="#CC0000">1</font color="#CC0000"></TT> to <TT><font color="#CC0000">100</font color="#CC0000"></TT>, as we needed.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> The actual largest
possible value depends upon your system; see <A class="docLink" target="_blank" HREF="http://www.cpan.org/doc/FMTEYEWTK/random">http://www.cpan.org/doc/FMTEYEWTK/random</A> if
you really need to know.</p></blockquote> <P class="docList">The commented-out line can be helpful during development and
debugging, or if you like to cheat. The main body of this program is
the infinite <TT><font color="#CC0000">while</font color="#CC0000"></TT> loop. That will keep asking for
guesses until we execute <TT><font color="#CC0000">last</font color="#CC0000"></TT>.
</P>
<P class="docList">It's important that we test the possible strings before the
numbers. If we didn't, do you see what would happen when the
user types <TT><font color="#CC0000">quit</font color="#CC0000"></TT>? That would be interpreted as a
number (probably giving a warning message, if warnings were turned
on), and since the value as a number would be zero, the poor user
would get the message that their guess was too small. We might never
get to the string tests, in that case.
</P>
<P class="docList">Another way to make the infinite loop here would be to use a naked
block with <TT><font color="#CC0000">redo</font color="#CC0000"></TT>. It's no more or less
efficient; merely another way to write it. Generally, if you expect
to mostly loop, it's good to write <TT><font color="#CC0000">while</font color="#CC0000"></TT>,
since that loops by default. If looping will be the exception, a
naked block may be a better choice.
</P></span></LI>
</OL></span>


<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-10"></A>
<H3 class="docSection1Title">A.10 Answers to Chapter 11 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">sub get_line { 
  # prompts for, reads, chomps, and returns a line of input
  print $_[0];
  chomp(my $line = &lt;STDIN&gt;);
  $line;
}

my $source = &amp;get_line("Which source file? ");
open IN, $source
  or die "Can't open '$source' for input: $!";

my $dest = &amp;get_line("What destination file? ");
die "Won't overwrite existing file"  
  if -e $dest;  # optional safety test
open OUT, "&gt;$dest"
  or die "Can't open '$dest' for output: $!";

my $pattern = &amp;get_line("What search pattern: ");
my $replace = &amp;get_line("What replacement string: ");

while (&lt;IN&gt;) {
  s/$pattern/$replace/g;
  print OUT $_;
}</font color="#CC0000"></PRE><P class="docList">This one needs to ask the user for several things, so we decided to
make a subroutine to take care of some of the work. The subroutine
prints out the prompt, which is the first (and only) parameter to the
subroutine. Then it reads a line of input, chomps it, and returns it.
That makes it easy to ask for each parameter, one after the other.
</P>
<P class="docList">Once we know what the user wants for the source file, we try opening
it. An earlier version of this program asked for all of the
parameters first, but if the source file name is incorrect,
there's no point in having the user type more parameters. This
way can save the user some time and trouble. Note that the die
message reports the file name inside quote marks; this can be helpful
in diagnosing a problem when a string has whitespace characters. If
you opened <TT><font color="#CC0000">"&lt;$source"</font color="#CC0000"></TT> instead of just plain
<TT><font color="#CC0000">$source</font color="#CC0000"></TT>, that's fine, too. (There's no
reason to worry that the user of this program will do something
nefarious, since anything they can do with this program, they could
accomplish just as well without it. If this program were made to run
over the web, to give one example, we'd need to be
<span class="docEmphasis">much</span> more cautious about opening the
user's choice of file.)
</P>
<P class="docList">As we hope you discovered when you tried it, it's easy to
overwrite an existing file simply by opening it for output. So we put
in a safety test using the <TT><font color="#CC0000">-e</font color="#CC0000"></TT> file test. The
corresponding die message doesn't include <TT><font color="#CC0000">$!</font color="#CC0000"></TT>
because we're not reporting a failed request of the system. By
the way, this test for overwrite is fine here, but it would be
insufficient in an environment where many copies of the same program
(or different programs all working with the same files) might be
running at once. This typically happens with programs on the web: Two
processes check the same filename for existence at approximately the
same time, and both see that it doesn't exist. So one of them
creates the file, and an instant later the other one overwrites it
with a file of its own. This kind of concurrency problem can't
be solved with the <TT><font color="#CC0000">-e</font color="#CC0000"></TT> file test; some kind of file
locking (which is beyond the scope of this book) is needed.
</P>
<P class="docList">With that safety test, the user won't accidentally overwrite an
existing file. Is that test a good idea? Well, if the user comes to
see you next week and says, "Golly, I'm glad you put in
that safety test. It kept me from accidentally overwriting my
file!", then you know that it was the right thing to do. But if
the user says, "Dagnabit, your program is hard to use! I told
it what filename I wanted to use for output, and it wouldn't
let me use it until I first deleted that file!", then it was
the wrong thing to do. Making decisions like this is often the
toughest part of a programmer's job. Perhaps we should make the
program ask something like, "Are you sure you want to overwrite
the existing file `barney'?" by default, but have a
command-line option for the power user that says to overwrite without
asking. Next version.
</P>
<P class="docList">Once we've asked for everything and opened the files, the rest
of the program is pretty simple. The heart of the program is the loop
at the end, which reads lines, updates them, and prints them out.
Note that the substitution uses the <TT><font color="#CC0000">/g</font color="#CC0000"></TT>
option—if you left that out, your program is broken, since the
exercise asked that the program replace <span class="docEmphasis">every</span>
occurrence of the search pattern, not just the first one on each
line.
</P>
<P class="docList">Were you able to use regular expression metacharacters in the search
pattern? Sure; the substitution interpolates
<TT><font color="#CC0000">$pattern</font color="#CC0000"></TT> to make the search pattern. Were you able
to use memory variables and backslash escapes in the replacement
string? Nope; <TT><font color="#CC0000">$replace</font color="#CC0000"></TT> is interpolated to make the
replacement string, but it's not
<span class="docEmphasis">re-</span>interpolated to interpret any magical
characters. If <TT><font color="#CC0000">$replace</font color="#CC0000"></TT> holds
<TT><font color="#CC0000">$1</font color="#CC0000"></TT>, that's a dollar sign and a numeral one
in the replacement string. If Perl always kept re-interpolating, you
could never put a dollar sign or backslash into the replacement
string, since they'd always make something magical happen.
(Actually, though, if you need one additional level of interpolation,
it is possible. See the <TT><font color="#CC0000">perlfaq</font color="#CC0000"></TT> manpages for some
suggestions on how to do this.)
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">foreach my $file (@ARGV) {
  my $attribs = &amp;attributes($file);
  print "'$file' $attribs.\n";
}

sub attributes {
  # report the attributes of a given file
  my $file = shift @_;
  return "does not exist" unless -e $file;

  my @attrib;
  push @attrib, "readable" if -r $file;
  push @attrib, "writable" if -w $file;
  push @attrib, "executable" if -x $file;
  return "exists" unless @attrib;
  'is ' . join " and ", @attrib;  # return value
}</font color="#CC0000"></PRE><P class="docList">In this one, once again it's convenient to use a subroutine.
The main loop prints one line of attributes for each file, perhaps
telling us that <TT><font color="#CC0000">'cereal-killer' is executable</font color="#CC0000"></TT> or
that <TT><font color="#CC0000">'sasquatch' does not exist</font color="#CC0000"></TT>.
</P>
<P class="docList">The subroutine tells us the attributes of the given filename. Of
course, if the file doesn't even exist, there's no need
for the other tests, so we test for that first. If there's no
file, we'll return early.
</P>
<P class="docList">If the file does exist, we'll build a list of attributes. (Give
yourself extra credit points if you used the special
<TT><font color="#CC0000">_</font color="#CC0000"></TT> filehandle instead of <TT><font color="#CC0000">$file</font color="#CC0000"></TT>
on these tests, to keep from calling the system separately for each
new attribute.) It would be easy to add additional tests like the
three we show here. But what happens if none of the attributes is
true? Well, if we can't say anything else, at least we can say
that the file exists, so we do. The <TT><font color="#CC0000">unless</font color="#CC0000"></TT> clause
uses the fact that <TT><font color="#CC0000">@attrib</font color="#CC0000"></TT> will be true (in a
Boolean context, which is a special case of a scalar context) if
it's got any elements.
</P>
<P class="docList">But if we've got some attributes, we'll join them with
<TT><font color="#CC0000">" and "</font color="#CC0000"></TT> and put <TT><font color="#CC0000">"is "</font color="#CC0000"></TT> in front,
to make a description like <TT><font color="#CC0000">is readable and
writable</font color="#CC0000"></TT>. This isn't perfect however; if there are
three attributes, it says that the file <TT><font color="#CC0000">is readable and
writable and executable</font color="#CC0000"></TT>, which has too many
<TT><font color="#CC0000">and</font color="#CC0000"></TT>s, but we can get away with it. If you wanted
to add more attributes to the ones this program checks for, you
should probably fix it to say something like <TT><font color="#CC0000">is readable,
writable, executable, and nonempty</font color="#CC0000"></TT>. If that matters to you.
</P>
<P class="docList">Note that if you somehow didn't put any filenames on the
command line, this produces no output. This makes sense; if you ask
for information on zero files, you should get zero lines of output.
But let's compare that to what the next program does in a
similar case, in the discussion below.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">die "No file names supplied!\n" unless @ARGV;
my $oldest_name = shift @ARGV;
my $oldest_age = -M $oldest_name;

foreach (@ARGV) {
  my $age = -M;
  ($oldest_name, $oldest_age) = ($_, $age)    
    if $age &gt; $oldest_age;
}

printf "The oldest file was %s, and it was %.1f days old.\n",
  $oldest_name, $oldest_age;</font color="#CC0000"></PRE><P class="docList">This one starts right out by complaining if it didn't get any
filenames on the command line. That's because it's
supposed to tell us the oldest filename—and there ain't
one if there aren't any files to check.
</P>
<P class="docList">Once again, we're using the "high-water-mark"
algorithm. The first file is certainly the oldest one seen so far. We
have to keep track of its age as well, so that's in
<TT><font color="#CC0000">$oldest_age</font color="#CC0000"></TT>.
</P>
<P class="docList">For each of the remaining files, we'll determine the age with
the <TT><font color="#CC0000">-M</font color="#CC0000"></TT> file test, just as we did for the first one
(except that here, we'll use the default argument of
<TT><font color="#CC0000">$_</font color="#CC0000"></TT> for the file test). The last-modified time is
generally what people mean by the "age" of a file,
although you could make a case for using a different one. If the age
is more than <TT><font color="#CC0000">$oldest_age</font color="#CC0000"></TT>, we'll use a list
assignment to update both the name and age. We didn't have to
use a list assignment, but it's a convenient way to update
several variables at once.
</P>
<P class="docList">We stored the age from <TT><font color="#CC0000">-M</font color="#CC0000"></TT> into the temporary
variable <TT><font color="#CC0000">$age</font color="#CC0000"></TT>. What would have happened if we had
simply used <TT><font color="#CC0000">-M</font color="#CC0000"></TT> each time, rather than using a
variable? Well, first, unless we used the special
<TT><font color="#CC0000">_</font color="#CC0000"></TT> filehandle, we would have been asking the
operating system for the age of the file each time, a potentially
slow operation (not that you'd notice unless you have hundreds
or thousands of files, and maybe not even then). More importantly,
though, we should consider what would happen if someone updated a
file while we're checking it. That is, first we see the age of
some file, and it's the oldest one seen so far. But before we
can get back to use <TT><font color="#CC0000">-M</font color="#CC0000"></TT> a second time, someone
modifies the file and resets the timestamp to the current time. Now
the age that we save into <TT><font color="#CC0000">$oldest_age</font color="#CC0000"></TT> is actually
the <span class="docEmphasis">youngest</span> age possible. The result would be
that we'd get the oldest file among the files tested from that
point on, rather than the oldest overall; this would be a tough
problem to debug!
</P>
<P class="docList">Finally, at the end of the program, we use
<TT><font color="#CC0000">printf</font color="#CC0000"></TT> to print out the name and age, with the
age rounded off to the nearest tenth of a day. Give yourself extra
credit if you went to the trouble to convert the age to a number of
days, hours, and minutes.
</P></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-11"></A>
<H3 class="docSection1Title">A.11 Answers to Chapter 12 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it, with a glob:</P><PRE><font color="#CC0000">print "Which directory? (Default is your home directory) ";
chomp(my $dir = &lt;STDIN&gt;);
if ($dir =~ /^\s*$/) {         # A blank line
  chdir or die "Can't chdir to your home directory: $!"; 
} else {
  chdir $dir or die "Can't chdir to '$dir': $!";
}

my @files = &lt;*&gt;;
foreach (@files) {
  print "$_\n";
}</font color="#CC0000"></PRE><P class="docList">First, we show a simple prompt, and read the desired directory,
chomping it as needed. (Without a chomp, we'd be trying to head
for a directory that ends in a newline—legal in Unix, and
therefore cannot be presumed to simply be extraneous by the
<TT><font color="#CC0000">chdir</font color="#CC0000"></TT> function.)
</P>
<P class="docList">Then, if the directory name is nonempty, we'll change to that
directory, aborting on a failure. If empty, the home directory is
selected instead.
</P>
<P class="docList">Finally, a glob on "star" pulls up all the names in the
(new) working directory, automatically sorted to alphabetical order,
and they're printed one at a time.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "Which directory? (Default is your home directory) ";
chomp(my $dir = &lt;STDIN&gt;);
if ($dir =~ /^\s*$/) {         # A blank line
  chdir or die "Can't chdir to your home directory:
$!"; 
} else {
  chdir $dir or die "Can't chdir to '$dir': $!";
}

my @files = &lt;.* *&gt;;       ## now includes .*
foreach (sort @files) {   ## now sorts
  print "$_\n";
}</font color="#CC0000"></PRE><P class="docList">Two differences from previous one: first, the glob now includes
"dot star", which matches all the names that
<span class="docEmphasis">do</span> begin with a dot. And second, we now must
sort the resulting list, because some of the names that begin with a
dot must be interleaved appropriately either before or after the list
of things without a beginning dot.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "Which directory? (Default is your home directory) ";
chomp(my $dir = &lt;STDIN&gt;);
if ($dir =~ /^\s*$/) {         # A blank line
  chdir or die "Can't chdir to your home directory:
$!"; 
} else {
  chdir $dir or die "Can't chdir to '$dir': $!";
}

opendir DOT, "." or die "Can't opendir dot: $!";
foreach (sort readdir DOT) {
  # next if /^\./; ##   if we were skipping dot files
  print "$_\n";
}</font color="#CC0000"></PRE><P class="docList">Again, same structure as the previous two programs, but now
we've chosen to open a directory handle. Once we've
changed the working directory, we want to open the current directory,
and we've shown that as the <TT><font color="#CC0000">DOT</font color="#CC0000"></TT> directory
handle.
</P>
<P class="docList">Why <TT><font color="#CC0000">DOT</font color="#CC0000"></TT>? Well, if the user asks for an absolute
directory name, like <TT><font color="#CC0000">/etc</font color="#CC0000"></TT>, there's no
problem opening it. But if the name is relative, like
<TT><font color="#CC0000">fred</font color="#CC0000"></TT>, let's see what would happen. First, we
<TT><font color="#CC0000">chdir</font color="#CC0000"></TT> to <TT><font color="#CC0000">fred</font color="#CC0000"></TT>, and then we want
to use <TT><font color="#CC0000">opendir</font color="#CC0000"></TT> to open it. But that would open
<TT><font color="#CC0000">fred</font color="#CC0000"></TT> in the new directory, not
<TT><font color="#CC0000">fred</font color="#CC0000"></TT> in the original directory. The only name we
can be sure will mean "the current directory" is
"<TT><font color="#CC0000">.</font color="#CC0000"></TT>", which always has that meaning (on
Unix and similar systems, at least).
</P>
<P class="docList">The <TT><font color="#CC0000">readdir</font color="#CC0000"></TT> function pulls up all the names of
the directory, which are then sorted, and displayed. If we had done
the first exercise this way, we would have skipped over the dot
files, and that's handled by the uncommenting the commented-out
line in the <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop.
</P>
<P class="docList">You may find yourself asking, "Why did we
<TT><font color="#CC0000">chdir</font color="#CC0000"></TT> first? You can use
<TT><font color="#CC0000">readdir</font color="#CC0000"></TT> and friends on any directory, not merely
on the current directory." Primarily, we wanted to give the
user the convenience of being able to get to their home directory
with a single keystroke. But this could be the start of a general
file-management utility program; maybe the next step would be to ask
the user which of the files in this directory should be moved to
offline tape storage, say.
</P></span></LI>
</OL></span>

<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-12"></A>
<H3 class="docSection1Title">A.12 Answers to Chapter 13 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">unlink @ARGV;</font color="#CC0000"></PRE><P class="docList">...or, if you want to warn the user of any problems:</P>
<PRE><font color="#CC0000">foreach (@ARGV) {
  unlink $_ or warn "Can't unlink '$_': $!, continuing...\n";
}</font color="#CC0000"></PRE><P class="docList">Here, each item from the command-invocation line is placed
individually into <TT><font color="#CC0000">$_</font color="#CC0000"></TT>, which is then used as the
argument to <TT><font color="#CC0000">unlink</font color="#CC0000"></TT>. If something goes wrong, the
warning gives the clue about why.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">use File::Basename;
use File::Spec;

my($source, $dest) = @ARGV;

if (-d $dest) {
  my $basename = basename $source;
  $dest = File::Spec-&gt;catfile($dest, $basename);
}

rename $source, $dest
  or die "Can't rename '$source' to '$dest': $!\n";</font color="#CC0000"></PRE><P class="docList">The workhorse in this program is the last statement, but the
remainder of the program is necessary when we are renaming into a
directory. First, after declaring the modules we're using, we
name the command-line arguments sensibly. If <TT><font color="#CC0000">$dest</font color="#CC0000"></TT>
is a directory, we need to extract the basename from the
<TT><font color="#CC0000">$source</font color="#CC0000"></TT> name and append it to the directory
(<TT><font color="#CC0000">$dest</font color="#CC0000"></TT>). Finally, once <TT><font color="#CC0000">$dest</font color="#CC0000"></TT> is
patched up if needed, the <TT><font color="#CC0000">rename</font color="#CC0000"></TT> does the deed.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">use File::Basename;
use File::Spec;

my($source, $dest) = @ARGV;

if (-d $dest) {
  my $basename = basename $source;
  $dest = File::Spec-&gt;catfile($dest, $basename);
}

link $source, $dest
  or die "Can't link '$source' to '$dest': $!\n";</font color="#CC0000"></PRE><P class="docList">As the hint in the exercise description said, this program is much
like the previous one. The difference is that we'll
<TT><font color="#CC0000">link</font color="#CC0000"></TT> rather than <TT><font color="#CC0000">rename</font color="#CC0000"></TT>. If
your system doesn't support hard links, you might have written
this as the last line:
</P>
<PRE><font color="#CC0000">print "Would link '$source' to '$dest'.\n";</font color="#CC0000"></PRE></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">use File::Basename;
use File::Spec;

my $symlink = $ARGV[0] eq '-s';
shift @ARGV if $symlink;

my($source, $dest) = @ARGV;
if (-d $dest) {
  my $basename = basename $source;
  $dest = File::Spec-&gt;catfile($dest, $basename);
}

if ($symlink) {
  symlink $source, $dest
    or die "Can't make soft link from '$source' to '$dest': $!\n";
} else {
  link $source, $dest
    or die "Can't make hard link from '$source' to '$dest': $!\n";
}</font color="#CC0000"></PRE><P class="docList">The first few lines of code (after the two <TT><font color="#CC0000">use</font color="#CC0000"></TT>
declarations) look at the first command-line argument, and if
it's "<TT><font color="#CC0000">-s</font color="#CC0000"></TT>", we're making a
symbolic link, so we note that as a true value for
<TT><font color="#CC0000">$symlink</font color="#CC0000"></TT>. If we saw that
"<TT><font color="#CC0000">-s</font color="#CC0000"></TT>", we then need to get rid of it
(in the next line). The next few lines are cut-and-pasted from the
previous exercise answers. Finally, based on the truth of
<TT><font color="#CC0000">$symlink</font color="#CC0000"></TT>, we'll choose either to create a
symbolic link or a hard link. We also updated the dying words to make
it clear which kind of link we were attempting.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">foreach (&lt;.* *&gt;) {
  my $dest = readlink $_;
  print "$_ -&gt; $dest\n" if defined $dest;
}</font color="#CC0000"></PRE><P class="docList">Each item resulting from the glob ends up in <TT><font color="#CC0000">$_</font color="#CC0000"></TT>
one by one. If the item is a symbolic link, then
<TT><font color="#CC0000">readlink</font color="#CC0000"></TT> returns a defined value, and the
location is displayed. If not, then the condition fails, and we skip
over it.
</P></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-13"></A>
<H3 class="docSection1Title">A.13 Answers to Chapter 14 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">chdir "/" or die "Can't chdir to root directory: $!";
exec "ls", "-l" or die "Can't exec ls: $!";</font color="#CC0000"></PRE><P class="docList">The first line changes the current working directory to the root
directory, as our particular hard-coded directory. The second line
uses the multiple-argument <TT><font color="#CC0000">exec</font color="#CC0000"></TT> function to send
the result to standard output. We could have used the single-argument
form just as well, but it doesn't hurt to do it this way.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">open STDOUT, "&gt;ls.out" or die "Can't write to ls.out: $!";
open STDERR, "&gt;ls.err" or die "Can't write to ls.err: $!";
chdir "/" or die "Can't chdir to root directory: $!";
exec "ls", "-l" or die "Can't exec ls: $!";</font color="#CC0000"></PRE><P class="docList">The first and second lines reopen <TT><font color="#CC0000">STDOUT</font color="#CC0000"></TT> and
<TT><font color="#CC0000">STDERR</font color="#CC0000"></TT> to a file in the current directory (before
we change directories). Then, after the directory change, the
directory listing command executes, sending the data back to the
files opened in the original directory.
</P>
<P class="docList">Where would the message from the last <TT><font color="#CC0000">die</font color="#CC0000"></TT> go?
Why, it would go into <I>ls.err</I>, of course, since
that's where <TT><font color="#CC0000">STDERR</font color="#CC0000"></TT> is going at that point.
The <TT><font color="#CC0000">die</font color="#CC0000"></TT> from <TT><font color="#CC0000">chdir</font color="#CC0000"></TT> would go
there, too. But where would the message go if we can't re-open
<TT><font color="#CC0000">STDERR</font color="#CC0000"></TT> on the second line? It goes to the old
<TT><font color="#CC0000">STDERR</font color="#CC0000"></TT>. For the three standard filehandles,
<TT><font color="#CC0000">STDIN</font color="#CC0000"></TT>, <TT><font color="#CC0000">STDOUT</font color="#CC0000"></TT>, and
<TT><font color="#CC0000">STDERR</font color="#CC0000"></TT>, if re-opening them fails, the old
filehandle is still open.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">if (`date` =~ /^S/) {
  print "go play!\n";
} else {
  print "get to work!\n";
}</font color="#CC0000"></PRE><P class="docList">Well, since both Saturday and Sunday start with an S, and the day of
the week is the first part of the output of the
<I>date</I> command, this is pretty simple. Just check
the output of the <I>date</I> command to see if it starts
with <TT><font color="#CC0000">S</font color="#CC0000"></TT>. There are many harder ways to do this
program, and we've seen most of them in our classes.
</P>
<P class="docList">If we had to use this in a real-world program, though, we'd
probably use the pattern <TT><font color="#CC0000">/^(Sat|Sun)/</font color="#CC0000"></TT>. It's
a tiny bit less efficient, but that hardly matters; besides,
it's so much easier for the maintenance programmer to
understand.
</P></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-14"></A>
<H3 class="docSection1Title">A.14 Answers to Chapter 15 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">my @numbers;
push @numbers, split while &lt;&gt;;
foreach (sort { $a &lt;=&gt; $b } @numbers) {
  printf "%20g\n", $_;
}</font color="#CC0000"></PRE><P class="docList">That second line of code is too confusing, isn't it? Well, we
did that on purpose. Although we recommend that you write clear code,
some people like writing code that's as hard to understand as
possible,<sup class="docFootnote"><A class="docLink" HREF="#">[A]</A></sup> so we want you to be prepared for the worst. Someday,
you'll need to maintain confusing code like this.
</P> <blockquote><p class="docFootnote"><sup><A NAME="">[A]</A></sup> Well, we don't recommend it for
<span class="docEmphasis">normal</span> coding purposes, but it can be a fun game
to write confusing code, and it can be educational to take someone
else's obfuscated code examples and spend a weekend or two
figuring out just what they do. If you want to see some fun snippets
of such code and maybe get a little help with decoding them, ask
around at the next Perl Mongers' meeting. Or search for JAPHs
on the Web, or see how well you can decipher the example obfuscated
code block near the end of this chapter's answers. </p></blockquote>
<P class="docList">Since that line uses the <TT><font color="#CC0000">while</font color="#CC0000"></TT> modifier,
it's the same as if it were written in a loop like this:
</P>
<PRE><font color="#CC0000">while (&lt;&gt;) {
  push @numbers, split;
}</font color="#CC0000"></PRE><P class="docList">That's better, but maybe it's still a little unclear.
(Nevertheless, we don't have a quibble about writing it this
way. This one is on the correct side of the "too hard to
understand at a glance" line.) The <TT><font color="#CC0000">while</font color="#CC0000"></TT>
loop is reading the input a line at a time (from the user's
choice of input sources, as shown by the diamond operator), and
<TT><font color="#CC0000">split</font color="#CC0000"></TT> is, by default, splitting that on whitespace
to make a list of words—or, in this case, a list of numbers.
The input is just a stream of numbers separated by whitespace, after
all. Either way that you write it, then, that
<TT><font color="#CC0000">while</font color="#CC0000"></TT> loop will put all of the numbers from the
input into <TT><font color="#CC0000">@numbers</font color="#CC0000"></TT>.
</P>
<P class="docList">The <TT><font color="#CC0000">foreach</font color="#CC0000"></TT> loop takes the sorted list and prints
each one on its own line, using the <TT><font color="#CC0000">%20g</font color="#CC0000"></TT> numeric
format to put them in a right-justified column. You could have used
<TT><font color="#CC0000">%20s</font color="#CC0000"></TT> instead. What difference would that make?
Well, that's a string format, so it would have left the strings
untouched in the output. Did you notice that our sample data included
both <TT><font color="#CC0000">1.50</font color="#CC0000"></TT> and <TT><font color="#CC0000">1.5</font color="#CC0000"></TT>, and both
<TT><font color="#CC0000">04</font color="#CC0000"></TT> and <TT><font color="#CC0000">4</font color="#CC0000"></TT>? If you printed those
as strings, the extra zero characters will still be in the output;
but <TT><font color="#CC0000">%20g</font color="#CC0000"></TT> is a numeric format, so equal numbers
will appear identically in the output. Either format could
potentially be correct, depending upon what you're trying to
do.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000"># don't forget to incorporate the hash %last_name,
# either from the exercise text or the downloaded file

my @keys = sort {
  "\L$last_name{$a}" cmp "\L$last_name{$b}"  # by last name
   or
  "\L$a" cmp "\L$b"                          # by first name
} keys %last_name;

foreach (@keys) {
  print "$last_name{$_}, $_\n";              # Rubble,Bamm-Bamm
}</font color="#CC0000"></PRE><P class="docList">There's not much to say about this one; we put the keys in
order as needed, then print them out. We chose to print them in
last-name-comma-first-name order just for fun; the exercise
description left that up to you.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">print "Please enter a string: ";
chomp(my $string = &lt;STDIN&gt;);
print "Please enter a substring: ";
chomp(my $sub = &lt;STDIN&gt;);

my @places;

for (my $pos = -1; ; ) {                  # tricky use of three-part for loop
  $pos = index($string, $sub, $pos + 1);  # find next position
  last if $pos == -1;
  push @places, $pos;
}

print "Locations of '$sub' in '$string' were: @places\n";</font color="#CC0000"></PRE><P class="docList">This one starts out simply enough, asking the user for the strings
and declaring an array to hold the list of substring positions. But
once again, as we see in the <TT><font color="#CC0000">for</font color="#CC0000"></TT> loop, the code
seems to have been "optimized for cleverness", which
should be done only for fun, never in production code. But this
actually shows a valid technique which could be useful in some cases,
so let's see how it works.
</P>
<P class="docList">The <TT><font color="#CC0000">my</font color="#CC0000"></TT> variable <TT><font color="#CC0000">$pos</font color="#CC0000"></TT> is
declared private to the scope of the <TT><font color="#CC0000">for</font color="#CC0000"></TT> loop, and
it starts with a value of <TT><font color="#CC0000">-1</font color="#CC0000"></TT>. So as not to keep
you in suspense about this variable, we'll tell you right now
that it's going to hold a position of the substring in the
larger string. The test and increment sections of the
<TT><font color="#CC0000">for</font color="#CC0000"></TT> loop are empty, so this is an infinite loop.
(Of course, we'll eventually break out of it, in this case with
<TT><font color="#CC0000">last</font color="#CC0000"></TT>).
</P>
<P class="docList">The first statement of the loop body looks for the first occurrence
of the substring at or after position <TT><font color="#CC0000">$pos + 1</font color="#CC0000"></TT>.
That means that on the first iteration, when <TT><font color="#CC0000">$pos</font color="#CC0000"></TT>
is still <TT><font color="#CC0000">-1</font color="#CC0000"></TT>, the search will start at position
<TT><font color="#CC0000">0</font color="#CC0000"></TT>, the start of the string. The location of the
substring is stored back into <TT><font color="#CC0000">$pos</font color="#CC0000"></TT>. Now, if that
was <TT><font color="#CC0000">-1</font color="#CC0000"></TT>, we're done with the
<TT><font color="#CC0000">for</font color="#CC0000"></TT> loop, so <TT><font color="#CC0000">last</font color="#CC0000"></TT> breaks out of
the loop in that case. If it wasn't <TT><font color="#CC0000">-1</font color="#CC0000"></TT>, then
we save the position into <TT><font color="#CC0000">@places</font color="#CC0000"></TT> and go around
the loop again. This time, <TT><font color="#CC0000">$pos + 1</font color="#CC0000"></TT> means that
we'll start looking for the substring just after the previous
place where we found it. And so we get the answers we wanted and the
world is once again a happy place.
</P>
<P class="docList">If you didn't want that tricky use of the
<TT><font color="#CC0000">for</font color="#CC0000"></TT> loop, you could accomplish the same result as
shown here:
</P>
<PRE><font color="#CC0000">{
  my $pos = -1;
  while (1) {
    ... # Same loop body as the for loop used above
  }
}</font color="#CC0000"></PRE><P class="docList">The naked block on the outside restricts the scope of
<TT><font color="#CC0000">$pos</font color="#CC0000"></TT>. You don't have to do that, but
it's often a good idea to declare each variable in the smallest
possible scope. This means we have fewer variables
"alive" at any given point in the program, making it less
likely that we'll accidentally reuse the name
<TT><font color="#CC0000">$pos</font color="#CC0000"></TT> for some new purpose. For the same reason, if
you don't declare a variable in a small scope, you should
generally give it a longer name that's thereby less likely to
be reused by accident. Maybe something like
<TT><font color="#CC0000">$substring_position</font color="#CC0000"></TT> would be appropriate in this
case.
</P>
<P class="docList">On the other hand, if you were <span class="docEmphasis">trying</span> to
obfuscate your code (shame on you!), you could create a monster like
this (shame on us!):
</P>
<PRE><font color="#CC0000">for (my $pos = -1; -1 != 
  ($pos = index 
    +$string,
    +$sub,
    +$pos
    +1
  );
push @places, ((((+$pos))))) {
    'for ($pos != 1; # ;$pos++) {
      print "position $pos\n";#;';#' } pop @places;
}</font color="#CC0000"></PRE><P class="docList">That even trickier code works in place of the original tricky
<TT><font color="#CC0000">for</font color="#CC0000"></TT> loop. By now, you should know enough to be
able to decipher that one on your own, or to obfuscate code in order
to amaze your friends and confound your enemies. Be sure to use these
powers only for good, never for evil.
</P>
<P class="docList">Oh, and what did you get when you searched for <TT><font color="#CC0000">t</font color="#CC0000"></TT>
in <TT><font color="#CC0000">This is a test.</font color="#CC0000"></TT>? It's at positions
<TT><font color="#CC0000">10</font color="#CC0000"></TT> and <TT><font color="#CC0000">13</font color="#CC0000"></TT>. It's not at
position <TT><font color="#CC0000">0</font color="#CC0000"></TT>; since the capitalization doesn't
match, the substring doesn't match.
</P></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-15"></A>
<H3 class="docSection1Title">A.15 Answers to Chapter 16 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">open PF, '/path/to/perlfunc.pod' or die "Can't open perlfunc.pod: $!";
dbmopen my %DB, "pf_data", 0644 or die "Can't create dbm file: $!";

%DB = ( );  # wipe existing data, if any

while (&lt;PF&gt;) {
  if (/^=item\s+([a-z_]\w*)/i) {
    $DB{$1} = $DB{$1} || $.;
  }
}

print "Done!\n";</font color="#CC0000"></PRE><P class="docList">This one is similar to the previous ones with
<I>perlfunc.pod</I>. Here, though, we open a DBM file
called <I>pf_data</I> as the DBM hash
<TT><font color="#CC0000">%DB</font color="#CC0000"></TT>. In case that file had any leftover data, we
set the hash to an empty list. That's normally a rare thing to
do, but we want to wipe out the entire database, in case a previous
run of this program left incorrect or out-of-date data in the file.
(After all, there's a new <I>perlfunc.pod</I>
with each new release of Perl.)
</P>
<P class="docList">When we find an identifier, we need to store its line number (from
<TT><font color="#CC0000">$.</font color="#CC0000"></TT>) into the database. The statement that does
that uses the high-precedence short-circuit <TT><font color="#CC0000">||</font color="#CC0000"></TT>
operator. If the database entry already has a value, that value is
true, so the old value is used. If the database entry is empty,
that's false, so the value on the right (<TT><font color="#CC0000">$.</font color="#CC0000"></TT>)
is used instead. We could have written that line in a shorter way,
like this:
</P>
<PRE><font color="#CC0000">$DB{$1} ||= $.;</font color="#CC0000"></PRE><P class="docList">When the program is done, it says so. That's not required by
the exercise description, but it lets us know that the program did
something; without that line, there would be no output at all. But
how can we tell that it worked correctly? That's the next
exercise.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">dbmopen my %DB, "pf_data", undef or die "Can't open dbm file: $!";
my $line = $DB{$ARGV[0]} || "not found";

print "$ARGV[0]: $line\n";</font color="#CC0000"></PRE><P class="docList">Once we have the database, it's simple to look something up in
it. Note that in this program, the third argument to
<TT><font color="#CC0000">dbmopen</font color="#CC0000"></TT> is <TT><font color="#CC0000">undef</font color="#CC0000"></TT>, since that
file must already exist for this program to work.
</P>
<P class="docList">If the entry for <TT><font color="#CC0000">$ARGV[0]</font color="#CC0000"></TT> (the first command-line
parameter) isn't found in the database, we'll say
it's <TT><font color="#CC0000">not found</font color="#CC0000"></TT>, using the high-precedence
short-circuit <TT><font color="#CC0000">||</font color="#CC0000"></TT>.
</P></span></LI>
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">dbmopen my %DB, "pf_data", undef or die "Can't open dbm file: $!";

if (my $line = $DB{$ARGV[0]}) {
  exec 'less', "+$line", '/path/to/perlfunc.pod'
    or die "Can't exec pager: $!";
} else {
  die "Entry unknown: '$ARGV[0]'.\n";
}</font color="#CC0000"></PRE><P class="docList">This starts out like the previous one, but uses
<TT><font color="#CC0000">exec</font color="#CC0000"></TT> to start up a pager program if it can, and
dies if it can't.
</P></span></LI>
</OL></span>

<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-A-SECT-16"></A>
<H3 class="docSection1Title">A.16 Answer to Chapter 17 Exercises</H3>

<span style="font-weight:bold"><OL class="docList" TYPE="1">
<LI><span style="font-weight:normal"><P class="docList">Here's one way to do it:</P><PRE><font color="#CC0000">my $filename = 'path/to/sample_text';
open FILE, $filename
  or die "Can't open '$filename': $!";
chomp(my @strings = &lt;FILE&gt;);
while (1) {
  print "Please enter a pattern: ";
  chomp(my $pattern = &lt;STDIN&gt;);
  last if $pattern =~ /^\s*$/;
  my @matches = eval {
    grep /$pattern/, @strings;
  };
  if ($@) {
    print "Error: $@";
  } else {
    my $count = @matches;
    print "There were $count matching strings:\n",
      map "$_\n", @matches;
  }
  print "\n";
}</font color="#CC0000"></PRE><P class="docList">This one uses an <TT><font color="#CC0000">eval</font color="#CC0000"></TT> block to trap any failure
that might occur when using the regular expression. Inside that
block, a <TT><font color="#CC0000">grep</font color="#CC0000"></TT> pulls the matching strings from the
list of strings.
</P>
<P class="docList">Once the <TT><font color="#CC0000">eval</font color="#CC0000"></TT> is finished, we can report either
the error message or the matching strings. Note that we
"unchomped" the strings for output by using
<TT><font color="#CC0000">map</font color="#CC0000"></TT> to add a newline to each string<A NAME="IXTR3-0"></A> <A NAME="IXTR3-1"></A>.
</P></span></LI>
</OL></span>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-B"></A>

<H2 class="docAppendixTitle">Appendix B. Beyond the Llama</H2>

<P class="docText">We've covered a lot in this book, but there's even more.
In this appendix, we'll tell about a little more of what Perl
can do, and give some references on where to learn the details. Some
of what we mention here is on the bleeding edge and may have changed
by the time that you're reading this book, which is one reason
why we frequently send you to the documentation for the full story.
We don't expect many readers to read every word of this
appendix, but we hope you'll at least skim the headings so that
you'll be prepared to fight back when someone tells you
"You just can't use Perl for project X, because Perl
can't do Y."
</P>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-B-SECT-1"></A>
<H3 class="docSection1Title">B.1 Further Documentation</H3>

<P class="docText">The <A NAME="IXT-B-335546"></A>
<A NAME="IXT-B-335547"></A>documentation that comes with Perl may
seem overwhelming at first. Fortunately, you can use your computer to
search for keywords in the documentation. When searching for a
particular topic, it's often good to start with the
<span class="docEmphasis">perltoc</span><A NAME="IXT-B-335548"></A> (table of contents) and
<span class="docEmphasis">perlfaq</span><A NAME="IXT-B-335549"></A> (frequently asked questions) sections.
On most systems, the <I>perldoc</I> command should be
able to track down the documentation for Perl, installed modules, and
related programs (including
<I>perldoc</I><A NAME="IXT-B-335550"></A> itself).
</P>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-B-SECT-2"></A>
<H3 class="docSection1Title">B.2 Regular expressions</H3>

<P class="docText">Yes, there's even more about regular expressions than we
mentioned. <span class="docEmphasis">Mastering Regular Expressions</span> by
Jeffrey <A NAME="IXT-B-335551"></A>
<A NAME="IXT-B-335552"></A> <A NAME="IXT-B-335553"></A>Friedl is one of the best technical
books we've ever read.<sup class="docFootnote"><A class="docLink" HREF="#">[B]</A></sup>
It's half about regular expressions in general, and half about
Perl's regular expressions. It goes into good detail about how
the <A NAME="IXT-B-335554"></A>regular expression engine works
internally, and why one way of writing a pattern may be much more
efficient than another. Anyone who is serious about Perl should read
this book. Also see the
<span class="docEmphasis">perlre</span><A NAME="IXT-B-335555"></A> <A NAME="IXT-B-335556"></A> <A NAME="IXT-B-335557"></A> manpage (and its companion
<span class="docEmphasis">perlretut</span> and <span class="docEmphasis">perlrequick</span>
manpages in newer versions of Perl).
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[B]</A></sup> And we're not just
saying that because it's also published by O'Reilly &amp;
Associates, Inc. It's really a great book.</p></blockquote>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-B-SECT-3"></A>
<H3 class="docSection1Title">B.3 Packages</H3>

<P class="docText">Packages<sup class="docFootnote"><A class="docLink" HREF="#">[B]</A></sup> allow you to
compartmentalize the namespaces. Imagine that you have ten
programmers all working on one big project. If you use the global
names <TT><font color="#CC0000">$fred</font color="#CC0000"></TT>, <TT><font color="#CC0000">@barney</font color="#CC0000"></TT>,
<TT><font color="#CC0000">%betty</font color="#CC0000"></TT>, and <TT><font color="#CC0000">&amp;wilma</font color="#CC0000"></TT> in your
part of the project, what happens when I accidentally use one of
those same names in my part?
<A NAME="IXT-B-335559"></A>Packages let us
keep these separate; I can access your <TT><font color="#CC0000">$fred</font color="#CC0000"></TT>, and
you can access mine, but not by accident. Packages are needed to make
Perl scalable, so that we can manage large programs.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[B]</A></sup> The name "package" is perhaps an
unfortunate choice, in that it makes many people think of a
packaged-up chunk of code (in Perl, that's a module or a
library). All that a package does is define a
<A NAME="IXT-B-335558"></A>namespace (a collection of global symbol
names, like <TT><font color="#CC0000">$fred</font color="#CC0000"></TT> or
<TT><font color="#CC0000">&amp;wilma</font color="#CC0000"></TT>). A namespace is <span class="docEmphasis">not</span>
a chunk of code. </p></blockquote>


<ul></ul>
</td>
</tr>
</table><hr size="1"><br><table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="lperl3-APP-B-SECT-4"></A>
<H3 class="docSection1Title">B.4 Extending Perl's Functionality</H3>

<P class="docText">One of the most common pieces of good advice heard in the Perl
discussion forums is that you shouldn't reinvent the wheel.
Other folks have written code that you can put to use. The most
frequent way to add to what
<A NAME="IXT-B-335560"></A>Perl can do is by using a library or
module. Many of these come with Perl, while others are available from
CPAN. Of course, you can even write your own libraries and modules.
</P>

<A NAME="lperl3-APP-B-SECT-4.1"></A>
<H4 class="docSection2Title">B.4.1 Libraries</H4>

<P class="docText">Many programming languages offer support for
<A NAME="IXT-B-335561"></A>libraries much as
Perl does. Libraries are collections of (mostly) subroutines for a
given purpose. In modern Perl, though, it's more common to use
modules than libraries.
</P>


<A NAME="lperl3-APP-B-SECT-4.2"></A>
<H4 class="docSection2Title">B.4.2 Modules</H4>

<P class="docText"><A NAME="lperl3-IDXTERM-1139"></A>A
module is a "smart library". A module will typically
offer a collection of subroutines that act as if they were built in
functions, for the most part. Modules are smart in that they keep
their details in a separate package, only importing what you request.
This keeps a module from stomping on your code's symbols.
</P>

<P class="docText">Although many useful modules are written in pure Perl, others are
written using a language like C. For example, the MD5 algorithm is
sort of like a high-powered checksum.<sup class="docFootnote"><A class="docLink" HREF="#">[B]</A></sup> It uses a lot of low-level
bit-twiddling that could be done in Perl, but hundreds of times more
slowly;<sup class="docFootnote"><A class="docLink" HREF="#">[B]</A></sup> it's an algorithm that was
designed to be efficiently implemented in C. So, the
<TT><font color="#CC0000">Digest::MD5</font color="#CC0000"></TT> module is made to use the compiled C
code. When you use that module, it's as if your Perl had a
built in function to calculate MD5 digests.
</P>
<blockquote><p class="docFootnote"><sup><A NAME="">[B]</A></sup> It's not
really a checksum, but that's good enough for this
explanation.</p></blockquote>
<blockquote><p class="docFootnote"><sup><A NAME="">[B]</A></sup> The module <TT><font color="#CC0000">Digest::Perl::MD5</font color="#CC0000"></TT>
is a pure Perl implementation of the MD5 algorithm.
Although your mileage may vary, we found it to be about 280 times
slower than the <TT><font color="#CC0000">Digest::MD5</font color="#CC0000"></TT> module on one sample
dataset. Remember that many of the bit-twiddling operations in the C
algorithm compile down to a <span class="docEmphasis">single</span> machine
instruction; thus, entire lines of code can take a mere handful of
clock cycles to run. Perl is fast, but let's not be
unrealistic. </p></blockquote>


<A NAME="lperl3-APP-B-SECT-4.3"></A>
<H4 class="docSection2Title">B.4.3 Finding and Installing Modules</H4>

<P class="docText">Maybe your system already has the module you need. But how can you
find out which modules are installed? You can use the program
<I>inside</I>,<A NAME="IXT-B-335562"></A>
<A NAME="IXT-B-335563"></A>
which should be available for download from <A NAME="IXT-B-335564"></A>CPAN in the directory
<A class="docLink" target="_blank" HREF="http://www.cpan.org/authors/id/P/PH/PHOENIX/">http://www.cpan.org/authors/id/P/PH/PHOENIX/</A>.
</P>

<P class="docText">If none of the modules already available on your system suits your
needs, you can search for Perl modules on <A NAME="IXT-B-335565"></A> <A NAME="IXT-B-335566"></A>CPAN at
<A NAME="IXT-B-335567"></A><A class="docLink" target="_blank" HREF="http://search.cpan.org/">http://search.cpan.org/</A>. To install a module
on your system, see the
<TT><font color="#CC0000">perlmodinstall</font color="#CC0000"></TT><A NAME="IXT-B-335568"></A> manpage.
</P>

<P class="docText">When using a module, you'll generally put the required
<TT><font color="#CC0000">use</font color="#CC0000"></TT><A NAME="IXT-B-335569"></A> directives at the top of your
program. That makes it easy for someone who is installing your
program on a new system to see at a glance which modules it needs.
</P>


<A NAME="lperl3-APP-B-SECT-4.4"></A>
<H4 class="docSection2Title">B.4.4 Writing Your Own Modules</H4>

<P class="docText">In the rare case that there's no module to do what you need, an
advanced programmer can write a new one, either in Perl or in another
language (often C). See the
<TT><font color="#CC0000">perlmod</font color="#CC0000"></TT><A NAME="IXT-B-335570"></A> <A NAME="IXT-B-335571"></A> and <TT><font color="#CC0000">perlmodlib</font color="#CC0000"></TT>
manpages for more information.  ... didnt copy the rest of app B or the index
</P>



<a href="?xmlid=0-596-00132-0/18961533"><img src="images/pixel.gif" width="1" height="1" border="0"></a><ul></ul>
</td>
</tr>
</table>

<a href="perl1.html">page 1</a><br>
<a href="perl2.html">page 2</a><br>
<a href="perl3.html">page 3</a><br>
<a href="perl4.html">page 4</a><br>
 
</body></html>